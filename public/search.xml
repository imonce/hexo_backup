<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SQL语句命令执行顺序]]></title>
    <url>%2F2019%2F11%2F06%2FSQL%E8%AF%AD%E5%8F%A5%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[op1=>operation: from + join op2=>operation: where op3=>operation: group by op4=>operation: having op5=>operation: select op6=>operation: order by op7=>operation: limit op1->op2->op3->op4->op5->op6->op7{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[启发式算法学习（二）：模拟退火算法]]></title>
    <url>%2F2019%2F11%2F06%2F%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法简介模拟退火算法的思想借鉴于固体的退火原理，当固体的温度很高的时候，内能比较大，固体的内部粒子处于快速无序运动，当温度慢慢降低的过程中，固体的内能减小，粒子的慢慢趋于有序，最终，当固体处于常温时，内能达到最小，此时，粒子最为稳定。模拟退火算法便是基于这样的原理设计而成。 模拟退火算法从某一高温出发，在高温状态下计算初始解，然后以预设的邻域函数产生一个扰动量，从而得到新的状态，即模拟粒子的无序运动，比较新旧状态下的能量，即目标函数的解。如果新状态的能量小于旧状态，则状态发生转化；如果新状态的能量大于旧状态，则以一定的概率准则发生转化。当状态稳定后，便可以看作达到了当前状态的最优解，便可以开始降温，在下一个温度继续迭代，最终达到低温的稳定状态，便得到了模拟退火算法产生的结果。 算法过程 状态空间与邻域函数状态空间也称为搜索空间，它由经过编码的可行解的集合所组成。而邻域函数应尽可能满足产生的候选解遍布全部状态空间。其通常由产生候选解的方式和候选解产生的概率分布组成。候选解一般按照某一概率密度函数对解空间进行随机采样获得，而概率分布可以为均匀分布、正态分布、指数分布等。 状态概率分布（Metropolis准则）状态转移概率是指从一个状态转换成另一个状态的概率，模拟退火算法中一般采用Metropolis准则，具体如下： $$f(x)=\left{\begin{aligned}1 &amp; , &amp; E(x_{new}) &lt; E(x_{old}) \exp(-\frac{E(x_{new})-E(x_{old})}{T}) &amp; , &amp; E(x_{new}) \ge E(x_{old})\end{aligned}\right.$$ 其与当前温度参数T有关，随温度的下降而减小。 冷却进度表冷却进度表是指从某一高温状态T向低温状态冷却时的降温函数,设时刻的温度为T(t)，则经典模拟退火算法的降温方式为： $$T(t)=\frac{T_{0}}{lg(1+t)}$$ 而快速模拟退火算法的降温方式为： $$T(t)=\frac{T_{0}}{1+t}$$ 其他方法不再赘述。 初始温度一般来说，初始温度越大，获得高质量解的几率越大，但是花费的时间也会随之增加，因此，初温的确定应该同时考虑计算效率与优化质量，常用的方法包括： 均匀抽样一组状态，以各状态目标值的方差为初温。 随机产生一组状态，确定两两状态间的最大目标值差，然后根据差值，利用一定的函数确定初温，如： $T_{0}=-\frac{\Delta_{max}}{Pr}$ ,其中Pr为初始接受概率。 根据经验公式给出。 循环终止准则内循环（求解循环）终止准则： 检验目标函数的均值是否稳定 连续若干步的目标值变化较小 按一定的步数进行抽样 外循环（降温循环）终止准则： 设置终止温度 设置外循环迭代次数 算法搜索到的最优值连续若干步保持不变 检验系统熵是否稳定 Python实现实例函数： $f(x)=(x^{2}-5x)sin(x^2)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import numpy as npimport matplotlib.pyplot as pltimport randomclass SA(object): def __init__(self, interval, tab='min', T_max=10000, T_min=1, iterMax=1000, rate=0.95): self.interval = interval # 给定状态空间 - 即待求解空间 self.T_max = T_max # 初始退火温度 - 温度上限 self.T_min = T_min # 截止退火温度 - 温度下限 self.iterMax = iterMax # 定温内部迭代次数 self.rate = rate # 退火降温速度 self.x_seed = random.uniform(interval[0], interval[1]) # 解空间内的种子 self.tab = tab.strip() # 求解最大值还是最小值的标签: 'min' - 最小值；'max' - 最大值 self.solve() # 完成主体的求解过程 self.display() # 数据可视化展示 def solve(self): temp = 'deal_' + self.tab # 采用反射方法提取对应的函数 if hasattr(self, temp): deal = getattr(self, temp) else: exit('&gt;&gt;&gt;tab标签传参有误："min"|"max"&lt;&lt;&lt;') x1 = self.x_seed T = self.T_max while T &gt;= self.T_min: for i in range(self.iterMax): f1 = self.func(x1) delta_x = random.random() * 2 - 1 # [-1,1)之间的随机值 if x1 + delta_x &gt;= self.interval[0] and x1 + delta_x &lt;= self.interval[1]: # 将随机解束缚在给定状态空间内 x2 = x1 + delta_x else: x2 = x1 - delta_x f2 = self.func(x2) delta_f = f2 - f1 x1 = deal(x1, x2, delta_f, T) T *= self.rate self.x_solu = x1 # 提取最终退火解 def func(self, x): # 状态产生函数 - 即待求解函数 value = np.sin(x**2) * (x**2 - 5*x) return value def p_min(self, delta, T): # 计算最小值时，容忍解的状态迁移概率 probability = np.exp(-delta/T) return probability def p_max(self, delta, T): probability = np.exp(delta/T) # 计算最大值时，容忍解的状态迁移概率 return probability def deal_min(self, x1, x2, delta, T): if delta &lt; 0: # 更优解 return x2 else: # 容忍解 P = self.p_min(delta, T) if P &gt; random.random(): return x2 else: return x1 def deal_max(self, x1, x2, delta, T): if delta &gt; 0: # 更优解 return x2 else: # 容忍解 P = self.p_max(delta, T) if P &gt; random.random(): return x2 else: return x1 def display(self): print('seed: &#123;&#125;\nsolution: &#123;&#125;'.format(self.x_seed, self.x_solu)) plt.figure(figsize=(6, 4)) x = np.linspace(self.interval[0], self.interval[1], 300) y = self.func(x) plt.plot(x, y, 'g-', label='function') plt.plot(self.x_seed, self.func(self.x_seed), 'bo', label='seed') plt.plot(self.x_solu, self.func(self.x_solu), 'r*', label='solution') plt.title('solution = &#123;&#125;'.format(self.x_solu)) plt.xlabel('x') plt.ylabel('y') plt.legend() plt.savefig('SA.png', dpi=500) plt.show() plt.close() if __name__ == '__main__': SA([-5, 5], 'max') Referencehttps://www.imooc.com/article/30160https://baike.baidu.com/item/模拟退火算法/355508?fr=aladdinhttps://blog.csdn.net/google19890102/article/details/45395257https://www.cnblogs.com/xxhbdk/p/9192750.htmlflowchat st=>start: Start op1=>operation: 随机生成初始解w，计算目标函数f(w) op2=>operation: 扰动产生新解w'，计算目标函数f(w') op3=>operation: 接受新解，w=w',f(w)=f(w') op4=>operation: 按照Metropolis准则接受新解 op5=>operation: 缓慢降低温度，重置迭代次数 op6=>operation: 运算结束，返回最优解 cond1=>condition: f(w')-f(w)condition: 是否达到迭代次数? cond3=>condition: 满足终止条件? ed=>end: End st->op1->op2->cond1 cond1(yes)->op3->cond2 cond1(no)->op4->cond2 cond2(yes)->cond3 cond2(no)->op2 cond3(yes)->op6->end cond3(no)->op5(top)->op2{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>启发式算法</category>
      </categories>
      <tags>
        <tag>启发式算法</tag>
        <tag>模拟退火算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[启发式算法学习（一）：粒子群算法]]></title>
    <url>%2F2019%2F11%2F06%2F%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法简介粒子群算法（Particle swarm optimization，PSO）是模拟群体智能所建立起来的一种优化算法，主要用于解决最优化问题（optimization problems）。1995年由 Eberhart和Kennedy 提出，是基于对鸟群觅食行为的研究和模拟而来的。 假设一群鸟在觅食，在觅食范围内，只在一个地方有食物，所有鸟儿都看不到食物（即不知道食物的具体位置。当然不知道了，知道了就不用觅食了），但是能闻到食物的味道（即能知道食物距离自己是远是近。鸟的嗅觉是很灵敏的）。 假设鸟与鸟之间能共享信息（即互相知道每个鸟离食物多远。这个是人工假定，实际上鸟们肯定不会也不愿意），那么最好的策略就是结合自己离食物最近的位置和鸟群中其他鸟距离食物最近的位置这2个因素综合考虑找到最好的搜索位置。 粒子群算法与《遗传算法》等进化算法有很多相似之处。也需要初始化种群，计算适应度值，通过进化进行迭代等。但是与遗传算法不同，它没有交叉，变异等进化操作。与遗传算法比较，PSO的优势在于很容易编码，需要调整的参数也很少。 核心概念PSO有几个核心概念： 粒子（particle）：一只鸟。类似于遗传算法中的个体。 种群（population）：一群鸟。类似于遗传算法中的种群。 位置（position）：一个粒子（鸟）当前所在的位置。 经验（best）：一个粒子（鸟）自身曾经离食物最近的位置。 速度（velocity ）：一个粒子（鸟）飞行的速度。 适应度（fitness）：一个粒子（鸟）距离食物的远近。与遗传算法中的适应度类似。 算法过程 算法说明两个核心公式加速度更新公式： $$v[i] = w * v[i] + c1 * rand() *(pbest[i] - present[i]) + c2 * rand() * (gbest - present[i])$$ 其中v[i]代表第i个粒子的速度，w代表惯性权值,c1和c2表示学习参数，rand()表示在0-1之间的随机数,pbest[i]代表第i个粒子搜索到的最优值,gbest代表整个集群搜索到的最优值,present[i]代表第i个粒子的当前位置。 位置更新公式： $$present[i]=present[i]+v[i]$$ 解释说明1.粒子数：粒子数的选取一般在20个到40个之间，但是需要具体问题具体对待，如果对于复杂问题，则需要设置更多的粒子，粒子数量越多，其搜索范围就越大。 2.惯性因子 $w$ ：用来控制继承多少粒子当前的速度的，越大则对于当前速度的继承程度越小，越小则对于当前速度的继承程度越大。有些同学可能会产生疑问，是不是说反了。其实不是，从公式中可以明确看出，其值越大，则速度的改变幅度就越大，则对于粒子的当前速度继承越小；反之，速度的改变幅度越小，则对于粒子当前速度继承越大。因此如果的值越大，则解的搜索范围越大，可以提高算法的全局搜索能力，但也损失了局部搜索能力，有可能错失最优解；反之如果的值越小，则解的搜索范围也就越小，算法的全局搜索能力也就越小，容易陷入局部最优。如果是变量，则其值应该随着迭代次数的增加而减小（类似于梯度下降当中的学习率）。如果为定值，则建议在0.6到0.75之间进行选取。 3.加速常数 $c1,c2$ ：通过公式一可以看出，加速常数控制着飞翔速度的计算是更加看重自身经验还是群体经验。公式一中的第二项就是自身经验的体现，加速常数可以看做是用来调整自身经验在计算粒子飞翔速度上的权重。同理是用来控制群体经验在计算粒子飞翔速度过程中的权重的。如果为0，则自身经验对于速度的计算不起作用，如果为0，则群体经验对于粒子飞翔速度的计算不起作用。的取值在学术界分歧很大主要有如下几种情况： 学者 参数取值 Clerc c1=c2=2.05 Carlisle c1=2.8, c2=1.3 Trelea w=0.6, c1=c2=1.7 Eberhart w=0.729, c1=c2=1.494 python实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# -*- coding: utf-8 -*-"""f(x1,x2) = x1**2 + x2**2, x1,x2 belongs to [-10,10],求Min f"""import matplotlib.pyplot as pltimport numpy as np class PSO(object): def __init__(self, population_size, max_steps): self.w = 0.6 # 惯性权重 self.c1 = self.c2 = 2 self.population_size = population_size # 粒子群数量 self.dim = 2 # 搜索空间的维度 self.max_steps = max_steps # 迭代次数 self.x_bound = [-10, 10] # 解空间范围 self.x = np.random.uniform(self.x_bound[0], self.x_bound[1], (self.population_size, self.dim)) # 初始化粒子群位置 self.v = np.random.rand(self.population_size, self.dim) # 初始化粒子群速度 fitness = self.calculate_fitness(self.x) self.p = self.x # 个体的最佳位置 self.pg = self.x[np.argmin(fitness)] # 全局最佳位置 self.individual_best_fitness = fitness # 个体的最优适应度 self.global_best_fitness = np.max(fitness) # 全局最佳适应度 def calculate_fitness(self, x): return np.sum(np.square(x), axis=1) def evolve(self): fig = plt.figure() for step in range(self.max_steps): r1 = np.random.rand(self.population_size, self.dim) r2 = np.random.rand(self.population_size, self.dim) # 更新速度和权重 self.v = self.w*self.v+self.c1*r1*(self.p-self.x)+self.c2*r2*(self.pg-self.x) self.x = self.v + self.x plt.clf() plt.scatter(self.x[:, 0], self.x[:, 1], s=30, color='k') plt.xlim(self.x_bound[0], self.x_bound[1]) plt.ylim(self.x_bound[0], self.x_bound[1]) plt.pause(0.01) # plt.ion() # plt.show() fitness = self.calculate_fitness(self.x) # 需要更新的个体 update_id = np.greater(self.individual_best_fitness, fitness) self.p[update_id] = self.x[update_id] self.individual_best_fitness[update_id] = fitness[update_id] # 新一代出现了更小的fitness，所以更新全局最优fitness和位置 if np.min(fitness) &lt; self.global_best_fitness: self.pg = self.x[np.argmin(fitness)] self.global_best_fitness = np.min(fitness) print('best fitness: %.5f, mean fitness: %.5f' % (self.global_best_fitness, np.mean(fitness))) pso = PSO(10, 100)pso.evolve() Reference:https://blog.csdn.net/zhaozx19950803/article/details/79854466https://blog.csdn.net/yy2050645/article/details/80740641https://blog.csdn.net/zj15527620802/article/details/81366105st=>start: Start op1=>operation: 初始化参数 op2=>operation: 计算各粒子适应值 op3=>operation: 找出个体和群体的最优值和最优位置 op4=>operation: 更新各个粒子的位置和速度 cond=>condition: 是否满足终止条件? e=>end st->op1->op2->op3->op4->cond cond(yes)->e cond(no)->op2{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <categories>
        <category>启发式算法</category>
      </categories>
      <tags>
        <tag>启发式算法</tag>
        <tag>pso</tag>
        <tag>粒子群算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见QoS指标一览]]></title>
    <url>%2F2019%2F11%2F04%2F%E5%B8%B8%E8%A7%81QoS%E6%8C%87%E6%A0%87%E4%B8%80%E8%A7%88%2F</url>
    <content type="text"><![CDATA[英文： Quality of Service中文： 服务质量介绍： 指一个网络能够利用各种基础技术，为指定的网络通信提供更好的服务能力，是网络的一种安全机制，是用来解决网络延迟和阻塞等问题的一种技术。 通过配置QoS，对企业的网络流量进行调控，避免并管理网络拥塞，减少报文的丢失率，同时也可以为企业用户提供专用带宽或者为不同的业务（语音、视频、数据等）提供差分服务。 在正常情况下，如果网络只用于特定的无时间限制的应用系统，并不需要QoS，比如Web应用，或E-mail设置等。但是对关键应用和多媒体应用就十分必要。当网络过载或拥塞时，==QoS能确保重要业务量不受延迟或丢弃==，同时保证网络的高效运行。在RFC 3644上有对QoS的说明。 可用性是当用户需要时网络即能工作的时间百分比。可用性主要是设备可靠性和网络存活性相结合的结果。对它起作用的还有一些其他因素，包括软件稳定性以及网络演进或升级时不中断服务的能力。 在连续5min内，如果一个IP网络所提供的丢包率&lt;=75%，则认为该时间段是可用的，否则是不可用的。 吞吐量(网络带宽)网络带宽是指在单位时间（一般指的是1秒钟）内能传输的数据量。对IP网而言可以从帧中继网借用一些概念。根据应用和服务类型，服务水平协议(SLA)可以规定承诺信息速率(CIR)、突发信息速率(BIR)和最大突发信号长度。承诺信息速率是应该予以严格保证的，对突发信息速率可以有所限定，以在容纳预定长度突发信号的同时容纳从话音到视像以及一般数据的各种服务。一般讲，吞吐量越大越好。 时延指一项服务从网络入口到出口的平均经过时间。许多服务，特别是话音和视像等实时服务都是高度不能容忍时延的。当时延超过200-250毫秒时，交互式会话是非常麻烦的。为了提供高质量话音和会议电视，网络设备必须能保证低的时延。产生时延的因素很多，包括分组时延、排队时延、交换时延和传播时延。传播时延是信息通过铜线、光纤或无线链路所需的时间，它是光速的函数。在任何系统中，包括同步数字系列(SDH)、异步传输模式（ATM）和弹性分组环路(RPR)，传播时延总是存在的。 时延变化(抖动)是指同一业务流中不同分组所呈现的时延不同。高频率的时延变化称作抖动，而低频率的时延变化称作漂移。抖动主要是由于业务流中相继分组的排队等候时间不同引起的，是对服务质量影响最大的一个问题。 ​某些业务类型（特别是语音和视频等实时业务）是极其不能容忍抖动的。报文到达时间的差异将在语音或视频中造成断续；另外，抖动也会影响一些网络协议的处理，有些协议是按固定的时间间隔发送交互性报文，抖动过大就会导致协议震荡，而实际上所有传输系统都有抖动，但只要抖动在规定容差之内就不会影响服务质量，另外，可利用缓存来克服过量的抖动，但这将会增加时延。 漂移是任何同步传输系统都有的一个问题。在SDH系统中是通过严格的全网分级定时来克服漂移的。在异步系统中，漂移一般不是问题。漂移会造成基群失帧，使服务质量的要求不能满足。 丢包不管是比特丢失还是分组丢失，对分组数据业务的影响比对实时业务的影响都大。在通话期间，丢失一个比特或一个分组的信息往往用户注意不到。在视像广播期间，这在屏幕上可能造成瞬间的波形干扰，然后视像很快恢复如初。即便是用传输控制协议(TCP)传送数据也能处理丢失，因为传输控制协议允许丢失的信息重发。事实上，一种叫做随机早丢(RED)的拥塞控制机制在故意丢失分组，其目的是在流量达到设定门限时抑制TCP传输速率，减少拥塞，同时还使TCP流失去同步，以防止因速率窗口的闭合引起吞吐量摆动。但分组丢失多了，会影响传输质量。所以，要保持统计数字，当超过预定门限时就向网络管理人员告警。 丢包（packetloss）可能在所有环节中发生，例如： 处理过程：路由器在收到报文的时候可能由于CPU繁忙，无法处理报文而导致丢包； 排队过程：在把报文调度到队列的时候可能由于队列被装满而导致丢包； 传输过程：报文在链路上传输的过程中，可能由于种种原因（如链路故障等）导致的丢包。 References:https://blog.csdn.net/qq_25077833/article/details/53428655https://blog.csdn.net/kakingka/article/details/45698709https://blog.csdn.net/qq_38265137/article/details/80466737]]></content>
      <tags>
        <tag>服务计算</tag>
        <tag>Service Computing</tag>
        <tag>QoS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3小时精通lxml.etree:Python中xml的读取、解析、生成和查找]]></title>
    <url>%2F2019%2F10%2F21%2F3%E5%B0%8F%E6%97%B6%E7%B2%BE%E9%80%9Alxml-etree-Python%E4%B8%ADxml%E7%9A%84%E8%AF%BB%E5%8F%96%E3%80%81%E8%A7%A3%E6%9E%90%E3%80%81%E7%94%9F%E6%88%90%E5%92%8C%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[本文主要参考官方文档https://lxml.de/tutorial.html整理，如有错误欢迎指出。 12from lxml import etreefrom copy import deepcopy 12345678910111213# 添加Element默认添加为根节点root = etree.Element("root")# 通过append添加子节点root.append(etree.Element("child1"))# 通过SubElement添加子节点child2 = etree.SubElement(root, "child2")child3 = etree.SubElement(root, "child3")print(etree.tostring(root))print(etree.tostring(root, pretty_print=True))# 默认encoding是ASCIIprint(etree.tostring(root, encoding='iso-8859-1'))# 如果要把byte转成str输出的话，可以用下边的语句print(str(etree.tostring(root, pretty_print=True),encoding='utf-8')) b&apos;&lt;root&gt;&lt;child1/&gt;&lt;child2/&gt;&lt;child3/&gt;&lt;/root&gt;&apos; b&apos;&lt;root&gt;\n &lt;child1/&gt;\n &lt;child2/&gt;\n &lt;child3/&gt;\n&lt;/root&gt;\n&apos; b&quot;&lt;?xml version=&apos;1.0&apos; encoding=&apos;iso-8859-1&apos;?&gt;\n&lt;root&gt;&lt;child1/&gt;&lt;child2/&gt;&lt;child3/&gt;&lt;/root&gt;&quot; &lt;root&gt; &lt;child1/&gt; &lt;child2/&gt; &lt;child3/&gt; &lt;/root&gt;1234567# 每个元素都是一个listchild1 = root[0]# .tag 可以取出元素的标签print(child1.tag, len(root))# 大部分list方法都可以使用在element上root.insert(0, etree.Element("child0"))print(root[0].tag) child1 3 child01234# 可以用list函数取出子元素的listchildren = list(root)print(root)print(children) &lt;Element root at 0x107b03888&gt; [&lt;Element child0 at 0x107b034c8&gt;, &lt;Element child1 at 0x107b03448&gt;, &lt;Element child2 at 0x107b038c8&gt;, &lt;Element child3 at 0x107b03908&gt;]1234567# 通过长度检查element是否为叶子节点if len(root): print('root has children')if len(child1): print('child1 has children')else: print('child1 has no child') root has children child1 has no child12345678910# 不同于普通list，赋值可能会造成元素移动print(etree.tostring(root))root[0] = root[-1]print(etree.tostring(root))# 这是普通listl = [0,1,2,3]print(l)l[0] = l[-1]print(l) b&apos;&lt;root&gt;&lt;child0/&gt;&lt;child1/&gt;&lt;child2/&gt;&lt;child3/&gt;&lt;/root&gt;&apos; b&apos;&lt;root&gt;&lt;child3/&gt;&lt;child1/&gt;&lt;child2/&gt;&lt;/root&gt;&apos; [0, 1, 2, 3] [3, 1, 2, 3]12345# 要拷贝节点，需要调用deepcopynewroot = etree.Element('newroot')newroot.append(deepcopy(root[1]))print(etree.tostring(root))print(etree.tostring(newroot)) b&apos;&lt;root&gt;&lt;child3/&gt;&lt;child1/&gt;&lt;child2/&gt;&lt;/root&gt;&apos; b&apos;&lt;newroot&gt;&lt;child1/&gt;&lt;/newroot&gt;&apos;1234# etree元素自带方法可以找到对应的父节点、前一个节点、后一个节点print(root is child1.getparent())print(root[0] is root[1].getprevious())print(root[1] is root[0].getnext()) True True True123456789# 属性以字典方式存储root = etree.Element("root", interesting="totally")print(etree.tostring(root))# 通过get方法获取属性值print(root.get("interesting"))print(root.get("hello"))# 通过set方法添加属性root.set("hello", "Huhu")print(etree.tostring(root)) b&apos;&lt;root interesting=&quot;totally&quot;/&gt;&apos; totally None b&apos;&lt;root interesting=&quot;totally&quot; hello=&quot;Huhu&quot;/&gt;&apos;123456789101112131415# 字典的相关方法也可以直接使用print(root.items(), root.keys(), root.values())# 通过 attrib 可以直接取出属性进行操作attributes = root.attribprint(attributes.get("no-such-attribute"))Noneattributes["hello"] = "Guten Tag"print(attributes["hello"])# root中的属性一并修改print(root.get("hello"))# 也可以转化为纯正的dictd = dict(root.attrib)print(d.items()) [(&apos;interesting&apos;, &apos;totally&apos;), (&apos;hello&apos;, &apos;Huhu&apos;)] [&apos;interesting&apos;, &apos;hello&apos;] [&apos;totally&apos;, &apos;Huhu&apos;] None Guten Tag Guten Tag dict_items([(&apos;interesting&apos;, &apos;totally&apos;), (&apos;hello&apos;, &apos;Guten Tag&apos;)])12345# 元素中包含文本root = etree.Element("root")root.text = "Hello World"print(root.text)print(etree.tostring(root)) Hello World b&apos;&lt;root&gt;Hello World&lt;/root&gt;&apos;1234567891011121314# 如何添加特殊元素类似于&lt;br/&gt;html = etree.Element("html")body = etree.SubElement(html, "body")body.text = "TEXT"print(etree.tostring(html))br = etree.SubElement(body, "br")print(etree.tostring(html))br.tail = "TAIL"print(etree.tostring(html))body.text = "HEAD"print(etree.tostring(html)) b&apos;&lt;html&gt;&lt;body&gt;TEXT&lt;/body&gt;&lt;/html&gt;&apos; b&apos;&lt;html&gt;&lt;body&gt;TEXT&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;&apos; b&apos;&lt;html&gt;&lt;body&gt;TEXT&lt;br/&gt;TAIL&lt;/body&gt;&lt;/html&gt;&apos; b&apos;&lt;html&gt;&lt;body&gt;HEAD&lt;br/&gt;TAIL&lt;/body&gt;&lt;/html&gt;&apos;1234# tail其实属于前边元素的一部分print(etree.tostring(br))print(etree.tostring(br, with_tail=False))print(etree.tostring(html, method="text")) b&apos;&lt;br/&gt;TAIL&apos; b&apos;&lt;br/&gt;&apos; b&apos;HEADTAIL&apos;123# xpath方法也可以使用print(html.xpath("string()"))print(html.xpath("//text()")) HEADTAIL [&apos;HEAD&apos;, &apos;TAIL&apos;]123# 甚至可以吧xpath的方法包装成函数build_text_list = etree.XPath("//text()") # lxml.etree only!print(build_text_list(html)) [&apos;HEAD&apos;, &apos;TAIL&apos;]123456789# text也可以找爸爸texts = build_text_list(html)print(texts[0])parent = texts[0].getparent()print(parent.tag)print(texts[1])print(texts[1].getparent().tag) HEAD body TAIL br1234# 判断一段文本是正常的文本还是tailprint(texts[0].is_text)print(texts[1].is_text)print(texts[1].is_tail) True False True1234# 但是XPath下有些方法就不行了stringify = etree.XPath("string()")print(stringify(html))print(stringify(html).getparent()) HEADTAIL None123456789# etree中的树是iterable的root = etree.Element("root")etree.SubElement(root, "child").text = "Child 1"etree.SubElement(root, "child").text = "Child 2"etree.SubElement(root, "another").text = "Child 3"print(etree.tostring(root, pretty_print=True))for element in root.iter(): print("%s - %s" % (element.tag, element.text)) b&apos;&lt;root&gt;\n &lt;child&gt;Child 1&lt;/child&gt;\n &lt;child&gt;Child 2&lt;/child&gt;\n &lt;another&gt;Child 3&lt;/another&gt;\n&lt;/root&gt;\n&apos; root - None child - Child 1 child - Child 2 another - Child 312345# 可以通过在iter中添加参数，来过滤输出的tagfor element in root.iter("child"): print("%s - %s" % (element.tag, element.text))for element in root.iter("another", "child"): print("%s - %s" % (element.tag, element.text)) child - Child 1 child - Child 2 child - Child 1 child - Child 2 another - Child 312345678910111213141516# 默认情况下，所有节点都会被遍历，如Entity、Comment等，通过添加tag参数可以避免这一点root.append(etree.Entity("#234"))root.append(etree.Comment("some comment"))print(etree.tostring(root))for element in root.iter(): if isinstance(element.tag, str): print("%s - %s" % (element.tag, element.text)) else: print("SPECIAL: %s - %s" % (element, element.text))for element in root.iter(tag=etree.Element): print("%s - %s" % (element.tag, element.text))for element in root.iter(tag=etree.Entity): print(element.text) b&apos;&lt;root&gt;&lt;child&gt;Child 1&lt;/child&gt;&lt;child&gt;Child 2&lt;/child&gt;&lt;another&gt;Child 3&lt;/another&gt;&amp;#234;&lt;!--some comment--&gt;&lt;/root&gt;&apos; root - None child - Child 1 child - Child 2 another - Child 3 SPECIAL: &amp;#234; - &amp;#234; SPECIAL: &lt;!--some comment--&gt; - some comment root - None child - Child 1 child - Child 2 another - Child 3 &amp;#234;123# 通过elementTreeName.write(filePath)可以把树写进文件或通过url传输# 或者如果你只有elementName的话，可以这么写：# etree.ElementTree(elementName).write(filePath) 1234567# 简单粗暴的直接写xml也可以root = etree.XML( '&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br/&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;')# 通过method参数，可以序列化为不同格式，默认method = 'xml'print(etree.tostring(root))print(etree.tostring(root, method='html'))print(etree.tostring(root, method='text')) b&apos;&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br/&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&apos; b&apos;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&apos; b&apos;HelloWorld&apos;12345678910111213141516# ElementTree class，是一个element的容器，提供了一些方法来对整个root node文档进行操作root = etree.XML('''\&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE root SYSTEM "test" [ &lt;!ENTITY tasty "parsnips"&gt; ]&gt;&lt;root&gt; &lt;a&gt;&amp;tasty;&lt;/a&gt;&lt;/root&gt;''')tree = etree.ElementTree(root)print(tree.docinfo.xml_version)print(tree.docinfo.doctype)tree.docinfo.public_id = '-//W3C//DTD XHTML 1.0 Transitional//EN'tree.docinfo.system_url = 'file://local.dtd'print(tree.docinfo.doctype) 1.0 &lt;!DOCTYPE root SYSTEM &quot;test&quot;&gt; &lt;!DOCTYPE root PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;file://local.dtd&quot;&gt;12print(etree.tostring(tree))print(etree.tostring(tree.getroot())) b&apos;&lt;!DOCTYPE root PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;file://local.dtd&quot; [\n&lt;!ENTITY tasty &quot;parsnips&quot;&gt;\n]&gt;\n&lt;root&gt;\n &lt;a&gt;parsnips&lt;/a&gt;\n&lt;/root&gt;&apos; b&apos;&lt;root&gt;\n &lt;a&gt;parsnips&lt;/a&gt;\n&lt;/root&gt;&apos;123456# 解析文档中以string读入的xmlsome_xml_data = "&lt;root&gt;data&lt;/root&gt;"# .fromstring函数其实和.XML差不多root = etree.fromstring(some_xml_data)print(etree.tostring(root)) b&apos;&lt;root&gt;data&lt;/root&gt;&apos;1234567891011121314# 二进制读取解析from io import BytesIOsome_file_or_file_like_object = BytesIO(b"&lt;root&gt;data&lt;/root&gt;")tree = etree.parse(some_file_or_file_like_object)print(etree.tostring(tree))# 注意：parse函数返回的是ElementTree对象，不是Element，通过getroot可以转化为Element对象# ElementTree和Element在某些方面相似，但是方法调用上不同，比如.tag只有Element可以使用root = tree.getroot()print(etree.tostring(root))try: print("tree执行:", tree.tag)except: print("root执行:", root.tag) b&apos;&lt;root&gt;data&lt;/root&gt;&apos; b&apos;&lt;root&gt;data&lt;/root&gt;&apos; root执行: root1234# parser对象parser = etree.XMLParser(remove_blank_text=True)root = etree.XML("&lt;root&gt; &lt;a/&gt; &lt;b&gt; &lt;/b&gt; &lt;/root&gt;", parser)print(etree.tostring(root)) b&apos;&lt;root&gt;&lt;a/&gt;&lt;b&gt; &lt;/b&gt;&lt;/root&gt;&apos;123456789101112131415161718192021222324# Incremental parsing增量解析，比如在网络分步传输的场景下需要使用# 方法一class DataSource: data = [ b"&lt;roo", b"t&gt;&lt;", b"a/", b"&gt;&lt;", b"/root&gt;" ] def read(self, requested_size): try: return self.data.pop(0) except IndexError: return b'' tree = etree.parse(DataSource())print(etree.tostring(tree))# 方法二parser = etree.XMLParser()parser.feed("&lt;roo")parser.feed("t&gt;&lt;")parser.feed("a/")parser.feed("&gt;&lt;")parser.feed("/root&gt;")root = parser.close()print(etree.tostring(root)) b&apos;&lt;root&gt;data&lt;/root&gt;&apos; b&apos;&lt;root&gt;&lt;a/&gt;&lt;/root&gt;&apos;1234567891011121314# Event-driven parsing事件驱动的解析，如只需要很大的树中的一小部分时使用# 方法一# iterparse默认只解析end事件some_file_like = BytesIO(b"&lt;root&gt;&lt;a&gt;data&lt;/a&gt;&lt;/root&gt;")for event, element in etree.iterparse(some_file_like): print("%s, %4s, %s" % (event, element.tag, element.text)) print()# 可以修改events参数解析所有事件some_file_like = BytesIO(b"&lt;root&gt;&lt;a&gt;data&lt;/a&gt;&lt;/root&gt;")for event, element in etree.iterparse(some_file_like, events=("start", "end")): print("%5s, %4s, %s" % (event, element.tag, element.text)) end, a, data end, root, None start, root, None start, a, data end, a, data end, root, None12345678910111213141516171819202122# 方法二class ParserTarget: events = [] close_count = 0 def start(self, tag, attrib): self.events.append(("start", tag, attrib)) def close(self): events, self.events = self.events, [] self.close_count += 1 return eventsparser_target = ParserTarget()parser = etree.XMLParser(target=parser_target)events = etree.fromstring('&lt;root test="true"/&gt;', parser)print(parser_target.close_count)for event in events: print('event: %s - tag: %s' % (event[0], event[1])) for attr, value in event[2].items(): print(' * %s = %s' % (attr, value)) 1 event: start - tag: root * test = true /Users/imonce/anaconda/lib/python3.6/site-packages/ipykernel_launcher.py:15: DeprecationWarning: inspect.getargspec() is deprecated, use inspect.signature() or inspect.getfullargspec() from ipykernel import kernelapp as app1234events = etree.fromstring('&lt;root test="true"/&gt;', parser)print(parser_target.close_count)events = etree.fromstring('&lt;root test="true"/&gt;', parser)print(parser_target.close_count) 2 31234for event in events: print('event: %s - tag: %s' % (event[0], event[1])) for attr, value in event[2].items(): print(' * %s = %s' % (attr, value)) event: start - tag: root * test = true123456789101112131415# namespace命名空间，格式为：&#123;namespace_name&#125;tag_name# 一般是链接，空链接的话会 ns+编号 给一个代号# a:b的tag名会直接报错xhtml = etree.Element("&#123;http://www.w3.org/1999/test&#125;testhtml")body = etree.SubElement(xhtml, "&#123;http://www.w3.org/1999/test&#125;tbody")body.text = "Hello World"print(etree.tostring(xhtml))# 高贵的htmlxhtml = etree.Element("&#123;http://www.w3.org/1999/xhtml&#125;html")body = etree.SubElement(xhtml, "&#123;http://www.w3.org/1999/xhtml&#125;body")body.text = "Hello World"print(etree.tostring(xhtml)) b&apos;&lt;ns0:testhtml xmlns:ns0=&quot;http://www.w3.org/1999/test&quot;&gt;&lt;ns0:tbody&gt;Hello World&lt;/ns0:tbody&gt;&lt;/ns0:testhtml&gt;&apos; b&apos;&lt;html:html xmlns:html=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;html:body&gt;Hello World&lt;/html:body&gt;&lt;/html:html&gt;&apos;123456789# 设置默认命名空间XHTML_NAMESPACE = "http://www.w3.org/1999/xhtml"XHTML = "&#123;%s&#125;" % XHTML_NAMESPACENSMAP = &#123;None : XHTML_NAMESPACE&#125; # the default namespace (no prefix)xhtml = etree.Element(XHTML + "html", nsmap=NSMAP) # lxml only!body = etree.SubElement(xhtml, XHTML + "body")body.text = "Hello World"print(etree.tostring(xhtml)) b&apos;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;&apos;123456789# QName方法，快速合成或提取namespacetag = etree.QName('http://www.w3.org/1999/xhtml', 'html')print(tag.localname)print(tag.namespace)print(tag.text)root = etree.Element('&#123;http://www.w3.org/1999/xhtml&#125;html')tag = etree.QName(root)print(tag.localname) html http://www.w3.org/1999/xhtml {http://www.w3.org/1999/xhtml}html html12# nsmap方法，直接提取命名空间字典print(xhtml.nsmap) {None: &apos;http://www.w3.org/1999/xhtml&apos;}123456# 子元素继承父元素命名空间root = etree.Element('root', nsmap=&#123;'a': 'http://a.b/c'&#125;)child = etree.SubElement(root, 'child', nsmap=&#123;'b': 'http://b.c/d'&#125;)print(root.nsmap)print(child.nsmap) {&apos;a&apos;: &apos;http://a.b/c&apos;} {&apos;b&apos;: &apos;http://b.c/d&apos;, &apos;a&apos;: &apos;http://a.b/c&apos;}123456# 添加带命名空间的属性，格式为：set(&#123;namespace_name&#125;attr_name, attr_value)body.set(XHTML + "bgcolor", "#CCFFAA")print(etree.tostring(xhtml))# 注意：get的时候也要带命名空间print(body.get("bgcolor"))print(body.get(XHTML+"bgcolor")) b&apos;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;&lt;body xmlns:html=&quot;http://www.w3.org/1999/xhtml&quot; html:bgcolor=&quot;#CCFFAA&quot;&gt;Hello World&lt;/body&gt;&lt;/html&gt;&apos; None #CCFFAA123456# 也可以用XPathfind_xhtml_body = etree.ETXPath( # lxml only ! "//&#123;%s&#125;body" % XHTML_NAMESPACE)results = find_xhtml_body(xhtml)print(results[0].tag) {http://www.w3.org/1999/xhtml}body12# iter的话也要考虑namespacefor el in xhtml.iter('&#123;*&#125;body'): print(el.tag) {http://www.w3.org/1999/xhtml}body1234567891011121314151617181920212223# E-factory：提供一种简单紧凑的语法来生成XML和HTMLfrom lxml.builder import Edef CLASS(*args): # class 是python中的保留字，无法直接当做属性名 return &#123;"class":' '.join(args)&#125;html = page = ( E.html( # create an Element called "html" E.head( E.title("This is a sample document") ), E.body( E.h1("Hello!", CLASS("title")), E.p("This is a paragraph with ", E.b("bold"), " text in it!"), E.p("This is another paragraph, with a", "\n ", E.a("link", href="http://www.python.org"), "."), E.p("Here are some reserved characters: &lt;spam&amp;egg&gt;."), etree.XML("&lt;p&gt;And finally an embedded XHTML fragment.&lt;/p&gt;"), ) ))print(str(etree.tostring(page, pretty_print=True),encoding='utf-8')) &lt;html&gt; &lt;head&gt; &lt;title&gt;This is a sample document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=&quot;title&quot;&gt;Hello!&lt;/h1&gt; &lt;p&gt;This is a paragraph with &lt;b&gt;bold&lt;/b&gt; text in it!&lt;/p&gt; &lt;p&gt;This is another paragraph, with a &lt;a href=&quot;http://www.python.org&quot;&gt;link&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Here are some reserved characters: &amp;lt;spam&amp;amp;egg&amp;gt;.&lt;/p&gt; &lt;p&gt;And finally an embedded XHTML fragment.&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;12345678910111213141516171819202122232425# 此外还有一种基于属性的方法from lxml.builder import ElementMaker # lxml only !E = ElementMaker(namespace="http://my.de/fault/namespace", nsmap=&#123;'p' : "http://my.de/fault/namespace"&#125;)DOC = E.docTITLE = E.titleSECTION = E.sectionPAR = E.parmy_doc = DOC( TITLE("The dog and the hog"), SECTION( TITLE("The dog", tType='title'), PAR("Once upon a time, ..."), PAR("And then ...") ), SECTION( TITLE("The hog"), PAR("Sooner or later ...") ))print(str(etree.tostring(my_doc, pretty_print=True),encoding='utf-8')) &lt;p:doc xmlns:p=&quot;http://my.de/fault/namespace&quot;&gt; &lt;p:title&gt;The dog and the hog&lt;/p:title&gt; &lt;p:section&gt; &lt;p:title tType=&quot;title&quot;&gt;The dog&lt;/p:title&gt; &lt;p:par&gt;Once upon a time, ...&lt;/p:par&gt; &lt;p:par&gt;And then ...&lt;/p:par&gt; &lt;/p:section&gt; &lt;p:section&gt; &lt;p:title&gt;The hog&lt;/p:title&gt; &lt;p:par&gt;Sooner or later ...&lt;/p:par&gt; &lt;/p:section&gt; &lt;/p:doc&gt;12345# XPath的一些例子root = etree.XML("&lt;root&gt;&lt;a x='123'&gt;aText&lt;b/&gt;&lt;c/&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;")# 找儿子（单层子节点）print(root.find("b"))print(root.find("a").tag) None a12# 找孩子（所有子节点）print(root.find(".//b").tag) b12# 带属性找孩子print(root.findall(".//a[@x]")[0].tag) a123456# 通过ElementTree找路径tree = etree.ElementTree(root)a = root[0]print(tree.getelementpath(a[0]))print(tree.getelementpath(a[1]))print(tree.getelementpath(a[2])) a/b[1] a/c a/b[2]]]></content>
      <categories>
        <category>Learn X in Y minutes</category>
        <category>Learn lxml.etree in Y minutes</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python3</tag>
        <tag>lxml</tag>
        <tag>etree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过TensorFlow实现word embedding]]></title>
    <url>%2F2019%2F10%2F21%2F%E9%80%9A%E8%BF%87TensorFlow%E5%AE%9E%E7%8E%B0word-embedding%2F</url>
    <content type="text"><![CDATA[word2vec的方法主要分为CBOW（Continuous Bag Of Words）和skip-gram（n-gram）两大类。 两种方法互为镜像。简单来说，CBOW是通过上下文预测中间值来进行训练的，skip-gram是通过中间值预测上下文来进行训练的。 这里，我们使用skip-gram的方法。 python脚本IDE: jupyter notebook 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221from __future__ import absolute_importfrom __future__ import divisionfrom __future__ import print_functionfrom sklearn.manifold import TSNEimport matplotlib.pyplot as pltimport collectionsimport mathimport osimport randomimport zipfileimport numpy as npfrom six.moves import urllibfrom six.moves import xrangeimport tensorflow as tfclass BasicPatternEmbedding: def __init__(self): self.url = &apos;http://mattmahoney.net/dc/&apos; self.data_index = 0 self.vocabulary_size = 5000 self.batch_size = 128 self.embedding_size = 128 # Dimension of the embedding vector. self.skip_window = 1 # How many words to consider left and right. self.num_skips = 2 # How many times to reuse an input to generate a label. # We pick a random validation set to sample nearest neighbors. Here we limit the # validation samples to the words that have a low numeric ID, which by # construction are also the most frequent. self.valid_size = 16 # Random set of words to evaluate similarity on. self.valid_window = 100 # Only pick dev samples in the head of the distribution. # choose 16 numbers from 0 to 99 randomly self.valid_examples = np.random.choice(self.valid_window, self.valid_size, replace=False) self.num_sampled = 64 # Number of negative examples to sample. self.num_steps = 10001 self.final_embedding = None self.graph = tf.Graph() # download and verify the dataset file def maybe_download(self, filename, expected_bytes): # If the dataset file is not under the current path, download it directly if not os.path.exists(filename): filename, _ = urllib.request.urlretrieve(self.url + filename, filename) # get dataset file infomationn statinfo = os.stat(filename) # verify file size if statinfo.st_size == expected_bytes: print(&apos;Found and verified&apos;, filename) else: print(statinfo.st_size) raise Exception( &apos;Failed to verify &apos; + filename + &apos;. Can you get to it with a browser?&apos;) return filename # read the data from zip into a list of strings def read_data(self, filename): with zipfile.ZipFile(filename) as f: # separate by default separators, that is, all null characters, including spaces, newlines (\n), tabs (\t), etc. data = tf.compat.as_str(f.read(f.namelist()[0])).split() return data # process raw inputs into a dataset def build_dataset(self, words): # add unknown words into count list count = [[&apos;UNK&apos;, -1]] # count the words list and add the pairs (word_name, number) into count list count.extend(collections.Counter(words).most_common(self.vocabulary_size - 1)) dictionary = dict() # create a dictionary of the words with serial number for word, _ in count: dictionary[word] = len(dictionary) data = list() unk_count = 0 # convert the word list into a number list, 0 for unknown words for word in words: if word in dictionary: index = dictionary[word] else: index = 0 unk_count += 1 data.append(index) # update the number of UNK count[0][1] = unk_count # generate a new dictionary by exchanging key and value reversed_dictionary = dict(zip(dictionary.values(), dictionary.keys())) return data, count, dictionary, reversed_dictionary # function to generate a training batch for the skip-gram model def generate_batch(self, data): # make sure the data length is OK assert self.batch_size % self.num_skips == 0 assert self.num_skips &lt;= 2 * self.skip_window batch = np.ndarray(shape=(self.batch_size), dtype=np.int32) labels = np.ndarray(shape=(self.batch_size, 1), dtype=np.int32) span = 2 * self.skip_window + 1 # [ skip_window target skip_window ] # create a new double-ended queue to store the buffer buffer = collections.deque(maxlen=span) # data_index indicates the end point of the current window if self.data_index + span &gt; len(data): data_index = 0 buffer.extend(data[self.data_index:self.data_index + span]) self.data_index += span for i in range(self.batch_size // self.num_skips): target = self.skip_window # target label at the center of the buffer targets_to_avoid = [self.skip_window] # sample num_skips batches and labels, optimizable for j in range(self.num_skips): while target in targets_to_avoid: target = random.randint(0, span - 1) # avoid sampling to the same target targets_to_avoid.append(target) # each batch item stands for input batch[i * self.num_skips + j] = buffer[self.skip_window] # each label item stands for ground truth labels[i * self.num_skips + j, 0] = buffer[target] if self.data_index == len(data): buffer[:] = data[:span] self.data_index = span else: buffer.append(data[self.data_index]) self.data_index += 1 # Backtrack a little bit to avoid skipping words in the end of a batch self.data_index = self.data_index - span return batch, labels def train(self, data, reverse_dictionary): with self.graph.as_default(): train_inputs = tf.placeholder(tf.int32, shape=[self.batch_size]) train_labels = tf.placeholder(tf.int32, shape=[self.batch_size, 1]) valid_dataset = tf.constant(self.valid_examples, dtype=tf.int32) # Ops and variables pinned to the CPU with tf.device(&apos;/cpu:0&apos;): # Look up embeddings for inputs. embeddings = tf.Variable(tf.random_uniform([self.vocabulary_size, self.embedding_size], -1.0, 1.0)) # according to embeddings, the 128-dimensional vector corresponding to the input word(train inputs) was extracted embed = tf.nn.embedding_lookup(embeddings, train_inputs) # Construct the variables for the NCE loss nce_weights = tf.Variable(tf.truncated_normal([self.vocabulary_size, self.embedding_size], stddev=1.0 / math.sqrt(self.embedding_size))) nce_biases = tf.Variable(tf.zeros([self.vocabulary_size])) # Compute the average NCE loss for the batch. # tf.nce_loss automatically draws a new sample of the negative labels each # time we evaluate the loss. loss = tf.reduce_mean( tf.nn.nce_loss(weights=nce_weights, biases=nce_biases, labels=train_labels, inputs=embed, num_sampled=self.num_sampled, num_classes=self.vocabulary_size)) # Construct the SGD optimizer using a learning rate of 1.0. optimizer = tf.train.GradientDescentOptimizer(1.0).minimize(loss) # Compute the cosine similarity between minibatch examples and all embeddings. norm = tf.sqrt(tf.reduce_sum(tf.square(embeddings), 1, keep_dims=True)) normalized_embeddings = embeddings / norm valid_embeddings = tf.nn.embedding_lookup(normalized_embeddings, valid_dataset) similarity = tf.matmul(valid_embeddings, normalized_embeddings, transpose_b=True) # Add variable initializer. init = tf.global_variables_initializer() with tf.Session(graph = self.graph) as session: init.run() average_loss = 0 for step in xrange(self.num_steps): batch_inputs, batch_labels = self.generate_batch(data) feed_dict = &#123;train_inputs: batch_inputs, train_labels: batch_labels&#125; # we perform one update step by evaluating the optimizer op (including it # in the list of returned values for session.run() _, loss_val = session.run([optimizer, loss], feed_dict=feed_dict) average_loss += loss_val if step % 2000 == 0: if step &gt; 0: average_loss /= 2000 # the average loss is an estimate of the loss over the last 2000 batches. print(&apos;Average loss at step &apos;, step, &apos;: &apos;, average_loss) average_loss = 0 # output the most similar eight words to the screen if step % 10000 == 0: sim = similarity.eval() for i in xrange(self.valid_size): valid_word = reverse_dictionary[self.valid_examples[i]] top_k = 8 # number of nearest neighbors nearest = (-sim[i, :]).argsort()[1:top_k + 1] log_str = &apos;Nearest to %s:&apos; % valid_word for k in xrange(top_k): close_word = reverse_dictionary[nearest[k]] log_str = &apos;%s %s,&apos; % (log_str, close_word) print(log_str) self.final_embeddings = normalized_embeddings.eval() # visualize the embeddings def plot_with_labels(self, low_dim_embs, labels, filename=&apos;tsne.png&apos;): assert low_dim_embs.shape[0] &gt;= len(labels), &apos;More labels than embeddings&apos; plt.figure(figsize=(18, 18)) # in inches for i, label in enumerate(labels): x, y = low_dim_embs[i, :] plt.scatter(x, y) plt.annotate(label, xy=(x, y), xytext=(5, 2), textcoords=&apos;offset points&apos;, ha=&apos;right&apos;, va=&apos;bottom&apos;) plt.show() #plt.savefig(filename) 1234567891011121314151617181920212223242526272829if __name__ == &quot;__main__&quot;: try: bpe = BasicPatternEmbedding() filename = bpe.maybe_download(&apos;text8.zip&apos;,31344016) vocabulary = bpe.read_data(filename) print(&apos;Data size&apos;, len(vocabulary)) print (&apos;vocabulary:&apos;, vocabulary[:10]) data, count, dictionary, reverse_dictionary = bpe.build_dataset(vocabulary) del vocabulary # Hint to reduce memory. print(&apos;Most common words (+UNK)&apos;, count[:5]) print(&apos;Sample data&apos;, data[:10], [reverse_dictionary[i] for i in data[:10]]) batch, labels = bpe.generate_batch(data) for i in range(8): print(batch[i], reverse_dictionary[batch[i]], &apos;-&gt;&apos;, labels[i, 0], reverse_dictionary[labels[i, 0]]) print (dictionary[&apos;a&apos;], dictionary[&apos;as&apos;], dictionary[&apos;term&apos;]) bpe.train(data, reverse_dictionary) tsne = TSNE(perplexity=30, n_components=2, init=&apos;pca&apos;, n_iter=5000, method=&apos;exact&apos;) plot_only = 300 low_dim_embs = tsne.fit_transform(bpe.final_embeddings[:plot_only, :]) labels = [reverse_dictionary[i] for i in xrange(plot_only)] bpe.plot_with_labels(low_dim_embs, labels) except ImportError: print(&apos;Please install sklearn, matplotlib, and scipy to show embeddings.&apos;) Found and verified text8.zip Data size 17005207 vocabulary: [&apos;anarchism&apos;, &apos;originated&apos;, &apos;as&apos;, &apos;a&apos;, &apos;term&apos;, &apos;of&apos;, &apos;abuse&apos;, &apos;first&apos;, &apos;used&apos;, &apos;against&apos;] Most common words (+UNK) [[&apos;UNK&apos;, 2735459], (&apos;the&apos;, 1061396), (&apos;of&apos;, 593677), (&apos;and&apos;, 416629), (&apos;one&apos;, 411764)] Sample data [0, 3081, 12, 6, 195, 2, 3134, 46, 59, 156] [&apos;UNK&apos;, &apos;originated&apos;, &apos;as&apos;, &apos;a&apos;, &apos;term&apos;, &apos;of&apos;, &apos;abuse&apos;, &apos;first&apos;, &apos;used&apos;, &apos;against&apos;] 3081 originated -&gt; 12 as 3081 originated -&gt; 0 UNK 12 as -&gt; 6 a 12 as -&gt; 3081 originated 6 a -&gt; 195 term 6 a -&gt; 12 as 195 term -&gt; 2 of 195 term -&gt; 6 a 6 12 195 Average loss at step 0 : 185.77481079101562 Nearest to it: confidence, doesn, theatre, came, gulf, cultural, sites, corps, Nearest to use: buried, grave, observation, dust, batman, security, hungarian, opens, Nearest to at: warrior, total, rivers, yards, reaction, extinction, exclusively, eu, Nearest to if: emergency, present, developing, dates, life, for, pennsylvania, genesis, Nearest to between: grant, execution, generally, power, official, interpreted, hiv, binary, Nearest to people: unlikely, mainly, prussian, dedicated, shot, spending, dangerous, pick, Nearest to states: forward, racing, begins, printed, follow, vacuum, study, mythology, Nearest to by: rulers, protestant, marvel, republic, zero, letters, researchers, amiga, Nearest to american: hit, stores, managed, practiced, intermediate, retrieved, moreover, unique, Nearest to world: leadership, decay, culture, false, vii, et, dialogue, gave, Nearest to but: denominations, passing, according, germans, medical, emperors, working, grant, Nearest to an: removed, marxist, experts, ac, eugene, bones, tree, ne, Nearest to were: coat, facing, grammar, storage, teach, covering, solomon, circuit, Nearest to to: plant, supporting, pay, pp, shell, problem, acids, post, Nearest to be: judah, photo, films, both, senate, woman, villages, eating, Nearest to used: legislative, hero, private, organ, spaces, vice, top, trivia, Average loss at step 2000 : 22.257665908694268 Average loss at step 4000 : 5.249317247629166 Average loss at step 6000 : 4.652066127896309 Average loss at step 8000 : 4.529780765414238 Average loss at step 10000 : 4.432040006399155 Nearest to it: he, came, votes, matters, doesn, whole, confidence, continues, Nearest to use: alien, buried, security, hungarian, grave, dust, batman, amount, Nearest to at: in, killed, appearance, extinction, mathbf, rivers, eu, pronunciation, Nearest to if: life, molecules, emergency, dates, present, pennsylvania, for, rates, Nearest to between: eight, execution, vs, of, hiv, grant, official, documentary, Nearest to people: UNK, mainly, dedicated, selection, unlikely, shot, fact, dangerous, Nearest to states: forward, racing, cover, arithmetic, study, vacuum, vs, begins, Nearest to by: and, as, in, infant, co, manufacturer, with, campaign, Nearest to american: hit, importance, austin, entry, depending, retrieved, vs, intermediate, Nearest to world: culture, leadership, UNK, false, mathbf, skills, et, titled, Nearest to but: and, medical, working, was, connecticut, vs, europeans, denominations, Nearest to an: the, ac, plant, challenge, experts, necessary, lake, marxist, Nearest to were: jpg, are, facing, covering, manual, circuit, opposite, test, Nearest to to: ends, and, plant, in, office, into, supporting, agave, Nearest to be: iso, shorter, judah, self, painter, also, dependent, assistance, Nearest to used: opposition, hero, private, illinois, legislative, regime, breaking, repeated, 相关函数说明Tensor.eval().eval() 其实就是tf.Tensor的Session.run() 的另外一种写法，但两者有差别 eval(): 将字符串string对象转化为有效的表达式参与求值运算返回计算结果 eval()也是启动计算的一种方式。基于Tensorflow的基本原理，首先需要定义图，然后计算图，其中计算图的函数常见的有run()函数，如sess.run()。同样eval()也是此类函数， 要注意的是，eval()只能用于tf.Tensor类对象，也就是有输出的Operation，写作Tensor.eval()。对于没有输出的Operation, 可以用.run()或者Session.run()；Session.run()没有这个限制。 np.argsort()argsort函数返回的是数组值从小到大的索引值 123&gt;&gt;&gt; x = np.array([3, 1, 2])&gt;&gt;&gt; np.argsort(x)array([1, 2, 0]) tf.reduce_sum()reduce_sum( ) 是求和函数，在 tensorflow 里面，计算的都是 tensor，可以通过调整 axis =0,1 的维度来控制求和维度。 1234567891011&gt;&gt;&gt; x = tf.constant([[1,1,1],[1,1,1]])&gt;&gt;&gt; tf.reduce_sum(x)6&gt;&gt;&gt; tf.reduce_sum(x, 0)[2,2,2]&gt;&gt;&gt; tf.reduce_sum(x, 1)[3,3]&gt;&gt;&gt; tf.reduce_sum(x, 1, keepdims=True)[[3],[3]]&gt;&gt;&gt; tf.reduce_sum(x, [0,1])6 tf.nn.nce_loss()假设nce_loss之前的输入数据是K维的，一共有N个类，那么 weight.shape = (N, K) bias.shape = (N) inputs.shape = (batch_size, K) labels.shape = (batch_size, num_true) num_true : 实际的正样本个数 num_sampled: 采样出多少个负样本 num_classes = N sampled_values: 采样出的负样本，如果是None，就会用不同的sampler去采样。待会儿说sampler是什么。 remove_accidental_hits: 如果采样时不小心采样到的负样本刚好是正样本，要不要干掉 partition_strategy：对weights进行embedding_lookup时并行查表时的策略。TF的embeding_lookup是在CPU里实现的，这里需要考虑多线程查表时的锁的问题 nce_loss的实现逻辑如下： _compute_sampled_logits: 通过这个函数计算出正样本和采样出的负样本对应的output和label sigmoid_cross_entropy_with_logits: 通过 sigmoid cross entropy来计算output和label的loss，从而进行反向传播。这个函数把最后的问题转化为了num_sampled+num_real个两类分类问题，然后每个分类问题用了交叉熵的损伤函数，也就是logistic regression常用的损失函数。TF里还提供了一个softmax_cross_entropy_with_logits的函数，和这个有所区别。 在训练过程中，作为input的embed也会被自动更新 tf.nn.embedding_lookup()1234# Signature:tf.nn.embedding_lookup(params, ids, partition_strategy=&apos;mod&apos;, name=None, validate_indices=True, max_norm=None)# Docstring:# Looks up `ids` in a list of embedding tensors. 是根据 ids 中的id，寻找 params 中的第id行。比如 ids=[1,3,5]，则找出params中第1，3，5行，组成一个tensor返回。 embedding_lookup不是简单的查表，params 对应的向量是可以训练的，训练参数个数应该是 feature_num * embedding_size，即前文表述的embedding层权重矩阵，就是说 lookup 的是一种全连接层。 partition_strategy 为张量编号方式，在张量存在多维时起作用，编号的方式有两种，”mod”（默认） 和 “div”。 假设：一共有三个tensor [a,b,c] 作为params 参数，所有tensor的第 0 维上一共有 10 个项目（id 0 ~ 9）。 “mod” : (id) mod len(params) 得到 多少就把 id 分到第几个tensor里面 a 依次分到id： 0 3 6 9 b 依次分到id： 1 4 7 c 依次分到id： 2 5 8 “div” : (id) div len(params) 可以理解为依次排序，但是这两种切分方式在无法均匀切分的情况下都是将前(max_id+1)%len(params)个 partition 多分配一个元素. a 依次分到id： 0 1 2 3 b 依次分到id： 4 5 6 c 依次分到id： 7 8 9 tf.SparseTensor()构造稀疏向量矩阵，每一行为一个样本 SparseTensor(indices, values, dense_shape) 1234567SparseTensor(indices=[[0, 0], [1, 2]], values=[1, 2], dense_shape=[3, 4])# represents the dense tensor[[1, 0, 0, 0] [0, 0, 2, 0] [0, 0, 0, 0]] reference:https://blog.csdn.net/qoopqpqp/article/details/76037334https://segmentfault.com/a/1190000015287066?utm_source=tag-newesthttps://blog.csdn.net/u012193416/article/details/83349138https://blog.csdn.net/qq_36092251/article/details/79684721https://gshtime.github.io/2018/06/01/tensorflow-embedding-lookup-sparse/]]></content>
      <tags>
        <tag>TensorFlow</tag>
        <tag>word2vec</tag>
        <tag>n-gram</tag>
        <tag>skip-gram</tag>
        <tag>embedding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一文读懂Curry-Howard同构]]></title>
    <url>%2F2019%2F10%2F10%2F%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82Curry-Howard%E5%90%8C%E6%9E%84%2F</url>
    <content type="text"><![CDATA[背景柯里-霍华德同构，Curry-Howard Isomorphism，又称柯里-霍华德对应（Curry-Howard correspondence）是在计算机程序和数学证明之间的紧密联系；这种对应也叫做公式为类型对应或命题为类型对应。这是对形式逻辑系统和公式计算（computational calculus）之间符号的相似性的推广。命名来自它的两位发现者：美国数学家哈斯凯尔·柯里和逻辑学家威廉·阿尔文·霍瓦德。 同构对应Curry-Howard 同构显示了推理系统和程序语言之间的相似性，在此框架下： 程序语言的语言构造同构为推理系统的推理规则 程序的类型同构为逻辑命题 闭合程序（不依赖环境的程序）可以同构为一条定理的证明过程，其类型就是一条定理 逻辑上下文同构为自由变量类型指派 Lambda 演算同构为 Gentzen 的自然演绎 函数调用就是蕴含消除 函数抽象就是蕴含介入 参数多态就是全称量化 模板类型就是谓词 结构类型就是合取 联合类型就是析取 收参数但不返回就是否定 call/cc 就是双重否定消除 SK 组合子演算同构为直觉 Hilbert 推理系统 S 和 K 就是演算系统的两条公理 Curry-Howard 同构与 Martin-Löf 类型论系统这个框架里灵活性最高的是 Martin-Löf 的系统，两个高度抽象的算子—— $\prod$ 和 $\sum$ 进一步泛化了函数调用与合取，这使得它有极其恐怖的抽象能力。这个系统的推理规则是一下几条： Introduction rule for $\prod$$$\frac{\Gamma,x:A\vdash b:B}{\Gamma\vdash\lambda x.b:(\prod x:A)B}(\prod I)$$ Elimination rule for $\prod$$$\frac{\Gamma\vdash f:(\prod x:A)B\quad\Gamma\vdash a:A}{\Gamma\vdash apply(f,a):B[a/x]}(\prod E)$$ Suppose $f = \lambda x.x$, then $apply(f,a)=(\lambda x.x)a$ Introduction rule for $\sum$$$\frac{\Gamma\vdash a:A\quad\Gamma\vdash b:B[a/x]}{\Gamma\vdash\lt a,b\gt:(\sum x:A)B}(\sum I)$$ Elimination rule for $\sum$$$\frac{\Gamma\vdash c:(\sum x:A)B\quad\Gamma,x:A,y:B\vdash d:C[\lt x,y\gt/z]}{\Gamma\vdash split(c,\lambda x.\lambda y.d):C[c/z]}(\sum E)$$ where: $split(\lt a,b\gt,\lambda x.\lambda y.d)=(\lambda x.\lambda y.d)(a)(b)$ referencehttps://www.zhihu.com/question/22959608/answer/24770830https://zh.wikipedia.org/zh-hans/柯里-霍华德同构http://www2.math.uu.se/~palmgren/tillog/klogik04-01eng.pdf]]></content>
      <tags>
        <tag>Curry-Howard Isomorphism</tag>
        <tag>Type Theory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Reading Notes]Customer Value Chain Analysis]]></title>
    <url>%2F2019%2F09%2F27%2FReading-Notes-Customer-Value-Chain-Analysis%2F</url>
    <content type="text"><![CDATA[overallCustomer Value Chain Analysis (CVCA) is an original methodological tool that enables design teams in the product definition phase to comprehensively identify pertinent stakeholders, their relationships with each other, and their role in the product’s life cycle. method CVCA Step 1: Determine the business model for the vending machine. CVCA Step 2: Delineate pertinent parties involved with the vending machine’s life cycle. CVCA Step 3: Determine how the vending machine’s customers are related to each other. CVCA Step 4: Identify the value propositions of the vending machine’s customers and define the flows between them. CVCA Step 5: Analyze the Customer Chain to determine the vending machine’s critical customers and their value propositions. The vending operator and the soft drink bottler (circled) were determined to be the critical customers to the vending machine manufacturer. case studyCase study 1: electrocardiogram (EKG) machine Case study 2: pacemaker alert system Case study 3: donor-funded micro-irrigation pump]]></content>
      <categories>
        <category>Reading Notes</category>
        <category>Service Computing</category>
      </categories>
      <tags>
        <tag>service system</tag>
        <tag>value chain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Reading Notes]Service system fundamentals: Work system, value chain, and life cycle]]></title>
    <url>%2F2019%2F09%2F23%2FReading-Notes-Service-system-fundamentals-Work-system-value-chain-and-life-cycle%2F</url>
    <content type="text"><![CDATA[This paper presents three interrelated frameworks as a first attempt to define the fundamentals of service systems. The work system framework uses nine basic elements to provide a system-oriented view of any system that performs work within or across organizations. Service systems are work systems. The service value chain framework augments the work system framework by introducing functions that are associated specifically with services. It presents a two-sided view of service processes based on the common observation that services are typically coproduced by service providers and customers. The work system life cycle model looks at how work systems (including service systems) change and evolve over time. It treats the life cycle of a system as a set of iterations involving planned and unplanned change. This paper uses two examples, one largely manual and one highly automated, to illustrate the potential usefulness of the three frameworks, which can be applied together to describe, analyze, and study how service systems are created, how they operate, and how they evolve through a combination of planned and unplanned change.]]></content>
      <categories>
        <category>Reading Notes</category>
        <category>Service Computing</category>
      </categories>
      <tags>
        <tag>service system</tag>
        <tag>value chain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BPMN2.0入门到掌握，这一篇就够了]]></title>
    <url>%2F2019%2F09%2F19%2FBPMN2-0%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86%2F</url>
    <content type="text"><![CDATA[BPMN2.0入门到精通，这一篇就够了 笔者默认看这篇文章的同学都是了解、知道什么是BPMN的，因此背景知识、历史发展什么的都直接略过，我们直切正题：BPMN中的五个基础元素类别。 流对象（Flow Objects）：流对象是定义业务流程的主要图形元素，主要有三种流对象 事件（Events） 活动（Activities） 网关（Gateways） 数据（Data）：数据主要通过四种元素表示 数据对象（Data Objects） 数据输入（Data Inputs） 数据输出（Data Outputs） 数据存储（Data Stores） 连接对象（Connecting Objects）：流对象彼此互相连接或者连接到其他信息的方法主要有四种 顺序流（Sequence Flows） 信息流（Message Flows） 协同（Associations） 数据协同（Data Associations） 泳道（Swimlanes）：有两种方式通过泳道对主要的建模元素进行分组 泳池：Pools 泳道：Lanes Artifacts：主要用来提供关于流程的额外信息。BPMN2.0定义两种标准Artifacts，但是建模者或者建模工具可以增加任意多Artifacts。（Artifacts，有的地方翻译成“工件”，但是感觉不管翻译成什么都不够传神，所以本文中就不翻译这个词了。） 组：Group 文本注释：Text Annotation 流对象（Flow Objects）事件（Event） 元素 Element 描述 Description 符号 Notation 开始事件 Start 表示一个流程(Process)或一个编排(choreography)的开始 中间事件 Intermediate 发生在开始和结束事件之间，影响处理流程 结束事件 End 表示一个流程(Process)或一个编排(choreography)的结束 其他 开始事件和一些中间事件具有定义事件原因的“触发器”。结束事件可以定义作为序列流路径结束的“结果”。开始事件只能对触发器（“catch”）做出反应。结束事件只能创建（“抛出”）结果。中间事件可以捕获或抛出触发器。对于捕获的事件、触发器，标记未填充；对于抛出的触发器和结果，标记已填充。另外，在bpmn 1.1中用来中断活动的一些事件现在可以在不中断的模式下使用。这些事件的边界是虚线（见右图）。 活动（Activity） 元素 Element 描述 Description 符号 Notation 活动 Activity 活动是公司在流程中执行的工作的通用术语。活动可以是原子的或非原子的（聚合物）。作为流程模型一部分的活动类型有：子流程和任务，它们都是圆角矩形。活动用于标准流程Process和编排Choreography。 任务（原子） Task（atomic） 任务是包含在流程中的原子活动。任务是当流程中的工作无法分解为更精细的流程细节级别时使用。 编排任务 Choreography Task 表示一个或多个消息交换的集合。每个编排任务涉及两个参与者。 子流程 Sub-Process 子流程是包含在流程或编排中的复合活动。它是复合的，因为它可以通过一组子活动分解为更细粒度级别的流程或编排。子流程活动主要有以下四类 Collapsed Sub-ProcessExpanded Sub-ProcessCollapsed Sub- ChoreographyExpanded Sub-Choreography 网关（Gateway） 元素 Element 描述 Description 符号 Notation 网关 Gateway 网关用于顺序流程和编排中序列流的发散和收敛。因此，它将决定路径的分支、分叉、合并和连接。内部标记将指示行为控制的类型（见下边一行）。 网关控制类型 Gateway Control Type 网关菱形内的图标将指示流控制行为的类型。控制类型包括：•排他型exclusive决策和合并。排他型exclusive和基于事件event-based的网关都执行排他决策，合并排他可以使用或不使用“x”标记来显示。•基于事件event-based和基于并行事件parallel event-based的网关可以启动流程的新实例。•包容型inclusive网关决策和合并。•复杂型complex网关——复杂的条件和情况。•并行parallel网关分叉和连接。每种类型的控件都会影响传入和传出流。 数据（Data）数据对象提供有关需要执行的活动和/或它们产生的内容的信息，数据对象可以表示单个数据对象或数据对象集合。数据输入和数据输出为流程提供相同的信息。 连接对象（Connecting Objects） 元素 Element 描述 Description 符号 Notation 顺序流 Sequence Flow 表示活动的执行顺序 信息流 Message Flow 表示两个参与者之间准备发送和接收的信息流 协同 Association 协同用于将信息和artifact与图形元素链接。如果有箭头，则表示流向（如数据）。 泳道（Swimlanes） 元素 Element 描述 Description 符号 Notation 泳池 Pool 泳池是协作中参与者的图形表示。它还充当一个“泳道”和一个图形容器，用于从其他池中分割一组活动，通常是在B2B环境中。泳池可以具有内部详细信息，以将要执行的进程的形式显示。或者一个泳池可能没有内部细节，也就是说，它可以是一个“黑匣子”。 泳道 Lane lane是进程中的一个子分区，有时在泳池中，它将垂直或水平地扩展进程的整个长度。泳道用于组织和分类活动。 Artifacts 元素 Element 描述 Description 符号 Notation 组 Group 组是同一类别内的图形元素的组。这种类型的分组不影响组内的序列流。类别名称在关系图上显示为组标签。类别可用于文档或分析目的。组是可以在图表上直观显示对象类别的一种方式。 文本注释 Text Annotation 是一个帮助建模者给图形元素增加额外文本说明的机制。 总结至此，你已经通过 20% 的时间了解了BPMN2.0 接近 80% 的内容。虽然BPMN底层语法以及结构还没有学习，但是这并不影响你已经可以通过BPMN2.0对你所在的业务进行详尽的描述！]]></content>
      <tags>
        <tag>BPMN</tag>
        <tag>BPMN2.0</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WhatIs: Definition, Theorem, Lemma, Corollary, Proposition, Conjecture, Claim, Axiom, Postulate, Identity, and Paradox]]></title>
    <url>%2F2019%2F09%2F02%2FWhatIs-Definition-Theorem-Lemma-Corollary-Proposition-Conjecture-Claim-Axiom-Postulate-Identity-and-Paradox%2F</url>
    <content type="text"><![CDATA[Definition（定义）A precise and unambiguous description of the meaning of a mathematical term. It characterizes the meaning of a word by giving all the properties and only those properties that must be true. 对数学术语含义的精确而明确的描述。它通过给出一个词的所有性质，仅给出那些必须为真的性质，来表征该词的意义。 Theorem（定理）A mathematical statement that is proved using rigorous mathematical reasoning. In a mathematical paper, the term theorem is often reserved for the most important results. 用严格的数学推理证明的数学陈述。在数学论文中，术语定理通常是为最重要的结果而保留的。 Lemma（引理）A minor result whose sole purpose is to help in proving a theorem. It is a stepping stone on the path to proving a theorem. Very occasionally lemmas can take on a life of their own. 唯一目的是帮助证明定理的小结果。这是证明一个定理之路的踏脚石。极少情况下引理可以独立存在。 Corollary（推论）A result in which the (usually short) proof relies heavily on a given theorem (we often say that “this is a corollary of Theorem A”). 证明（通常是简短的）很大程度上依赖于一个给定定理的结果（我们经常说“这是定理A的一个推论”）。 Proposition（命题）A proved and often interesting result, but generally less important than a theorem. 一个被证明的，通常很有趣的结果，但一般没有定理重要。 Conjecture（推测，猜想）A statement that is unproved, but is believed to be true. Claim（断言）An assertion that is then proved. It is often used like an informal lemma. 未经证实但被认为是真实的陈述。 Axiom/Postulate（公理/假定）A statement that is assumed to be true without proof. These are the basic building blocks from which all theorems are proved. 没有证明，且假设为真的陈述。这些是证明所有定理的基本构造块。 Identity（恒等式）A mathematical expression giving the equality of two (often variable) quantities. 两个（通常是可变的）量相等的数学表达式。 Paradox（悖论）A statement that can be shown, using a given set of axioms and de nitions, to be both true and false. Paradoxes are often used to show the inconsistencies in an awed theory. The term paradox is often used informally to describe a surprising or counterintuitive result that follows from a given set of rules. 一种使用一组给定的公理和定义，既正确又错误的陈述。悖论经常被用来显示敬畏理论中的矛盾。“悖论”一词通常被非正式地用来描述从一组给定规则得出的令人惊讶或违反直觉的结果。]]></content>
  </entry>
  <entry>
    <title><![CDATA[一个案例讲清楚所有服务盈利模式]]></title>
    <url>%2F2019%2F08%2F28%2F%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B%E8%AE%B2%E6%B8%85%E6%A5%9A%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1%E7%9B%88%E5%88%A9%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言互联网发展到今天，各种各样的互联网公司、互联网服务层出不穷，盈利方式更是”千奇百怪“，免费服务更是数不胜数，已然成为一种常态。 然而众所周知，无利不起早，是人就要吃饭。虽然我们享受着众多”免费“服务、点着各种满减外卖，但是这些提供服务的公司和平台却都活的好好的。他们的服务盈利模式都有哪些呢？ 服务盈利模式服务盈利模式总的来说分为两大类：内向盈利模式和外向盈利模式。 内向盈利模式：利润来自于服务提供者或消费者，依赖于在服务过程中产生或剩余的价值的盈利模式。 外向盈利模式：利润来自于无关自三方，依赖于服务存在的盈利模式。 根据变现对象的不同，内向盈利模式和外向盈利模式又可以分为以下几种子模式： 内向盈利模式 资产盈利模式：通过资产换取价值的盈利模式，如资产销售 服务盈利模式：依赖资产，通过提供服务换取价值的盈利模式，如收费服务、增值服务 平台盈利模式（内向型）：通过平台换取价值的盈利模式，如押金池、管理费 过程盈利模式（内向型）：依赖平台，通过服务过程产生额外价值的盈利模式，如佣金抽成 外向盈利模式 平台盈利模式（外向型）：依赖平台，从无关第三方获取价值的盈利方式，如金融运作 过程盈利模式（外向型）：依赖过程，从无关第三方获取价值的盈利方式，如广告 其他盈利模式：通过吸引投资、上市募集资金等手段获取价值的盈利方式，如外部投资 案例讲解我们现在虚构一个案例来讲解一下这几种盈利模式： 假设现在是2000年，有一家公司叫阿里后妈，他们是一个传统的服饰售卖公司。 由于互联网兴起，他们为了能够在线上销售自己的衣服，搭建了一个线上购物网站，通过销售一些货品获得盈利，此时他们的盈利模式是资产盈利模式。 为了增加客户黏度，他们提出了会员制度，通过办理线上会员，客户可以享受优先发货、免费退换等增值服务。此举一出，客户疯狂办理会员，后妈发现，衣服可以不赚钱，就交个朋友，会员费就够自己发工资了，此时他们的盈利模式是服务盈利模式。 阿里后妈的平台上人越来越多，这使得一些友商蠢蠢欲动。他们纷纷找阿里后妈商谈业务，希望能把自己的商品也上架到阿里后妈的网站上，他们愿意按期交一些管理费。后妈发现，自己连衣服都不用卖了，收管理费就足够恰饭了。此时盈利模式是平台盈利模式（内向型）。 但是一段时间过后，因为交易量大涨，导致平台运营成本增加，后妈发现每个月收的那点管理费有点不够用了。而且不管卖的多卖的少，商家交的管理费都一样，这是不公平的。于是后妈开始在管理费之外，每一单交易都收取30%的抽成。于是又增加了一种盈利模式过程盈利模式（内向型）。 员工越来越多、工资越来越高，交易量增速却开始下降，后妈发现这样下去可能要恰不起饭了。但是目前30%的抽成已经够高了，管理费用签过合同短期内不能变，怎么增加收入呢？后妈想到平台上有很多的押金，以及大量交易时的中转滞留滞留的资金，从中拿一部分出来，在不影响平台正常运作的情况下，做一些收益稳定的投资。盈利模式增加了平台盈利模式（外向型）。 过了一段时间，某离职员工把公司私用用户资金的问题爆料了出来，金融运作的路子走不通了。后妈又想到，可以在用户交易的过程中增加广告，比如交易页面上增加一个广告条，按照广告的播放次数收费，不需要增加买家或者卖家的成本，可以直接从第三方获取收益，岂不美哉。盈利模式增加了一种过程盈利模式（外向型）。 公司越办越大，最终上市，大量资金涌入，各个机构的投资纷至沓来，这些钱和服务并没有关系，这部分盈利属于其他盈利模式。 总结一家互联网公司同一时期并非只能存在一种盈利模式，通常情况下，是多种盈利模式共存的。 本问提出的划分方法，第一层是通过盈利来源来分（内部、外部），第二层是通过利润的产生对象来分（资产、服务、平台、过程），对于服务盈利模式进行了较好的抽象，对目前常见的盈利模式由较好的覆盖。]]></content>
      <tags>
        <tag>服务模式</tag>
        <tag>服务盈利模式</tag>
        <tag>服务计算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Reading Note]构造类型论与计算机程序设计]]></title>
    <url>%2F2019%2F08%2F21%2F%E6%9E%84%E9%80%A0%E7%B1%BB%E5%9E%8B%E8%AE%BA%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Taken from：http://xueshu.baidu.com/usercenter/paper/show?paperid=baa0175c22e30823d9b1e14e01cf4141&amp;site=xueshu_se&amp;hitarticle=1 背景及简介构造类型论为计算机科学家提供了一个框架, 以一种优雅和灵活的方式把逻辑和程序设计语言结合起来: 在同一形式系统中, 可以同时表达规约和(函数式语言)程序, 从证明规则可以导出正确的程序, 并验证程序具有某种性质, 从而在同一系统内完成程序的开发和验证。 构造类型轮的理论基础及相互关系构造类型论三大理论基石 直觉类型论和构造数学：构造类型论的直接基础是Martin-Lof的直觉类型论，它为构造数学提供直觉解释。它是一个逻辑框架，可以表达和解释其他逻辑或理论，从他的规范化证明立即得出其所表达理论的规范化。与此作用相同的还有T.Coquand和Giared的构造演算。 lambda演算和函数式语言程序设计与实现。lambda演算是函数式语言理论的基础，是函数式程序设计语言的纯理论部分的范式(canonical form)，是由函数抽象和函数应用组成的系统，而这两个特点也是程序设计语言所具有的的共同之处。 证明论和Curry-Howard同态。证明轮中直觉注意逻辑的Gentzen自然演绎、一些自动演绎技术及定理证明技术是构造类型轮实现系统主要使用的技术。 相互关系Curry-Howard同态是Martin-Lof直觉类型轮的基础：把命题解释称类型（propositions-a-types），或命题作为集合（propositions=as=sets）。利用命题与集合之间的等价，推导的规范化与计算机表示该推导的证明项的值对应。 直觉主义（构造）逻辑和有类型lambda盐酸在Curry-Howard同态下可以相互转化：直觉逻辑自然演绎的证明可用某种有类型lambda项表示，并且自然演绎的证明规范化与lambda盐酸的beta变换对应。 构造类型轮与程序设计的对应关系构造数学和计算机科学有一些基本概念是共同的。Bishop认为构造数学可以作为计算机科学的灵感的重要来源。 构造性证明与计算机程序概念的关系构造性的证明与计算机程序概念有密切关系：为构造地证明命题 $(\forall x \in A)(\exists y \in B)P(x,y)$ ，必须要给出函数f，使f应用于A中元素a时，产生B中元素b，使P(a,b)满足。如果P(a,b)描述了一个规约，则证明该命题的函数f就是满足该规约的一个程序。所以，可以吧构造证明本身看成是一个计算机程序，程序的计算过程与证明的规范化对应。正因为构造性证明的这一计算内容，可把类型轮用作一种程序设计语言，而且，由于程序是从他的说明的证明中得到的，类型轮还可以用作程序设计逻辑。 Martin-Lof直觉类型论和计算机程序概念的关系类型轮不是基于谓词逻辑，它不再使用Tarski的真值语义，而是利用命题和集合之间的Curry-Howard同态——“命题作为集合”的直觉主义语义来解释逻辑常数。这里，命题被解释称一个集合，若他的元素则被解释称命题的一个证明。根据Kolmogorov对直觉命题的解释，还可以吧集合看成是问题的描述，尤其是把集合看成是程序要解决问题的规约时，集合的元素就是满足该规约的程序。 用类型轮进行程序构造的好处是，可以在同一形式系统中表达规约和程序。同时，因为可以从证明规则到处正确的程序，并验证程序具有的性质，所以程序开发的验证也是在同一系统用中完成的。 构造类型轮的一些实现类型论的一个主要应用是作为变成逻辑，在其中能够从规约推导出程序。近年来，有几种类型轮的实现： Conell大学的Nurpl Edinburgh大学的LCF INRIA的Coq Edinburgh大学的LEGO Goteborg的ALF 其中，Coq和LEGO是基于构造演算CoC，与Martin-Lof直觉类型论的作用类似，也是提供了一种逻辑框架，利用了把命题解释成集合的思想。两者的区别是：Martin-Lof是直谓的（predicative），而CoC是非直谓的（impredicative）。所谓非直谓的，就是指可以对所有命题的类型Prop进行全称量化来构造类型。因此Martin-Lof直觉类型论只能够结实谓词逻辑，不能解释二姐逻辑，而CoC则能够解释高阶逻辑。 直觉主义（构造）逻辑和经典逻辑直觉注意逻辑更多的从证明论和模型论的角度展现逻辑：也就是说，它是一个构造的逻辑（constructive logic）。所谓构造性（constructivity）是指：与经典逻辑只关心公式的真值不同，构造逻辑关注的是实际的证明对象本身。“构造”可以指一个过程以及执行该过程的结果。 两者的主要不同在于语义基础不同。经典逻辑的基础是真值函数的语义：每个命题都为真或者假，这是Tarski语义的本质。而在直觉主义（构造）逻辑中，命题的定义就是把该命题的证明写下来，只有当存在一个与该命题对应的证明对象时，命题才为真，这是Brouwer-Heyting-Kolmogorov基于证明论语义的本质。因此从构造逻辑的角度来说，命题的真等价于命题的可证明性。其余区别见表： Curry-Howard同态Curry-Howard同态在有类型的lambda演算和直觉命题逻辑之间建立了密切的关系。 用 $t:\sigma$ 表示项t具有类型 $\sigma$ 。在有类型lambda盐酸中项的构造有三种：变量（用x，y，z等表示）；抽象（用 $\lambda x.t$ 表示）；应用（用tu表示）。构造项的规则用自然演绎的方式描述如下： 变量形成规则： $\frac{}{x:\sigma \to x:\sigma}$ 抽象形成规则： $\frac{\Gamma,x:\sigma \to t:r}{\Gamma \mapsto (\lambda x.t):\sigma \to r}$ 变量形成规则： $\frac{\Gamma \mapsto t:\sigma \to r \Delta \mapsto u:\sigma}{\Gamma,\Delta \mapsto (tu):\sigma}$ 对上边的规则形式进行改造： 把其中的项都去掉 用蕴含符号 $\Rightarrow$ 取代函数符号 $\to$ 用逻辑共识取代项 则可以得到直觉逻辑的自然演绎表示 公理： $\frac{}{A\mapsto A}$ 引入规则： $\frac{\Gamma, A \mapsto B}{\Gamma \mapsto A\Rightarrow B}(\Rightarrow I)$ 消除规则： $\frac{\Gamma \mapsto A\Rightarrow B\Delta \mapsto A}{\Gamma,\Delta \mapsto B}(\Rightarrow E)$ 这三条规则分别是直觉逻辑的自然演绎系统的定理、蕴含引入和蕴含消除规则。这就是Curry=Howard同态。 总结： lambda演算的项（或函数式语言程序）的类型与直觉逻辑的公式之间的对应：公式作为类型（formula-as-types） lambda演算的项与逻辑的证明对应：变量与公理对应，抽象与 $\Rightarrow$ 引入规则对应，应用与 $\Rightarrow$ 消除规则对应。而lambda演算的项就是函数式语言的程序，这就是：证明作为程序（proofs-as-programs） lambda演算与beta规约的过程与逻辑中的规范化过程对应，这就是计算作为规范化（computation-as-normalization） Martin-Lof直觉类型论概述对命题的直觉解释：命题作为集合类型论不是基于谓词演算，它的逻辑常熟市通过命题和集合之间的Curry-Howard同态解释的：命题被解释称集合，集合的元素代表了该命题的证明。 1）逻辑蕴含： $A \supset B$ $A \supset B$ 的证明是一个函数（方法，证明）。对A的每一证明，给出B的一个证明。 $A \supset B$ 等价于 $A \to B$ ，是从A到B的函数的集合。 集合 $A \to B$ 中元素都是函数，形式为 $\lambda x.b$ ，其中 $b\in B$ ，并且b可能依赖于 $x \in A$ 。 2）逻辑合取： $A \wedge B$ $A \wedge B$ 的证明是一个有序组，其中第一分量是A的每一证明，第二分量是B的一个证明。 $A \wedge B$ 等价于 $A \times B$ ，是A与B的笛卡尔积。 集合 $A \times B$ 中元素的形式为(a,b)，其中 $a\in A, b \in B$ 。 3）逻辑析取： $A \vee B$ 一个析取是构造地真，当且仅当我们能够证明析取式之一。所以， $A \vee B$ 的证明包括：A或者B的一个证明，加上有关到底是A还是B的证明的信息。 $A\vee B$ 等价于 A + B，是A与B的不想交并。 集合A+B中的元素的形式为inl(a)或inr(b)，其中 $a\in A, b \in B$ . 4）逻辑非： $\not A$ 命题A的反可以定义为： $\not A \equiv A \supset \perp$ 。其中 $\perp$ 代表荒谬（absurdity）。即一个没有证明的命题。如果用 $\Phi$ 代表空集，则利用逻辑蕴含的解释，有 $\not A$ 等价于 $A \to \Phi$ 。 为了对用两次定义的命题进行解释，我们来定义在集合族上的操作，即集合B依赖于集合A中的元素x。用 $B[x\leftarrow a]$ 表示把B中所有自由出现的x都用a替换后得到的表达式。 5）存在量词： $(\exists x \in A)B$ $(\exists x \in A)B$ 的证明包括：集合A的一个元素的构造，以及 $B[x\leftarrow a]$ 的一个证明。因此， $(\exists x \in A)B$ 的证明是一有序对，其第一分量是集合A的一个元素，第二分量是 $B[x\leftarrow a]$ 的一个证明。 $(\exists x \in A)B$ 等价于 $(\Sigma x\in A)B$ ， $(\Sigma x\in A)B$ 是一集合族的不相交并（disjoint union）。 集合中 $(\Sigma x\in A)B$ 中元素的形式为序偶 &lt;a,b&gt; ，其中 $a\in A, b \in B[x \leftarrow a]$。 6）全称量词： $(\forall x\in A)B$ $(\forall x \in A)B$ 的证明是一个函数（方法，程序），对于集合A中的每一个元素a给出 $B[x\leftarrow a]$ 的一个证明。因此， $(\forall x \in A)B$ 等价于 $(\prod x\in A)B$ ， $(\prod x\in A)B$ 是一集合族的笛卡尔积。 集合中 $(\prod x\in A)B$ 中元素都是函数，当应用与集合A中元素a时，给出集合 $B[x\leftarrow a]$ 中的一个元素。该集合中的元素形式为 $\lambda x.b$ ，其中 $b\in B$ ，并且b和B都可能依赖于 $x\in A$ 。 类型的概念类型轮中最基本的概念是类型的概念。对类型的直觉解释需要两方面的内容： 说明类型的对象是什么 说明该类型的两个对象相等的意义 类型论中有四种断言形式，对他们的直觉解释如下： A type，A是一个类型。 A=B，A和B是相等的类型。 $a\in A$ ，a是类型A中的一个对象。 $a=b\in A$ ，a和b是类型A中的相等对象 假言断言前边的四种断言不依赖于任何假设，假言断言（hypothetical judgement）通常都有一个上下文（context）. 下面我们只对当上下文的长度为1分别对前面4中断言的假言形式进行解释，其他可以通过归纳解释得到：上下文长度为0时，就是上一节的情况。以下使C是任意不依赖于任何假设的类型。 A type $[x\in C]$ ，当 $[x\in C]$ 时，A是一类型 A = B $[x\in C]$ ，A和B是类型C上相等的类型族 $a\in A[x\in C]$ ，a是依赖于 $[x\in C]$ 的类型A中的一个对象 $a=b\in A[x\in C]$ ，a和b是依赖于 $[x\in C]$ 的类型A中的相等对象 类型组成 产生基本类型的方式 类型Set 如果 $A\in Set$ ，A中元素的类型： $\frac{A\in Set}{El(A)type}$ 引入其他类型的方式 函数类型： $\frac{AtypeBtype[x\in A]}{(x\in A)Btype}$ ，相等函数类型 $\frac{A=A’B=B’[x\in A]}{(x\in A)B=(x\in A’)B’}$ 把函数应用于对象： $\frac{c\in (x\in A)Ba\in A}{c(a)\in B[x\leftarrow a]}$ ， $\frac{c\in (x\in A)Ba=b\in A}{c(a)=c(b)\in B[x\leftarrow a]}$ 引入函数的基本方法是对表达式共的一个变量进行抽象。： $\frac{b\in B[x\in A]}{[x]b\in (x\in A)B}$ 归纳定义的集合 常数的引入新的常数： 定义常数（defined constant）：用其他对象来定义的 显示定义常数：给出明确定义，实际上是某个类型中对象的简写 隐式定义常数：用于说明当把它应用于它的参数后，得到什么定义者 原始常数（primitive constant），值就是常数本身，只有一个类型，没有定义，也成为构造子（constructor），如自然数集合的定义就是通过声明以下常数： $N\in Set$ $succ\in (N)N$ $0\in N$]]></content>
      <tags>
        <tag>Type Theory</tag>
        <tag>类型论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何构建高绩效团队]]></title>
    <url>%2F2019%2F08%2F08%2F%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E9%AB%98%E7%BB%A9%E6%95%88%E5%9B%A2%E9%98%9F%2F</url>
    <content type="text"><![CDATA[剔除害群之马如果一个人没有良好的品质，任何领导者没有魔力能够把品质注入到他身上。 作为团队的领导，可以对每一个成员进行培养、测试他的品质，给年轻人机会让他展示自己的品质，但如果这种品质在他身上根本就不存在，就不能注入。这一点，每一个团队领导都要十分清楚。所以说，选择可靠的人的能力非常重要，有匹害群之马，大多数的组织都会功亏一篑。 团队的发展过程中，要坚持四个尊重 尊重别人 尊重诚实的品质 尊重忠诚的品质 尊重时间 高绩效团队拥有哪些元素 清晰的目的和愿景：人们想知道他们在做什么，想要达到什么样的目标，想要一些他们可以承诺的事情。这是很多团队领导者忽略的东西，或者他们知道自己的愿景是什么，但是，他们忘记了与团队成员分享，他们忽略了经常重复的好处。 清晰的目标：这包括两部分，为整个团队和每个团队成员制定明确的目标，这样，他们就知道团队对他们的期望，以及他们将如何为整体绩效做贡献。 高的工作标准：高效的团队为自己的绩效、工作方式和他们工作的水平感到自豪。拥有清晰的绩效标准或关键绩效指标（KPI）会得到强有力的承诺—-如果团队成员参与了这些标准的设定，承诺就会更多。 系统和程序：建立清晰的工作、报告和执行过程的清晰方法可以提高工作效率和效果。当团队成员变得更习惯于在一起工作时，这些系统和程序会变得更高质量。 清晰、开放的沟通：包括正式的非正式的沟通。在一个团队里，信息分享、说出你想要的和问出你想要的是非常重要的，更为关键的是团队成员之间可以相互倾听对方的观点并尊重对方的贡献，这样做的部分原因是，你可以轻松地表达不同意见、处理分歧。 信任和承诺：这是一种无形的元素，虽然人际关系很好，但这在团队中并不重要，更重要的是能够尊重同事，与他们一起工作，感觉他们会履行自己的承诺，可靠和值得信任远比彼此喜欢更为重要。 领导力：随着团队的发展，领导风格和方法需要与时俱进。 定义的角色和职责：大多数人都想知道他们应该做什么，以及他们将如何被评估。 归属感：团队成员有归属感吗？把目标感与愿景结合起来。 重点是分享和互相依赖高效的团队合作不是一个人们抛弃“自我”，仅是依附于团队获得支持和认同的依赖过程，在这个过程中，它也不是一个“我”是第一位的独立过程，高绩效团队是一个相互依赖的过程。 在高绩效协团队中，我们不会看到“指责”，或声称“这不是我的工作”。相互依赖的思维意味着从“这对我有什么好处？”到“这对我们有什么好处？”]]></content>
      <tags>
        <tag>团队建设</tag>
        <tag>团队管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里业务中台架构详解]]></title>
    <url>%2F2019%2F08%2F08%2F%E9%98%BF%E9%87%8C%E4%B8%9A%E5%8A%A1%E4%B8%AD%E5%8F%B0%E6%9E%B6%E6%9E%84%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[阿里业务中台架构图 基础设施服务，即IAAS层，提供硬件底层支持。 基础服务层，即PAAS层，包括分布式服务框架、分布式数据库、分布式消息、分布式存储、分布式事务、实时监控服务等等。 互联网业务中台，包括各服务中心的抽象出来的各种业务能力，包括交易中心、支付中心、营销中心、结算中心、用户中心、账户中心等等。也包括非业务类服务，如日志分析中心、配置中心、序列中心、基础中心。 业务应用，经过调取业务中台，组装形成独立业务服务能力的业务应用，如网银、手机银行。 交易来源，就是前台用户使用的各个端，如淘宝App、PC站等。 通过阿里云平台将技术中台进行部署，对集团内共享业务单元提供支撑，并最终对前台各业务线提供服务化能力输出。 产品形态 从这张产品形态图上边我们可以看出来，阿里巴巴的开发者主要开发的是能力，然后构建内部的能力地图，这里的能力可以看作是一个原子服务。在接收新的需求后，将需求进行结构化，通过已有能力配置产生新的业务，组成业务列表和业务全景。最后给这个业务一个身份标识，进行业务度量。 全剧架构 业务开发生命周期、业务创新和智能化 能力地图下放到需求域，商业能力可沉淀。根据已有数据进行分析，持续进化。 数据中台架构 数据中台本质上是在原有的计算存储平台与应用服务之间增加了一层统一数据服务中间件（OneService）。 形成了统一全域数据体系，实现了计算存储累计过亿的成本降低、响应业务效率多倍提升、为业务快速创新提供坚实保障。 全域数据采集与引入：以需求为驱动，以数据多样性的全域思想为指导，采集与引入全业务、多终端、多形态的数据； 标准规范数据架构与研发：统一基础层、公共中间层、百花齐放应用层的数据分层架构模式，通过数据指标结构化规范化的方式实现指标口径统一； 连接与深度萃取数据价值：形成以业务核心对象为中心的连接和标签体系，深度萃取数据价值； 统一数据资产管理：构建元数据中心，通过资产分析、应用、优化、运营四方面对看清数据资产、降低数据管理成本、追踪数据价值。 统一主题式服务：通过构建服务元数据中心和数据服务查询引擎，面向业务统一数据出口与数据查询逻辑，屏蔽多数据源与多物理表； 极大的丰富和完善了阿里巴巴大数据中心，OneData、OneID、OneService渐趋成熟并成为上至CEO、下至一线员工共识的方法论体系。 阿里技术全栈全景图 阿里技术全栈包含：移动中台、业务中台、数据中台、基本中间件、基础设施、前台业务、后台业务。 移动中台，包括移动网关、开发套件&amp;框架、消息推送、移动IM等等，提供了限流、负载、鉴权、消息推送、开发框架等等，使得移动端应用开发效率更高。 业务中台和数据中台，将业务、数据抽象和沉淀形成服务能力，对前台提供调用。 阿里技术平台底座 几百个业务应用，共享一个技术平台底座。 大中台、小前台 阿里巴巴集团在近期的组织结构调整中，组成由“小前台，大中台”互为协同的创新管理模式。原阿里巴巴中国零售事业群总裁张建锋将担负起“中台”的重要工作，负责共享、数据、搜索，以及闲鱼、淘宝头条等创新孵化业务。 reference:https://mp.weixin.qq.com/s/eLI4vcBwi0Q96yRlzvN3BQ]]></content>
      <tags>
        <tag>中台</tag>
        <tag>业务中台</tag>
        <tag>架构</tag>
        <tag>业务架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]知识图谱应用需要了解的16个知识]]></title>
    <url>%2F2019%2F08%2F08%2F%E8%BD%AC-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%BA%94%E7%94%A8%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%8416%E4%B8%AA%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1、知识图谱系统的关键特性有哪些？1.当然是可视化展示，知识图谱的魅力之一就是让人直观的看到多实体之间的关系，能用图标示的就不要哔哔 2.多种服务提供方式，有些服务使用方，不需要图，那么可能通过api或者批量文件的方式比较合适。所以从系统建设角度来看，最好能提供多样的服务对接方式，满足前端服务使用方的不同需要，发挥系统价值，是值得考虑的地方。 3.查询速度，在用户进行图操作，例如实体查询、关系推演扩展时，系统响应时间应该较低，避免大并发情况下用户体验的降低。 数据建模、批量时间相对来说，外界感知不到，因此不那么重要。 2、知识图谱适用场景有哪些？主要涉及关系分析的场景，利用账户、自然人或者资金交易形成的关系来判定结果是否可用时，比如担保圈、分析实际控制人、实际受益人、识别冒名贷款。而且通常，数据分析的深度在3度到5度，才能体现出优势。 分析深度小于3度，与传统关系型数据库没有太大差别，大于5度有可能引入较多的噪音数据。当然不排除某些场景下分析5度以上数据的可能性。 3、有没有业务场景是只能用知识图谱实现的？而其他技术方法无法实现？从技术角度考虑，应该没有，有的是效率孰高孰低、开发成本孰高孰低。 4、知识图谱应用时会面临哪些主要的困难，如何解决？主要是确认需求，一方面是适不适合用知识图谱这个工具，另一方面做好与其他系统的对接工作，如何能将知识图谱这个服务以简便快捷的方式输出给其他系统。前者可以和多方面行内外专家交流，后者主要还是要与业务部门进行沟通，确认业务部门的期望，技术实现大多时候不是难点，难的是如何满足欲壑难填的需求。 5、知识图谱系统的建设核心是什么？该如何选型？建设核心是图数据的存储和分析方法。不同的核心，外围使用的方法也不同。 以titan为例，它是集成在hadoop上的。数据的分析加工主要在使用sparksql和graphx，结果会存放在titan中，数量较多的明细流水会放在hbase中，常用的查询关键字，姓名、手机号码等会放在elasticsearch中，三者通过key相互关联。 如果换一种图数据库，比如neo4j，整个外围都会跟着调整。所以图数据库的选型不能进场图数据本身考虑，而应该结合整体规划，建设成本，多系统间的关联关系层面进行统筹考虑，甚至可能会为了大局牺牲一些效率。 6、图形数据库应该怎么选型？选的时候需要考虑哪些问题？从系统自身考虑的话，包括高可靠性，读写效率、扩展性，与其他系统相同。 除此之外，还应该从整体规划和这个系统所处的位置进行考虑，为了满足整体规划，牺牲一些性能或者成本也是必要的。比如为了避免海量数据的多系统存储分析，就选用了以hadoop为基础的图数据库，这样所有的数据只需一份，可以供平台上的多个子系统进行使用。 7、为满足关键特性系统的架构或组件选择是怎样的？（主要针对hadoop架构）1.可视化需要开发一个专门的知识图谱展示界面，将知识图谱中的实体、关系属性等以美观已操作的方式展示出来，因为颜值即正义。可以借用当前比较流行的bootstrap等前端开发语言。 2.为满足快速查询，可以将部分索引关键字放在索引es中，索引命中后在使用key去titian中查询。 3.多种服务方式，需要从设计时就进行考虑，至少满足三种api、可视化界面、批量文件。批量文件主要从hive中进行导出，而api接口则需要开发一个服务层，将所有图数据库的命令行操作转换为对应的api接口，轻量级的开发一个java服务放在tomcat中，有条件的可以使用微服务框架。 8、知识图谱的建设都有哪些重要的环节，需要注意什么？从自身项目实施来看，有三个地方： 1.建模时多系统数据的融合，比如客户的信息存在多个系统中，核心、信贷、理财等，因为系统建设时间不一、多次升级等问题，导致数据不一致，数据质量较差，这样就需要花费很大精力去处理数据质量问题，还可能导致程序返工。 2.模型开发过中，选择哪些业务场景也很重要，知识图谱不是万金油，有些场景比较费力。应该选择那些跟关联关系分析相关的，有明确结果，业务人员能够明确正确与否的应用场景，便于展示这个工具的优越性。 3.交付前的测试也很重要。因为知识图谱基本上都是需要融合各个业务系统的数据，涉及面较广。因此要给测试过程留够时间，便于测试人员发现一些数据处理上的遗漏。 9、知识图谱与智能客服如何对接？主要是通过API接口，在接入的同时系统自动调出客户当前的资产负债状况，最近的交易明细，购买产品的状况。在提问的时候，通过nlp系统解析问题中的关键字，识别询问的实体、关系等，找到关联的问题，引导客户按照提问已有的问题。使用知识图谱的好处在于，可以快速的查询出客户周边的所有数据。如果使用传统关系型数据库，则需要按照业务种类，逐个表进行查询，分模块展示。在图谱中则可以一起展示出来，因为是从客户出发按照关联关系进行查询的，并且可以用一张图进行直观的展示。 10、部署时需要满足怎样的性能要求，qps或tps？如果建设面向外部客户的大规模知识图谱，有哪些可以优化的方向？性能的需求应该是与业务场景强相关的，如果是面向外部客户那就要考虑扩容节点提升整体性能，明细数据可以从hbase迁移到es中，加快查询速度，限制部分查询内容或者只能查看经过分析的子图。 对于行内系统，从数据安全角度来看，只有少部分人能看到所有数据，绝大多数人只能看到部分数据，而且应该是具有特定业务含义的数据，比如某个预警模型的结果。在这种情况下，权限范围内的数据量就很小了，那么在查询的过程中，效率也会相应提升，不会全表扫描。 11、有没有合适的企业级的分布式知识图谱技术架构？横向涉猎不多，答错勿怪。 titian就是分布式的，因为它是基于hbase的。 Neo4j 好像就不支持，不像hbase这么简单就可以进行扩展。 12、知识图谱存储会不会引起数据膨胀？图数据库本身不会，但是知识图谱这个系统会，一份数据至少存在于hive加工区和hbase查询区，还有少量的elasticsearch索引区。 13、关于实体、属性、关系的识别和存储？大多数情况下实体关系属性都是比较明确的，因为知识图谱的建模是与现实世界相符的。 比如银行来说客户就是实体，姓名，身 份 证 号码，手机号都是属性。 关系相对稍微复杂一点，不过常见的关系也都比较明确，比如客户经理和贷款户，机构和对公客户，合同和借款人等等。 银行这边的实体基本上都是自然人、账号，机构，合同、押品等，关系就是实体之间的关系，比如账号和自然人的归属关系。 实体、关系和属性都是存在titan里的，交易明细存在hbase里。 14、脏数据的处理机制是什么？知识图谱作为下游系统其实没有好的办法处理脏数据，基本上有两种策略： 第一：确定一个优先级，某个属性以哪个系统为准，当两个系统不一致时，不管对错永远以某个系统为准。 第二：前一种方法不适用的，就将这些数据打入“冷宫”，放到一张表里，定期拿出来，找原系统进行数据修正，这是一个比较漫长的过程。 不过好在，80%以上的数据是正常的，脏数据多数由于客户长期未发生业务，渠道无法强制客户更新数据。 15、如何解决外部数据源准确性？我个人无法从根本上解决，因为我们只是数据的使用方，准确性是需要从产生的根源上解决的问题。 不过在使用的时候可以进行多数据源的交叉验证，来提高准确性，完全消除是难以实现的。 16、用知识图谱做传统的风控行业，局限性在哪里？利用大数据挖掘，除知识图谱外，还有哪些比较好的风控模型？1.知识图谱是一种工具，是一种与关系型数据库相对的数据组织方式，有其擅长的领域，但不能手里拿着锤子，看哪里都是钉子。知识图谱也有不擅长的领域。 2.除大数据外，基于传统的关系型数据库开发一些机器学习或深度学习模型也可以做到风控。 原文链接：https://mp.weixin.qq.com/s/kAxnYpW16fc-JvwhAA8onA]]></content>
      <tags>
        <tag>知识图谱</tag>
        <tag>knowledge graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是微服务架构（Microservice Architecture）]]></title>
    <url>%2F2019%2F08%2F07%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%EF%BC%88Microservice-Architecture%EF%BC%89%2F</url>
    <content type="text"><![CDATA[背景假设你在开发一个服务端应用。该应用必须支持各种各样的客户端，包括桌面浏览器、手机浏览器和本地手机应用。应用可能也需要公开部分API供第三方使用，还可能与其他应用通过web service或消息代理(message broker)相集成。应用执行业务逻辑来处理请求(HTTP请求或者消息)；访问数据库；与其他系统交换消息；并返回HTML/JSON/XML类型的响应。 应用或是多层架构或是六角架构，并且包含多种类型的组件： 表示组件(Presentation components) - 响应处理HTTP请求，并返回HTML或JSON/XML(对于web service API) 业务逻辑(Business logic) - 应用的业务逻辑 数据库访问逻辑(Database access logic) - 数据访问对象用于访问数据库 应用集成逻辑(Application integration logic) - 消息层，如基于Spring的集成 这些逻辑组件分别响应应用中不同的功能模块。 问题应用的部署架构是什么？ 动机 该应用由一个开发者团队在维护 团队新成员必须快速上手 应用应该易于理解和修改 你想对应用进行持续集成 你必须在多台机器上部署多份应用的拷贝，以满足可伸缩性和可用性的要求 你想使用新技术(框架、编程语言等) 解决方案通过采用伸缩立方(Scale Cube)(特别是y轴方向上的伸缩)来架构应用，将应用按功能分解为一组相互协作的服务的集合。每个服务实现一组有限并相关的功能。比如，一个应用可能包含订单管理服务，客户管理服务等。 服务间通过HTTP/REST等同步协议或AMQP等异步协议进行通讯。 服务独立开发和部署。 每个服务为了与其他服务解耦，都有自己的数据库。必要时，数据库间的一致性通过数据库复制机制或应用级事件来维护。 举例我们假设你在构建一个电子商务应用，应用从客户接收订单，验证库存和可用额度，并派送订单。应用包含多个组件，包括StoreFrontUI，用来实现用户接口，以及一些后台服务，用于检测信用额度、维护库存和派送订单。 应用作为一组服务部署。 结果这个方案有一些好处： 每个微服务都相对较小 易于开发者理解 IDE反应更快，开发者更高效 web容器启动更快，开发者更高效，并提升了部署速度 每个服务都可以独立部署 - 易于频繁部署新版本的服务 易于伸缩开发组织结构。你可以对多个团队的开发工作进行组织。每个(双披萨[1])团队负责单个服务。每个团队可以独立于其他团队开发、部署和伸缩服务。 提升故障隔离(fault isolation)。比如，如果一个服务存在内存泄露，那么只有该服务受影响，其他服务仍然可以处理请求。相比之下，一体架构的一个出错组件可以拖垮整个系统。 每个服务可以单独开发和部署 消除了任何对技术栈(technologh stack)的长期投入(long-term commitments) 这个方案也有一些缺点： 开发者要处理分布式系统的额外复杂度。 开发者工具/IDE是面向构建一体应用的，并没有显示提供对开发分布式应用的支持 测试更加困难 开发者需要实现服务间通信机制 不使用分布式事务实现跨服务的用例更加困难 实现跨服务的用例需要团队间的细致协作 生产环境的部署复杂度。对于包含多种不同服务类型的系统，部署和管理的操作复杂度仍然存在。 内存消耗增加。微服务架构使用NxM个服务实例来替代N个一体应用实例。如果每个服务运行在自己独立的JVM(或类似)上，通常有必要对实例进行隔离，对这么多运行的JVN，就有M倍的开销。另外，如果每个服务运行在独立的VM(如EC2实例)，如Netflix，开销会更高。 挑战什么时候使用微服务架构使用该方法的一个挑战就是决定何时使用才合理。在开发应用的初期，你通常不会遇到这种方法试图解决的问题。而且，使用这个精细、分布式的架构将会拖慢开发进度。对初创公司，这是个严重问题，因为它们的最大挑战通常是如何快速发展业务模型及相关应用。使用Y轴切分使快速迭代更加困难。但是之后，当挑战变成如何伸缩，你需要使用功能分解将一体应用切分为一组服务时，混乱的依赖关系可能使之变得困难。 如何拆分应用到服务另一个挑战是如何将系统分隔为微服务。这是个技术活，但有些策略可能有帮助。 按业务能力分解，定义与业务能力对应的服务。 按领域驱动设计的子域分解。 按动词或用例分解并定义负责特定操作的服务。例如，负责装运完整订单的运输服务。 通过定义负责对给定类型的实体/资源执行所有操作的服务，按名词或资源进行分解。例如，负责管理用户帐户的帐户服务。 理论上，每个服务应该只承担很小的职责。Bob Martin(大叔)讲过使用单一职责原则(SRP)来设计类。SRP定义类的职责作为变化的原因，而且类应该只有一个变化的原因。使用SRP来设计服务也是合理的。 另一个有助于服务设计的类比是Unix实用工具的设计方法。Unix提供大量的实用工具如grep、cat和find。每个工具只做一件事，通常做得非常好，并且可以跟其他工具使用shell脚本组合来执行复杂任务。 如何保持数据一致性为了确保松耦合，每个服务都有自己的数据库。维护服务之间的数据一致性是一个挑战，因为对于许多应用程序来说，两阶段提交/分布式事务不是一个选项。应用程序必须使用SAGA模式。服务在其数据更改时发布事件。其他服务使用该事件并更新其数据。有几种可靠更新数据和发布事件的方法，包括事件源和事务日志跟踪。 如何实现查询另一个挑战是实现需要检索多个服务拥有的数据的查询。 API组合和命令查询责任分离（CQR）模式。 相关模式有许多与微服务模式相关的模式。单片架构是微服务架构的替代方案。其他模式解决了应用微服务体系结构时会遇到的问题。如API网关模式定义了客户端如何访问服务。 分解模式 按业务能力分解 按子域分解 每个服务模式的数据库描述了每个服务如何拥有自己的数据库，以确保松耦合。 API网关模式定义了客户机如何访问微服务体系结构中的服务。 客户端发现和服务器端发现模式用于将客户端请求路由到微服务体系结构中的可用服务实例。 消息传递和远程过程调用模式是两种不同的服务通信方式。 每个主机的单个服务和每个主机的多个服务模式是两种不同的部署策略。 交叉关注模式：微服务机箱模式和外部化配置 测试模式：服务组件测试和服务集成契约测试 断路器 访问令牌 可观测性模式： 日志聚合 应用程序度量 审核日志记录 分布式跟踪 异常跟踪 健康检查API 记录部署和更改 用户界面模式： 服务器端页面片段组合 客户端UI组成 著名案例大多数大规模的web站点，如 Netflix, Amazon和eBay都从一体架构转变为微服务架构。 Netflix是个非常受欢迎的视频流服务提供商，占有多达30%的互联网流量，它有着大规模、基于服务的架构。他们每天处理800+不同类型设备超过10亿次视频流API的请求。每个API可以展开成平均6次对后端服务的调用。 Amazon.com原有个两层架构。为了伸缩，他们迁移到一个包含上百个后端服务的基于服务的架构。调用这些服务的应用中包括实现Amazon.com网站和web service API的应用。Amazon.com网站应用调用100-150个服务来获取数据用于构建网页。 拍卖网站ebay.com也从一体架构发展成基于服务的架构。应用层包含多个独立的应用。每个应用实现特定功能模块(如购买或销售)的业务逻辑。每个应用使用X轴的分隔，有些应用如搜索，使用Z轴分隔。Ebay.com也对数据库层采用X,Y,Z的组合伸缩方式。 译自：https://microservices.io/patterns/microservices.html]]></content>
      <categories>
        <category>软件架构和服务架构</category>
      </categories>
      <tags>
        <tag>软件架构</tag>
        <tag>服务架构</tag>
        <tag>software architecture</tag>
        <tag>service architecture</tag>
        <tag>微服务架构</tag>
        <tag>microservice architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是一体化架构(Monolithic Architecture)]]></title>
    <url>%2F2019%2F08%2F07%2F%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%BD%93%E5%8C%96%E6%9E%B6%E6%9E%84-Monolithic-Architecure%2F</url>
    <content type="text"><![CDATA[背景假设你在开发一个服务端应用。该应用必须支持各种各样的客户端，包括桌面浏览器、手机浏览器和本地手机应用。应用可能也需要公开部分API供第三方使用，还可能与其他应用通过web service或消息代理(message broker)相集成。应用执行业务逻辑来处理请求(HTTP请求或者消息)；访问数据库；与其他系统交换消息；并返回HTML/JSON/XML类型的响应。 应用或是多层架构或是六角架构，并且包含多种类型的组件： 表示组件(Presentation components) - 响应处理HTTP请求，并返回HTML或JSON/XML(对于web service API) 业务逻辑(Business logic) - 应用的业务逻辑 数据库访问逻辑(Database access logic) - 数据访问对象用于访问数据库 应用集成逻辑(Application integration logic) - 消息层，如基于Spring的集成 这些逻辑组件分别响应应用中不同的功能模块。 问题应用的部署架构是什么？ 动机 该应用由一个开发者团队在维护 团队新成员必须快速上手 应用应该易于理解和修改 你想对应用进行持续集成 你必须在多台机器上部署多份应用的拷贝，以满足可伸缩性和可用性的要求 你想使用新技术(框架、编程语言等) 解决方案使用一体化架构构建应用。如： 单个Java WAR文件 单个Rails或NodeJS目录结构 举例我们假设你在构建一个电子商务应用，应用从客户接收订单，验证库存和可用额度，并派送订单。应用包含多个组件，包括StoreFrontUI，用来实现用户接口，以及一些后台服务，用于检测信用额度、维护库存和派送订单。 应用作为一体应用部署。例如，一个Java web应用运行在Tomcat之类web容器上，仅包含单个WAR文件；一个Rails应用使用Phusion Passenger部署在Apache/Nginx上，或者使用JRuby部署在Tomcat上，它们都仅包含单个目录结构。为了伸缩和提高可用性，你可以在一个负载均衡器下面运行该应用的多份实例。 结果这个方案有一些好处： 易于开发 - 当前开发工具和IDE的目标就是支持这种一体应用的开发 易于部署 - 你只需要将WAR文件或目录结构放到合适的运行环境下 易于伸缩 - 你只需要在负载均衡器下面运行应用的多份拷贝就可以伸缩 但是，一旦应用变大、团队增长，这种方法的缺点就愈加明显： 巨大的一体代码库可能会吓到开发者，尤其是团队的新人。应用难于理解和修改。因此，开发速度通常会减缓。另外，由于没有模块硬边界，模块化也随时间而破坏。还有，因为难于理解如何实现变更，代码质量也随时间下降。这是个恶性循环！ 超载的IDE - 代码库越大，IDE越慢，开发者效率越低。 超载的web容器 - 应用越大，容器启动时间越长。因此开发者大量的时间被浪费在等待容器启动上。这也会影响到部署。 难于持续部署 - 对于频繁部署，巨大的一体应用也是个问题。为了更新一个组件，你必须重新部署整个应用。这还会中断后台任务(如Java应用的Quartz作业)，不管变更是否影响到这些任务，此外还可能引发问题。未被更新的组件也可能因而不能正常启动。因此，鉴于重新部署的相关风险会增加，不鼓励频繁更新。这尤其对用户界面的开发者来说是个问题，因为他们通常需要快速迭代，频繁重新部署。 难于伸缩应用 - 一体架构只能在一个维度伸缩。一方面，它可以通过运行多个拷贝来伸缩满足业务量的增加。某些云服务甚至可以动态地根据负载调整应用实例的数量。但是另一方面，该架构不能伸缩满足数据量的增加。每个应用实例都要访问全部数据，这使缓存低效，并且提升了内存占用和I/O流量。而且，不同的组件所需资源不同 - 有些可能是CPU密集型的，另一些可能是内存密集型的。一体架构下，我们不能独立伸缩各个组件。 难于调整开发规模 - 一体应用对调整开发规模也是个障碍。一旦应用达到一定规模，将工程组织分成专注于特定功能模块的团队通常更有效。比如，我们可能需要UI团队，会计团队，库存团队等。一体应用的问题是它阻碍组织团队相互独立地工作。团队之间必须在开发进度和重新部署上进行协调。对团队来说也很难改变和更新产品。 需要对一个技术栈长期投入 - 一体架构迫使你娶下开发初选择的技术栈(某些情况下，是那项技术的某个版本)。一体架构下，很难递增式地采用更新的技术。比如，想象下你选了JVM。除了Java你还可以选择其他使用JVM的语言，它们比如Groovy和Scala也可以与Java很好地进行互操作。但是一体架构下，非JVM语言写的组件就不行。而且，如果应用使用了后期过时的平台框架，将应用迁移到更新更好的框架上就很有挑战性。还有可能，为了采用新的平台框架，你要重写整个应用，这就太冒险了。 相关模式微服务架构是解决一体化架构缺点的替代模式。 已知案例著名的互联网服务，如Netflix, Amazon.com和eBay开始都使用一体架构。作者开发的大部分web应用也是一体架构的。 译自：https://microservices.io/patterns/monolithic.html]]></content>
      <categories>
        <category>软件架构和服务架构</category>
      </categories>
      <tags>
        <tag>软件架构</tag>
        <tag>服务架构</tag>
        <tag>一体化架构</tag>
        <tag>software architecture</tag>
        <tag>service architecture</tag>
        <tag>monolithic architecture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件架构及常用的架构风格]]></title>
    <url>%2F2019%2F08%2F07%2F%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[前言：本来只想做一个“什么是微服务架构”，后来发现有许多基础的知识如果不做会很难看懂，因此把软件架构和常用的架构风格也一并讲了。大佬们的请直接移步第三部分。 软件架构软件架构的定义要理解微服务架构，首先要理解什么是软件架构。 计算机系统的软件架构是构建这个系统所需要的一组结构，包括软件元素、它们之间的关系以及两者的属性。————卡耐基梅隆大学 Len Bass 这句话，本质上就是在讲：应用程序的架构是将软件分解为元素（element），这些元素之间的关系（relation），以及这些元素自有的属性（property）。 软件架构的意义应用程序有两个层面的需求。第一类是功能性需求，这些需求决定一个应用程序做什么。这些通常都包含在用例（use case）或者用户故事（user story）中。应用的架构其实跟这些功能性需求没什么关系。功能性需求可以通过任意的架构来实现，甚至是非常糟糕的大泥球架构。 架构的重要性在于，它帮助应用程序满足了第二类需求：非功能性需求。我们把这类需求也称之为质量属性需求，或者简称为“能力”。这些非功能性需求决定一个应用程序在运行时的质量，比如可扩展性和可靠性。它们也决定了开发阶段的质量，包括可维护性、可测试性、可扩展性和可部署性。为应用程序所选择的架构将决定这些质量属性。 也可以从以下几点来讲软件架构的意义： 它促进了劳动和知识的分工。它使具有特定专业知识的人们（或多个团队）能够就应用程序高效地协同工作。 它定义了软件元素的交互方式。 将软件分解成元素以及定义这些元素之间的关系，决定了软件的能力。 软件架构的4+1视图模型 每个视图的目的如下： 逻辑视图：开发人员创建的软件元素。在面向对象的语言中，这些元素是类和包。它们之间的关系是类和包之间的关系，包括继承、关联和依赖。 实现视图：构建编译系统的输出。此视图由表示打包代码的模块和组件组成，组件是由一个或多个模块组成的可执行或可部署单元。在Java中，模块是JAR文件，组件通常是WAR文件或可执行JAR文件。它们之间的关系包括模块之间的依赖关系以及组件和模块之间的组合关系。 进程视图：运行时的组件。每个元素都是一个进程，进程之间的关系代表进程间通信。 部署视图：进程如何映射到机器。此视图中的元素由（物理或虚拟）计算机和进程组成。机器之间的关系代表网络。该视图还描述了进程和机器之间的关系。 除了这四个视图以外，4+1中的+1是指场景，它负责把视图串联在一起。每个场景负责描述在一个视图中的多个架构元素如何协作，以完成一个请求。例如，在逻辑视图中的场景，展现了类是如何协作的。同样，在进程视图中的场景，展现了进程是如何协作的。 常用的架构风格架构风格的定义如下： 架构风格根据结构组织模式定义了一系列此类系统。更具体地说，架构风格确定可以在该风格的实例中使用的组件和连接器的词汇表，以及关于如何组合它们的一组约束。————David Garlan and Mary Shaw 特定的架构风格提供了有限的元素（组件）和关系（连接器），你可以从中定义应用程序架构的视图。应用程序通常使用多种架构风格的组合。例如，单体架构可以通过不同的风格通的实现视图构造为单个（可执行与可部署）组件的架构样式。微服务架构将应用程序构造为一组松散耦合的服务，也可以通过不同的风格进行表示。 分层式架构风格架构的典型例子是分层架构。分层架构将软件元素按“层”的方式组织。每个层都有明确定义的职责。分层架构还限制了层之间的依赖关系。每一层只能依赖于紧邻其下方的层（如果严格分层）或其下面的任何层。 可以将分层架构应用于前面讨论的四个视图中的任何一个。流行的三层架构是应用于逻辑视图的分层架构。它将应用程序的类组织到以下层中： 表现层：包含实现用户界面或外部API的代码。 业务逻辑层：包含业务逻辑。 数据持久化层：实现与数据库交互的逻辑。 分层架构是架构风格的一个很好的例子，但它确实有一些明显的弊端： 单个表现层：它无法展现应用程序可能不仅仅由单个系统调用的事实。 单一数据持久化层：它无法展现应用程序可能与多个数据库进行交互的事实。 将业务逻辑层定义为依赖于数据持久化层：理论上，这样的依赖性会妨碍你在没有数据库的情况下测试业务逻辑。 此外，分层架构错误地表示了精心设计的应用程序中的依赖关系。业务逻辑通常定义数据访问方法的接口或接口库。数据持久化层则定义了实现存储库接口的DAO类。换句话说，依赖关系与分层架构所描述的相反。 六边形架构风格六边形架构是分层架构风格的替代品。如图所示，六边形架构风格选择以业务逻辑为中心的方式组织逻辑视图。应用程序具有一个或多个入站适配器，而不是表示层，它通过调用业务逻辑来处理来自外部的请求。同样，应用程序具有一个或多个出站适配器，而不是数据持久化层，这些出站适配器由业务逻辑调用并调用外部应用程序。此架构的一个关键特性和优点是业务逻辑不依赖于适配器。相反，各种适配器都依赖业务逻辑。 业务逻辑具有一个或多个端口（port）。端口定义了一组操作，关于业务逻辑如何与外部交互。例如，在Java中，端口通常是Java接口。有两种端口：入站和出站端口。入站端口是业务逻辑公开的API，它使外部应用程序可以调用它。入站端口的一个实例是服务接口，它定义服务的公共方法。出站端口是业务逻辑调用外部系统的方式。出站端口的一个实例是存储库接口，它定义数据访问操作的集合。 业务逻辑的周围是适配器。与端口一样，有两种类型的适配器：入站和出站。入站适配器通过调用入站端口来处理来自外部世界的请求。入站适配器的一个实例是Spring MVC Controller，它实现一组REST接口（endpoint）或一组Web页面。另一个实例是订阅消息的消息代理客户端。多个入站适配器可以调用相同的入站端口。 出站适配器实现出站端口，并通过调用外部应用程序或服务处理来自业务逻辑的请求。出站适配器的一个实例是实现访问数据库的操作的数据访问对象（DAO）类。另一个实例是调用远程服务的代理类。出站适配器也可以发布事件。 六边形架构风格的一个重要好处是它将业务逻辑与适配器中包含的表示层和数据访问层的逻辑分离开来。业务逻辑不依赖于表示层逻辑或数据访问层逻辑。 由于这种分离，单独测试业务逻辑要容易得多。另一个好处是它更准确地反映了现代应用程序的架构。可以通过多个适配器调用业务逻辑，每个适配器实现特定的API或用户界面。业务逻辑还可以调用多个适配器，每个适配器调用不同的外部系统。六边形架构是描述微服务架构中每个服务的架构的好方法。 reference:https://mp.weixin.qq.com/s/r9eKHhEKWo5TovFN87HtPw]]></content>
      <categories>
        <category>软件架构和服务架构</category>
      </categories>
      <tags>
        <tag>软件架构</tag>
        <tag>software architecture</tag>
        <tag>架构风格</tag>
        <tag>architecture style</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何走出职场焦虑、避免中年危机]]></title>
    <url>%2F2019%2F08%2F06%2F%E5%A6%82%E4%BD%95%E8%B5%B0%E5%87%BA%E8%81%8C%E5%9C%BA%E7%84%A6%E8%99%91%E3%80%81%E9%81%BF%E5%85%8D%E4%B8%AD%E5%B9%B4%E5%8D%B1%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[自我认识有人对自己工作进行抱怨时，经常会用到“不会做，不好做，不想做”这样的词语。然而“不会做”，“不好做”，“不想做”表达的是同样的含义么？这些表述背后又透露了什么信息呢？ 为了帮助大家分析自己，美国著名心理学家麦克利兰提出了一个“冰山模型”，把一个人的素质要素分成了三类： 知识、技能 能力 价值观、性格特质、动机 知识、技能 能力 价值观、性格特质、动机 解释 通过学习和实践获得的可以使用在特定领域的认知、经验、技术，如学过的数学知识、写作修辞手法、office套件的使用方法等 可以在不同领域使用的通用能力，如学习能力、人际交往能力 判断事物的是非标准、行为偏好、成就动机、权利动机、亲和动机 和工作不匹配的表现 不会做，慌乱焦虑、无所适从 不好做，低效、无奈 不想做，矛盾纠结、没热情、心累 职业匹配职业，本质上是关键业务的集合。看一个人和他的职业匹不匹配，就是看他是否需要、擅长、喜欢自己负责的业务。 可以通过下表来对自己和职业的匹配进行评估，只需要根据冰山模型填上自己的个人素质、自己目前需要什么（钱、社区、人脉等），再根据和每个业务的匹配关系给出1-5的评分即可。 个人素质 业务1的匹配分数 业务2的匹配分数 ... 喜欢 价值观 性格特质 动机 擅长 知识 技能 能力 需要 需要 职业调整当我们对自己进行职业匹配之后，发现自己不喜欢、不擅长、不需要某一份工作的时候应该怎么办呢？ 不喜欢不喜欢是和一个人的根本挂钩的，很难靠改变自己来喜欢上某个工作或者业务，最好是对工作进行调整： 调整业务内容和目标（业务内调整） 更换负责的业务（岗位内调整） 请求更换岗位（公司内调整） 跳槽 不擅长不擅长说白了是自己的知识储备不够、技术水平不过关、能力不足导致的。需要不是外界的调整，而是自我的提升。 不需要不需要，本质上是这份工作不能满足你的某些需求。那么只需要分析其中的原因即可： 业务原因。这个业务不被重视，没有前景，可能会被砍掉 行业原因。行业普遍工资低/加班等 职业原因。某类岗位就是重复性机械劳动，难以接触新的事物 公司原因。这公司药丸 分析清楚了原因，就知道从哪里下手了。 内在提升时间要投入到自我提升上，才会有工资的提升。自我提升有以下几种： 知识提升提升自己的知识储备，不必每次都去搜索学习。 但是要注意，学了知识之后，如果可以灵活运营，则满腹经纶指点江山，否则就是读死书，浪费时间。 因此，要注意： 要学会提取知识的核心，掌握20%的核心知识。比如做ppt漂亮的核心就是饱和度、边框、行间距 知识和问题关联起来，学习知识的时候就要联系到它能解决什么问题 系统化训练，刻意使用刚刚学到的知识，不要快速遗忘 技能提升技能的定价和天花板取决于其稀缺性。 某一技能可能在稀缺时期很值钱，但是随着供求关系发生变化，其市场价值依然会产生波动。 能力提升技能熟练，只是一个好兵，能力强大，才能得到提升，成为将才。 能力提升可以跨行业跨职业，一旦积累到一定高度，换个公司、行业、职业一样可以吃的开，挣到钱。 提升自我、认识自我提升自我：对事物有更加深刻的看法，有更加成熟的三观，锻炼自己的某种特质 认识自我：有自知之明，找到更加适合自己的环境和土壤 外在提升外在提升主要就是提升自己周围的环境，物理环境和社会环境。 物理环境的提升可以通过搬家、打扫卫生等完成。 社会环境，主要由自己的人脉构成，扩展、优化自己的人脉，就是提升自己的社会环境的过程。 提升过程中需要注意以下几个误区： 皇冠综合症：只顾低头做事，等待伯乐发现自己，给自己戴上皇冠，这是不对的。要学会主动争取，树立个人品牌，展现自己的价值 名片囤积：人脉的构建不是基于名片的互换，而是基于价值的互换 人脉关系中存在以下几种角色，可以帮助你迅速定位自己： 节点：把大家连接在一起的人 专家：掌握信息、知识甚至是资源的人 明星：有强烈个人魅力的人 助理：在圈子里提供服务的人 持续成长 长远规划，给自己定好发展方向 提升能力，成为可迁移人才 提升认知高度，成为纵向深度人才，多思考： 这个行业中的关键成功要素是什么 行业的社会价值是什么 部门、岗位、公司的核心价值是什么 在成长的几个阶段，需要注意： 起步期：靠自己 思维方面，形成独立见解 效率方面，学会多任务，能够高效处理工作，管理时间 沟通方面，理解他人需求，条理清楚 交际方面，懂得人际拓展方法 发展期：靠别人 思维方面，掌握解决复杂问题、拆分工作的方法 效率方面，懂得如何辅导和激励下属工作，不让自己累死 沟通方面，掌握说服他人的技巧，懂得公开表达 交际方面，能够处理团队内部或跨部门的冲突，进行高难度沟通 成熟期：靠影响力 思维方面，要更加有高度，掌握战略思维、经济学思维等 效率方面，掌握运营和财务的知识，更好的配置资源 沟通方面，了解公司，知道如何向用户推销自己，营销思维 交际方面，全面进阶的领导力]]></content>
      <categories>
        <category>个人提升系列</category>
      </categories>
      <tags>
        <tag>职业规划、个人提升</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[米兰攻略（一）：缘起、准备]]></title>
    <url>%2F2019%2F07%2F08%2F%E7%B1%B3%E5%85%B0%E6%94%BB%E7%95%A5%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BC%98%E8%B5%B7%E3%80%81%E5%87%86%E5%A4%87%2F</url>
    <content type="text"><![CDATA[缘起现在的年轻人大多更加讲究效率，对于为什么、怎么回事问的少了，只为了更加关注于事情本身，任何细节都不愿放过：即便要靠脑补来填充。而很多故事的有趣之处，其实也就是在缘起之处，这里是万事之始，这里种下了一切的因缘。 本人男，直博二年级在读，学校姑且叫Z大好了。博士毕业，无非三点：论文、论文、还有论文。第一个论文是SCI（主要是期刊论文），第二个论文是EI（主要是会议论文），第三个论文叫做“优秀的、有一定影响力的工作”。为了能够按时毕业，我投稿了专业领域的一个知名会议：E会。投稿的另一个原因是，E会2019年的会址在米兰，我还未曾去过。我的导师也未曾去过。 不幸的是，由于动机不纯导致文章灌水灌的有失水准，我的文章被reject。故事本应结束，导师却凌空一指：转投E会旗下的workshop。所谓workshop，可以看作一个会议旗下的子会，虽然没什么影响力，又对博士毕业、教授职称之类的没什么帮助，好在与E会共享会址和所有安排，于外可以交流学习、于内可以交差报销。于是，我的文章经过一轮大修，不出意外的中了一个workshop，H子会。 中了之后我的第一反应是：可惜了我的文章。第一次被拒我是认的，写的仓促，实在垃圾。大修之后我感觉这篇文章火候已经小成，只中一篇workshop，未免有些可惜了。 算了，为了米兰，算了。 准备说来惭愧，从进入大学开始，便一直叫嚣要出国旅游一趟，却由于种种原因一直未能成行。 这句话我原本深信不疑，直到我真的要出国了，我才发觉其中的问题。种种原因其实只有一个：怂。没错，要出国了，要去意大利了，要去米兰了，我怂了。 有人说欧洲资本主义国家先进发达，吐槽国内保守落后，但是真的要出国了，才觉得国内真乃世外桃源。手机支付暂且不谈，主要是安全问题，意大利的治安在欧洲算是一般，但依然不安全。问起身边的人才知道，国内的两位老师日前去意大利访学，在街头被公然抢包；学生旅游，被偷包偷钱的更是不胜枚举。离别之时才想起家里的好，多年在外求学，如今终于要念起乡愁了。 再者就是意大利并不怎么说英语，主要还是讲意大利语。这就麻烦了，都说学好英国话，走遍天下都不怕，意大利与英国不远，语言却已然不同。好在我天赋异禀，出行一周前，只花了4天便入门了意大利语，又花了3天将其忘得一干二净。到了意大利，英语，真香。 为了这8天7夜的旅游交流学习，经过一通调查，我带了 剃须刀 两部手机及充电器：一部手机放国外的流量卡 充电宝 一个意标插口转换器 国标插线板 几套衣服 拖鞋、牙刷牙膏护肤品：意大利很多酒店都不提供，最好还是自己带上 护照、身份证+护照申请各项材料：入境的时候可能会看 国外信用卡：大部分地方都是可以刷信用卡的 400欧元：所有地方都收现金，不需要给小费 申请签证就不细讲了，意大利大使馆官网上有一个清单，照着准备就是。大学生可以不准备父母的关系证明，但是银行卡上要存个2、3万，让签证官相信你有钱回来。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>米兰</tag>
        <tag>攻略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意大利语学习（十三）：租房子（下）]]></title>
    <url>%2F2019%2F07%2F03%2F%E6%84%8F%E5%A4%A7%E5%88%A9%E8%AF%AD%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9A%E7%A7%9F%E6%88%BF%E5%AD%90%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[课文对话1Giulio：Ciao Marta. Vieni, entra! 嗨玛塔。来吧，进来！ Marta：Grazie! Tu sei Giulio, vero? 谢谢！你是朱利奥，不是吗？ Giulio：Sì, in persona! Come stai? 是的，亲自（就是本人）！你好吗？ Marta：Tutto bene, grazie! Siena mi piace molto. Mi sembra una città molto vivace 好的，谢谢！我真的很喜欢锡耶纳。在我看来，这是一个非常活跃的城市 Giulio：Sono d’accordo con te! Anche a me piace abitare in questa città 我同意你的看法！我也喜欢住在这个城市 Giulio：Io sono di Sassari ma vivo a Siena da quattro anni 我来自萨萨里，但在锡耶纳住了四年 Giulio：e sempre in questo appartamento 而且总是在这间公寓里 Marta：Davvero? Allora ti trovi bene qui… 真的吗？那你在这里感到很舒服…… Giulio：Hai ragione, mi piace molto questa casa 你是对的，我真的很喜欢这个房子 Giulio：Vieni, ti faccio vedere la camera libera 来吧，我会告诉你空的房间 Marta：Okay, andiamo! 好的，我们走吧！ Giulio：Ecco, questa è la singola 在这里，这是单间 Giulio：C’è un letto da una piazza, un armadio, una scrivania 配有一张单人床，衣柜和书桌 Giulio：c’è una lampada sul comodino 床头柜上有一盏灯 Giulio：È una stanza luminosa perché ci sono due finestre! 这是一个明亮的房间，因为有两个窗户！ Marta：È vero, c’è molta luce anche oggi che il cielo è grigio 确实，即使在今天天空是灰色的时候也会有很多光 Marta：Secondo me fra poco comincia a piovere! 我想它很快就会下雨！ Marta：Senti, ma quanti bagni ci sono? 看，有多少间浴室？ Giulio：Solo uno. Però finora non ci sono stati problemi con gli altri coinquilini 只有一个。但到目前为止，其他室友没有遇到任何问题 Marta：Sì, poi basta avere un po’ di pazienza… C’è la doccia o la vasca da bagno? 是的，然后有点耐心……有淋浴或浴缸吗？ Giulio：La doccia. Vieni, è di qua, guarda! 淋浴。来吧，这就是它，看！ Marta：Bella! E anche il colore del bagno mi piace: io amo il blu! 美丽！我也喜欢浴室的颜色：我喜欢蓝色！ Giulio：E questa è la cucina. È un po’ piccola ma c’è tutto quello che serve: 这是厨房。它有点小，但有你需要的一切： Giulio：piatti, bicchieri, pentole, frigo, fornelli, e forno ma non funziona bene 盘子，杯子，锅，冰箱，炉子和烤箱，但它不能很好地工作（不一定好用） Giulio：Sai qui non siamo bravi cuochi… 你知道我们这里不是好厨师…… Giulio：Mangiamo molte insalate e pasta. Tu sai cucinare? 我们吃了很多沙拉和意大利面。你能做饭吗？ Marta：Mah… insomma. Mamma mi ha insegnato qualche ricetta ma… 嗯……简而言之。妈妈教我一些食谱，但…… Giulio：Okay, se vieni a abitare con noi le proveremo le ricette della tua mamma! 好的，如果你和我们住在一起，我们会尝试你妈妈的食谱！ Giulio：E questo è il soggiorno 这是起居室 Giulio：un tavolo con quattro sedie, il televisore, il divano e la poltrona 一张桌子有四把椅子，电视，沙发和扶手椅 Giulio：I mobili sono un po’ vecchi ma ancora in buone condizioni 家具有点旧，但仍然状况良好 Giulio：Insomma, di solito ci troviamo tutti qui per mangiare 总之，我们通常都在这里吃饭 Giulio：e rilassarci dopo il lavoro 下班后放松一下 Marta：Bella, anche questa stanza è luminosa 美丽，这个房间也很明亮 Giulio：Sì, anche qui c’è una finestra grande 是的，即使在这里也有一个大窗户 Marta：E la camera dell’altra ragazza? 而另一个女孩的房间？ Giulio：Anche Tania ha una singola 塔尼亚也有单间 Giulio：È la stanza in fondo al corridoio, quella vicina al bagno 是走廊尽头的房间，靠近浴室的房间 Marta：Senti, l’appartamento mi piace! 看，我喜欢这套公寓！ Giulio：Anche la zona è perfetta perché è molto vicino all’ospedale 该地区（位置）也很完美，因为它离医院很近 Marta：Sì, è vero. E l’atmosfera in casa è divertente! 是的，这是真的。房子里的气氛很有趣！ Marta：Benissimo, allora ho deciso, prendo in affitto la camera 很好，然后我决定，我租房间 Marta：Quando posso venire? 我什么时候能来？ Giulio：Sono contento! Vieni quando vuoi, anche domani 我很高兴！随时随地，即使是明天 Giulio：Intanto dico a Tania che abbiamo trovato una ragazza per la singola 与此同时，我告诉塔尼亚，我们为单间找到了一个女孩 Marta：Okay, allora vengo domani mattina alle 11 好的，所以我明天早上11点来 Marta：Sei in casa o ti devo telefonare un po’ prima? 你在家还是我早点打电话给你？ Giulio：Sarò a casa. Faccio i turni al lavoro e domani lavoro di notte 我会回家。我明天晚上轮流上班，晚上上班 Giulio：Stai tranquilla, ti aspetto qui! 放心，我会在这儿等你！ Marta：Grazie Giulio, sei davvero gentile! A domani… e non vedo l’ora! 谢谢朱利奥，你真的很善良！明天见！我等不及了！]]></content>
      <categories>
        <category>意大利语学习</category>
      </categories>
      <tags>
        <tag>意大利语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意大利语学习（十二）：租房子（上）]]></title>
    <url>%2F2019%2F07%2F03%2F%E6%84%8F%E5%A4%A7%E5%88%A9%E8%AF%AD%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%A7%9F%E6%88%BF%E5%AD%90%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[课文对话1Marta：Buongiorno, mi chiamo Marta, telefono per l’annuncio della camera in affitto 您好，我的名字是Marta，电话是看到了租房间的公告 Giulio：Buongiorno! 你好！ Giulio：Sì, la camera è ancora libera. Sei di Siena? 是的，房间仍然是空的。你是在锡耶纳吗？ Marta：No, di Pescare. Sono appena arrivata a Siena 不，我在Pescare。我刚刚抵达锡耶纳 Giulio：Lavori o studi? 工作还是学习？ Marta：Lavoro, faccio l’infermiera… 我工作，我是一名护士…… Giulio：Vuoi vedere la camera? 想看房间吗？ Marta：Sì certo, la vedo volentieri! È una camera singola, vero? 是的，当然，我心甘情愿地看到它！这是单人间，不是吗？ Marta：Prima vorrei sapere quanto costa 我首先想知道一个月租金多少 Marta：sto facendo un tirocinio in ospedale e non posso spendere molto 我在医院实习，而且我不能花太多钱 Giulio：250 euro. Per una singola non è molto! 250欧元。对于一个单间的它并不多！ Giulio：Sai che in città gli affitti sono abbastanza cari… 你知道在城市租金很贵…… Marta：Le spese sono incluse? 是否包括（全部其他）费用？ Giulio：Tutto incluso eccetto il telefono che è a parte 全包，但电话除外 Marta：Il prezzo va bene 价格还可以 Marta：L’annuncio dice che l’appartamento è vicino all’ospedale 公告称该公寓靠近医院 Marta：Puoi darmi altre informazioni? 你能给我更多信息吗？ Giulio：L’appartamento è vicino a Piazza Libertà a due minuti dall’ospedale 公寓靠近PiazzaLibertà，距医院仅2分钟路程 Giulio：È luminoso, carino 它很明亮，很舒适 Giulio：C’è anche la lavatrice 还配有一台洗衣机 Giulio：In casa ci abito io e una ragazza 我和一个女孩住在房子里 Giulio：che fa la cameriera in un hotel in centro 她是市中心酒店的女服务员 Giulio：È simpatica 她很好（人很好） Marta：Bene, sembra tutto perfetto… ma cose negative? 好吧，一切看起来都很完美……但是缺点呢？ Giulio：Forse l’unico problema è il rumore del bar di fronte alle nostre finestre 也许唯一的问题是我们窗户前酒吧的噪音 Giulio：Alcune sere, in particolare d’estate 有些晚上，特别是在夏天 Giulio：ci sono ragazzi che parlano forte e a volte cantano fino a tardi… 有些人大声说话，有时候唱到很晚…… Marta：Comunque vorrei vedere l’appartamento 不过我想看看公寓 Marta：perché devo trovare presto una camera 因为我必须尽快找到一个房间 Marta：Ora sono ospite di una collega ma non posso restare a lungo 现在我是同事的客人（在我同事家住），但我不能待久 Marta：perché ci sono già troppe persone in quell’appartamento 因为那间公寓里的人已经太多了 Giulio：Io domani mattina sono a casa dalle 10 in poi. Tu quando sei libera? 明天早上我从上午10点开始回家。你什么时候有空？ Marta：Alle undici e mezza va bene? 十一点半可以吗？ Giulio：Allora ti aspetto in via Dante 37, interno 3 然后我在Dante 37号，3里面等 Marta：Okay, grazie mille, ci vediamo domani! Ma come ti chiami? 好的，非常感谢，明天见！但是你的名字是什么？ Giulio：Oh, scusa non mi sono presentato. Sono Giulio, Giulio Conti 哦对不起，我没有出现。我是Giulio，Giulio Conti Marta：Ciao Giulio! A domani 好的Giulio！明天见]]></content>
      <categories>
        <category>意大利语学习</category>
      </categories>
      <tags>
        <tag>意大利语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意大利语学习（十一）：在网吧]]></title>
    <url>%2F2019%2F07%2F03%2F%E6%84%8F%E5%A4%A7%E5%88%A9%E8%AF%AD%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9C%A8%E7%BD%91%E5%90%A7%2F</url>
    <content type="text"><![CDATA[课文对话1Mario：Buongiorno! 早上好！ Anna：Buongiorno. Vorrei usare internet 早上好。 我想使用互联网 Mario：Certo. Può usare il computer n°3 当然。 您可以使用计算机＃3 Anna：Come si usa? È la prima volta che vengo ad un internet point 怎么用？ 这是我第一次来到互联网点 Mario：Lei mi dà un documento di identità 给我一张身份证 Mario：io la registro e le do un username e una password 我会录制它并给你一个用户名和密码 Mario：Lei inserisce questi dati prima di accedere ad internet e quando ha finito, clicca su logout 您在访问互联网之前输入此数据，完成后点击注销 Anna：Quanto costa? 它需要多少钱？ Mario：Dipende da quanto tempo usa internet. Il minimo è mezz’ora e costa 1 euro 这取决于你使用互联网的时间。 最短为半小时，费用为1欧元 Anna：Ho visto che ci sono delle cabine telefoniche 我看到有电话亭 Anna：Quanto costa chiamare all’estero? 打电话到国外需要多少钱？ Mario：Dipende dal paese, signora 女士，取决于国家 Mario：Lei compra una scheda e ha un tot di minuti a disposizione 你买了一张卡，有几分钟可用 Anna：Quanto costa una scheda? Mia sorella non sta molto bene e devo telefonarle 一张卡多少钱？ 我姐姐（身体）不是很好，我得给她打电话 Mario：Quella da 60 minuti costa 5.50 euro, quella da 120, ne costa 20 60分钟的费用为5.50欧元，120分钟的费用为20分钟 Anna：Mi dia quella da 20 euro 给我那20欧元（的电话卡） Mario：Bene, ecco a lei 嗯，这是给你的 Anna：Grazie. Qual è il numero del computer, scusi? 谢谢。 电脑编号是多少，对不起？ Mario：Il 3, da quella parte 3，在那一边 Anna：Grazie mille 非常感谢你 Mario：Prego 请（不客气）]]></content>
      <categories>
        <category>意大利语学习</category>
      </categories>
      <tags>
        <tag>意大利语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意大利语学习（十）：购物2]]></title>
    <url>%2F2019%2F07%2F03%2F%E6%84%8F%E5%A4%A7%E5%88%A9%E8%AF%AD%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E8%B4%AD%E7%89%A92%2F</url>
    <content type="text"><![CDATA[课文对话1Anna：Buon giorno signore, desidera? 早上好，先生，想要（买东西）？ Mario：Posso vedere quella giacca Bianca esposta in vetrina? 我可以（看看）在窗口看到那件白色夹克吗？ Anna：Che taglia ha? 多大号？ Mario：La 44 44（号） Anna：Adesso quarto, Signore, è fortunata: è propio la sua taglia 现在第四（我找找看），先生，很幸运：这是你的身材（尺寸） Mario：Vediamo… Di che stoffa è? 让我们看看……它有什么材料？ Anna：Di lino: Pratico ed elegante 是亚麻的：实用而优雅 Mario：Mi piace molto. Posso provarla? 我非常喜欢它。 我可以试试吗？ Anna：Certamente, si accomodi in camerino 当然，坐在更衣室里 Mario：Questa giacca mi va benissimo e questo modello mi sta bene 这件夹克非常适合我，这一款式看起来很棒 Anna：Veramente le va a pennello 实际上非常合身 Mario：Quanto costa? 它需要多少钱？ Anna：Con lo sconto del 50%, paga solo 200 euro. Un vero affare! 享受50％的折扣，只需支付200欧元。 一个真正的讨价还价（非常实惠）！ Mario：Va bene la compro. Posso pagare con un assegno? 好吧我买了。 我可以用支票付款吗？ Anna：Senz’altro. Alla cassa prego 当然可以。 请在收银台（付款）]]></content>
      <categories>
        <category>意大利语学习</category>
      </categories>
      <tags>
        <tag>意大利语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意大利语学习（零）：入门词汇]]></title>
    <url>%2F2019%2F07%2F02%2F%E6%84%8F%E5%A4%A7%E5%88%A9%E8%AF%AD%E5%AD%A6%E4%B9%A0%EF%BC%88%E9%9B%B6%EF%BC%89%EF%BC%9A%E5%85%A5%E9%97%A8%E8%AF%8D%E6%B1%87%2F</url>
    <content type="text"><![CDATA[a 至、到、对、于 abbiamo 我们、我们的 abitanti 人 abiti 衣服、居住、生活 abitiamo 生活、居住 abito 连衣裙、住 accanto 下面 accordo 协议、合同、协定 ad 到、至 aiuta 帮助 aiutiamo 帮助 aiuto 帮助 alla 一、一个 allegro 快活 allora 然后、那么、于是、也就是说 alta 高 anche 还 ancora 更、更多、仍然 ancora 更、进一步讲 andiamo 让我们去 anni 年龄、岁 anziani 老年的 appartamenti 公寓 appunti 笔记 arrivare 取得、到达 arrive 到达 ascolto 听 assistono 帮助 attentamente 小心地、仔细地 attivamente 积极地 aula 教室 avere 有 avete 你、你们 avvocato 律师 bambine 女孩、少女 bambini 孩子 belle 漂亮的 bene 良好 bene 良好 bravi 良好 calcio 足球 cambiando 改变 capito 了解、理解、明白 carattere 人物、性格 casalinga 家庭主妇 case 房子、住房 c’è 那里（有） cerca 搜索、寻找 certo 当然 che 那、那个 chi 谁 chiamano 通话 chiamarli 通话 chiedo 我问、寻求 ci 那里（有） ci 我们 cognato 姐夫 come 如何 con 同、和…一道 conosciamo 我们知道、我们认识 convinta 相信 coppie 对、成对的 corso 课程 cose 事 costano 成本 crescita 发展、增长 da 从 decidono 决定 degli 从 della …中 demografica 人口 dice 他说 difficoltà 困难 dimostra 节目、表现、展示 discussione 讨论 disinvolto 随便、随和 divisa 分 divorziata 离婚 donne 妇女 dopo …之后 dormo 睡觉 dove 哪里 durante 在…期间 economiche 经济 ed 和 edificio 建筑 elementare 初级、初等 energico 有活力 eravamo 我们 esatto 正是、准确、正好 esercizi 演习、练习 fa 前、之前 faccio 我、在下 facile 容易 facilmente 容易 facoltà 学院 figlio 儿子 formano 形式、形成 fra 中 fratello 兄弟 fuori 出 genitori 父母 già 已经 giovane 年轻 giovane 年轻 gli 该 grammaticale 语法的 grande 伟大、大 ha 它、它有 hai 您、你们 ho 我 i 该、在、对、将 i 该、在、对、将 immagino 我想象 importante 重要 incontro 会议、遇到 indica 指示、表示 infatti 其实 ingegnere 工程师 insegna 教书 insegnano 他们教 invece 代替为、更改为 la 该、在、对、将 lavora 工作的 lavorano 工作的 lavoro 工作的 le 该、在、对、将 leggere 阅读 leggo 我读 lei 您、你们 lei 她 letterature 文献、文学 lettore 读者 lettrice 读者 lezione 一课、教训 linea 线、线性 lingua 语言 linguistico 语言 litighiamo 我们吵架 lo 该、在、对、将 lontano 远 loro 他们的 lui 他 ma 但 marito 丈夫 materna 保育、养老 mattina 上午 me 我 medico 医生 meno 少、更少 mese 月 metro(metropolitana) 地铁 mezza 一半 mica facile 不容易 miei 我的 migliorare 提高 migliori 最好的 moglie 妻子 molte 许多、多于 molti 许多、多于 molto 很、许多 morti 死、去世 ne ho 我有 nella 在、在…中 nello 在…中 nipoti 孙子 non 不 nonna 祖母 nonni 祖父母、爷爷、奶奶等 numerose 众多、大量 nuovi 新 o 或 occupa 交易、涉及 oggi 今天 ogni 每 ora 小时（单） ore 小时（复） orientali 东方的 ottima 优秀、卓越 palazzo 宫殿、建筑 parenti 亲属 parla 说、说话 parlare 谈话 partecipo 我参加 passano 通过、度过 passato 过去 per 为了、对于 per perché 为、因为 perché 因为 perfettamente 完美、很好的 perfetto 完美 però 然而 piccolo 小 più 更、更多 possibile 可能 posso 我可以 posto 地方、位置、地位 prendiamo 拿、取、采、喝 prendo 拿、取、采、喝、乘坐 presto 不久、很快 proposito 目的、宗旨 proprietà 属性 proprio 自己、本身 proverbio 谚语 purtroppo 不幸、遗憾的是、可惜 quando 当 quanti 多少 quasi 几乎 qui 这，这里 raccontare 告诉 ragazzo 男孩、男朋友 ragione 理智、理性 ragioni 原因 rare 稀有 ricordo 记忆 sa 知道 scadente 坏的 scrivere 写 scrivi 写 scuola 学校 sembra 似乎、大概 sempre 曾经、以往、永远 seriamente 认真 siamo 我们 simpatico 可爱、讨人喜欢 so 我知道 società 公司 solo 只、仅仅 somiglio 我长得像 sono 他们是 sorelle 姐妹 speriamo 希望、但愿如此 spesso 常 spiegazione 说明、解释 sposata 已婚 sposati 已婚 stanno 它们是 stesso 相同 straniere 国外的 struttura 结构 studio 学习、研究、工作 suo 它的 tanti 许多 tanto 许多 telefoniamo 通话 tempo 时间 testo 文本、课文 tipo 这种、这样 tra 之间 troppo 太、太大、太高 trova 位于、定位 tuo 你的 tutti 所有 tutto 所有、一切 ufficio 办公室 unico 只、仅仅 unita 联合的、团结的 va 去 vanno 去 vecchi 老人 vediamo 我们看到 vicenda 事件、情况 vieni 来 vive 生活 vivere 生活、居住 vivono 生活、居住 voce 声音 volentieri 乐意、甘愿]]></content>
      <categories>
        <category>意大利语学习</category>
      </categories>
      <tags>
        <tag>意大利语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意大利语学习（九）：购物1]]></title>
    <url>%2F2019%2F07%2F02%2F%E6%84%8F%E5%A4%A7%E5%88%A9%E8%AF%AD%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9A%E8%B4%AD%E7%89%A91%2F</url>
    <content type="text"><![CDATA[课文对话1Anna：Allora, chi compra la torta? 那么，谁买蛋糕？ Mario：La compro io. E i CD? 我会买的。CD怎么样？（谁来带？） Anna：Anna：Li portano Carlo e Giuseppe. Ma le candeline per la torta, dove sono? 卡洛和约瑟夫带来了。但是蛋糕蜡烛在哪里？ Mario：Eccole! Va bene? Poi stasera scrivo gli inviti e domani li spedisco, d’accordo? 在这里！可以吗？那我今晚写邀请函，明天发出去，好吗？ Anna：Ma allora, invitiamo anche Giovanna e sua sorella? 但是，我们应该邀请乔瓦娜和她姐姐吗？ Mario：Certo che le invitiamo! Chissà che bel regalo fanno a Gabriella. 当然我们邀请他们！我想知道他们给加布里埃拉的礼物多好。 Anna：Sì, sono ricche, ma sono anche molto avare! 是的，他们很富有，但他们也很贪婪（抠门）！ Anna：Al massimo portano una bottiglia di spumante scadente! 他们最多带一瓶快过期的香槟！ Mario：Ma che dici! Fanno sempre dei bei regali! 你在说什么！他们总是送上好礼物！ Anna：Sarà! Intanto, lo spumante buono lo porto io! 或许吧！同时，我会带来好的香槟！ 对话2Buongiorno signora! 早上好，女士。 Buongiorno! 早上好！ Cosa desidera comprare oggi? 你今天想买什么？ Vorrei delle seppie 我喜欢（想要买）乌贼 Mi dispiace oggi non le abbiamo 对不起，我们今天没有 Però abbiamo i calamari, sono molto freschi 但我们有鱿鱼，它们非常新鲜 No, grazie non li prendo perché non li so cucinare 不，谢谢，我不接受它们，因为我不知道如何烹饪它们 Posso consigliare allora delle cozze da fare gratinate o per gli spaghetti alla marinara? 我可以推荐您买贝类，以制作焗烤或意大利面条吗？ Sì, buona idea le prendo 是的，我认为这是一个好主意 Faccia un chilo abbondante. Poi cosa posso comprare d’altro? 给我称一斤。 那么我还可以买些什么东西呢？ Abbiamo del pesce spada favoloso 我们有很棒的箭鱼 che si può fare alla griglia o alla livornese 可以烤或做成利沃诺风味 Va bene lo prendo 好的，我会接受的 Facciamo mezzo chilo, saranno tre o quattro fette, credo 我想我们制作半公斤，它将是三片或四片 Poi ho le sogliole, ma le ho vendute tutte tranne una 另外我这里还有些鳎鱼，但我把它们全部卖掉只剩一条了 Si può fare impanata. Molto saporito 它可以是面包屑（蘸面包屑）。 非常好吃 Ok! Mi ha convinto la prendo per mio marito 好了！ 你说服了我，我把它买给我的丈夫 e la faccio impanata con una spruzzatura di limone 然后在上面淋点柠檬汁洒上面包屑]]></content>
      <categories>
        <category>意大利语学习</category>
      </categories>
      <tags>
        <tag>意大利语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意大利语学习（八）：你住在哪里]]></title>
    <url>%2F2019%2F07%2F02%2F%E6%84%8F%E5%A4%A7%E5%88%A9%E8%AF%AD%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E4%BD%A0%E4%BD%8F%E5%9C%A8%E5%93%AA%E9%87%8C%2F</url>
    <content type="text"><![CDATA[课文对话1Mario：Come sei bella oggi! 你今天真漂亮！ Anna：Perché? Solo oggi sono bella, e il resto della settimana, sono brutta? 为什么呢？ 只有今天我才漂亮，本周余下的时间，我是丑陋的吗？ Mario：Ma intendo che oggi sei particolarmente bella, ti sei tagliata i capelli, vero? 但我的意思是，今天你特别漂亮，你剪了头发，不是吗？ Anna：Scherzavo… 只是在开玩笑… Anna：Perché ho un appuntamento con il mio fidanzato 因为我跟男朋友约会了 Anna：È un’occasione speciale 这是一个特殊的场合 Mario：Ah, quel bell’uomo, con i suoi belli occhi azzurri? 啊，那个英俊的男人，有着美丽的蓝眼睛？ Mario：Beato lui! Ma da tempo non lo vedo. Come si chiama, a proposito? 祝福他！ 但是我很久没有见过他了。 他叫什么名字？ Anna：Luigi, si chiama Luigi Carruti 路易吉，他的名字是路易吉卡鲁蒂 Mario：Che ne pensi di venire da me questo weekend con lui? 你觉得这个周末和他一起来找我怎么样？ Anna：Ci fa molto piacere passare un po’ di tempo nella tua splendida villa 我们很高兴能在您美丽的别墅中度过一段美好时光 Mario：Grazie del complimento! Ma dai, anche il tuo appartamento è carino 谢谢你的赞美！ 不过，你的公寓也很好 Anna：Magari, però in quel condominio 也许，但在那栋楼里 Anna：il mio appartamentino sembra una vera prigione 我的小公寓看起来像一个真正的监狱 Anna：per non parlare che è anche in affitto! 更不用说它也是出租！ Mario：Ma non esagerare per carità! Allora siamo d’accordo, a che ora venite? 但是不要为了慈善而过火！（你这么讲就太夸张了！） 所以我们同意（说好了），你什么时候来？ Anna：Vengo alle tre, se ti va 我三点去吧，如果你方便的话 Mario：Va benissimo! 当然！ Mario：C’è la partita della Juventus! Non vedo l’ora di parlare di sport con Luigi! 是尤文图斯的比赛！（那会儿有尤文图斯的比赛！） 我迫不及待地想和Luigi一起谈运动！ Anna：L’uomo… Per me, è proprio un mistero, anche il calcio! 男人……对我来说真是个谜，还有足球！ Anna：Altro che passione, è una vera e propria pazzia! Mamma mia! 除了激情，这是一个真正的疯狂！ 妈妈咪！ 段落1Ciao. Io sono Francesca e questa è la mia casa 你好。 我是弗朗西斯卡，这是我的家 Io abito fuori città in una villetta in campagna con mio marito e miei due bambini 我和我的丈夫和两个孩子一起住在乡下的小屋里 Abbiamo una piccola casa a due piani, molto comoda e tranquilla 我们有一个两层楼的小房子，非常舒适安静 Davanti alla casa c’è un piccolo prato verde 房子前面有一个小绿草坪 Dietro alla casa c’è un giardino con i fiori 房子后面有一个种满鲜花的花园 Al pianterreno c’è la cucina, il salotto, la sala da pranzo il mio studio e un bagno 一楼设有厨房，起居室，餐厅，书房和浴室 Ci sono anche le scale che portano al secondo piano 还有通往二楼的楼梯 Il secondo piano è composto da tre camere da letto 二楼包括三间卧室 e un grande balcone dal quale posso ammirare un bel panorama 还有一个大阳台，我可以欣赏到美丽的全景 Abbiamo anche la soffitta nella quale mettiamo le cose vecchie 我们还有阁楼，我们把旧东西放在那里 Uscire! Non ci penso proprio, voglio passare più tempo a casa mia 滚出去！（出门！） 我不这么认为，我想在家里多呆一会儿]]></content>
      <categories>
        <category>意大利语学习</category>
      </categories>
      <tags>
        <tag>意大利语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意大利语学习（七）：我的家（下）]]></title>
    <url>%2F2019%2F07%2F02%2F%E6%84%8F%E5%A4%A7%E5%88%A9%E8%AF%AD%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E6%88%91%E7%9A%84%E5%AE%B6%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[段落段落1Mi chiamo Alberto Sorrentino 我叫Alberto Sorrentino Sono di Napoli, ma lavoro a Roma da molti anni 我来自那不勒斯，但我在罗马工作多年 Sono avvocato 我是个律师 Mia moglie, Luisa, insegna all’Università di Roma 我的妻子路易莎在罗马大学任教 Abbiamo due belle bambine, Giulia e Patrizia 我们有两个漂亮的女孩（女儿），Giulia和Patrizia Patrizia ha cinque anni e ancora non va a scuola Patrizia已经五岁了，仍然没有上学 ma sa già leggere e scrivere 但他已经知道如何阅读和写作 Giulia invece fa la terza elementare 朱莉娅改为（升年纪）三年级 I miei genitori vivono a Napoli 我的父母住在那不勒斯 Mio padre ha 70 anni ed è in pensione 我父亲今年70岁，现已退休 Mia madre è casalinga 我的妈妈是家庭主妇 I miei nonni paterni sono morti 我的祖父母已经死了 la mia nonna materna, invece, vive con i miei genitori 另一方面，我的外婆与我的父母住在一起 Ho anche due sorelle e un fratello 我还有两个姐妹和一个兄弟 La mia sorella più grande, Marisa, è medico 我的姐姐玛丽莎是一名医生 È sposata e ha un figlio di sette anni 她已婚，有一个七岁的儿子 Anche suo marito è avvocato, come me 她的丈夫也像我一样是律师 Io e mio cognato andiamo molto d’accordo 我的姐夫和我相处得很好 Ci conosciamo da quando eravamo bambini 自从我们还是孩子以来，我们彼此认识 Fra tutti i miei parenti, lui è il più simpatico 在我所有的亲戚中，他是最好的 Giovanna, la mia seconda sorella, è divorziata 我的第二个姐姐Giovanna离婚了 È ingegnere e lavora sempre tanto 她是一名工程师，总是努力工作 Io somiglio molto a lei 我看起来很像她 Abbiamo lo stesso carattere e spesso litighiamo 我们有相同的性格，我们经常争吵 Mio fratello Carlo è più piccolo di me 我兄弟卡罗比我小 È un tipo disinvolto, energico e allegro 他是一个休闲，充满活力和快乐的人 Studia lingue e letterature straniere all’Università di Napoli 他在那不勒斯大学学习外语和文学 Studia anche l’inglese, ma non lo sa parlare molto bene 他也学习英语，但不知道如何说得很好 Non ci vediamo molto spesso perché abitiamo lontano 我们不经常看到对方因为我们住得很远 ma siamo una famiglia molto unita 但我们是一个非常亲密的家庭 Ci telefoniamo spesso e ci aiutiamo a vicenda 我们经常互相打电话，互相帮助 段落2Oggi in Italia le famiglie numerose sono molto rare 今天在意大利，大家庭非常罕见 Infatti in Italia la crescita demografica è quasi zero 事实上，在意大利，人口增长几乎为零 Molte coppie oggi decidono di non avere figli o di avere un figlio unico 今天许多夫妇决定不生孩子或独生子女 per ragioni economiche e di lavoro 出于经济和工作原因 anche perché le donne italiane lavorano sempre più spesso fuori casa 也是因为意大利女性越来越多地在家外工作 Ancora, però, come in passato, i figli sposati spesso vivono vicino ai genitori 然而，与过去一样，已婚子女往往与父母亲近 e i nonni passano molto tempo con i nipoti 祖父母和孙子孙女一起度过了很多时光 particolarmente quando i genitori lavorano 特别是父母的工作（忙的时候） I figli adulti assistono i genitori quando sono vecchi o non stanno bene 成年子女在年老或不适时帮助父母 Spesso i genitori anziani vanno a vivere con i figli 年长的父母通常会和孩子一起生活 Oggi molte cose stanno cambiando anche nella struttura familiare italiana 今天，即使在意大利家庭结构中，许多事情也在变化 da molti anni c’è il divorzio e nuovi nuclei familiari si formano più facilmente che in passato 已经有很多年了，离婚、新家庭比过去更容易形成 la famiglia però occupa sempre un posto importante nella società italiana 然而，这个家庭在意大利社会中一直占有重要地位]]></content>
      <categories>
        <category>意大利语学习</category>
      </categories>
      <tags>
        <tag>意大利语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意大利语学习（三.5）：数字与星期几]]></title>
    <url>%2F2019%2F07%2F02%2F%E6%84%8F%E5%A4%A7%E5%88%A9%E8%AF%AD%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89-5%EF%BC%89%EF%BC%9A%E6%95%B0%E5%AD%97%E4%B8%8E%E6%98%9F%E6%9C%9F%E5%87%A0%2F</url>
    <content type="text"><![CDATA[数字 1 uno 2 due 3 tre 4 quattro 5 cinque 6 sei 7 sette 8 otto 9 nove 10 dieci 11 undici 12 dodici 13 tredici 14 quattordici 15 quindici 16 sedici 17 diciassette 18 diciotto 19 diciannove 20 venti 21 ventuno 22 ventidue 23 ventitré 24 ventiquattro 星期几 周1 lunedì 周2 marterdì 周3 mercoledì 周4 giovedì 周5 venerdì 周6 sabato 周7 domenica]]></content>
      <categories>
        <category>意大利语学习</category>
      </categories>
      <tags>
        <tag>意大利语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意大利语学习（六）：你上课的时候做些什么]]></title>
    <url>%2F2019%2F07%2F02%2F%E6%84%8F%E5%A4%A7%E5%88%A9%E8%AF%AD%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E4%BD%A0%E4%B8%8A%E8%AF%BE%E7%9A%84%E6%97%B6%E5%80%99%E5%81%9A%E4%BA%9B%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[对话对话1Mario：Uffa! Ho tanto da raccontare alla mia famiglia 嗨呀！我有很多要告诉我的家人 Mario：ma quando mi chiamano, io dormo 但是当他们打电话给我时，我睡觉 Mario：e quando posso chiamarli, loro sono in ufficio 当我打电话给他们时，他们在办公室 Anna：Perché non scrivi un’email? 你为什么不写电子邮件？ Mario：Hai ragione! È più conveniente! C’è un Internet bar qui vicino? 你是对的！ 它更方便！ 附近有网吧吗？ Anna：Certo! È proprio accanto alla caffetteria 当然！ 就在咖啡厅旁边 Mario：La caffetteria ll Greco? 是ll greco咖啡厅么？ Anna：Esatto 正是 Mario：Perfetto! Vieni con me? Prendiamo un caffè! 完美！ 你跟我一起去吗？ 我们来喝杯咖啡！ Anna：Ottima idea! A proposito. Come va il tuo studio di recente? Tutto a posto? 好主意！ 顺便说一下。 你的学习最近怎么样？ 一切都到位了么？ Mario：Il cinese non è mica facile. Io studio solo da un mese 中文并不容易。 我只学了一个月 Anna：Non mi ricordo dove studi, all’Università La Sapienza? 我不记得我在哪里学习,在La Sapienza大学？ Mario：Sì, ma non alla città universitaria 是的，但不是大学城 Mario：È un corso linguistico alla facoltà degli studi orientali 这是东方研究学院的语言课程 Anna：Allora abiti vicino a via Principe Amadeo? 你也住在Principe Amedeo路附近吗？ Mario：Purtroppo no, le case al Vittoriano costano troppo 不幸的是，Vittoriano的房子太贵了 Mario：Abito vicino al Ponte Mammolo 我在Ponte Mammolo附近居住 Mario：Prendo la metro linea B per arrivare alla scuola 我乘坐地铁B线去学校 Anna：Ho capito. I professori, come sono? Sono bravi? 我明白了。 教授们，他们怎么样？ 他们好吗？ Mario：Certo. Insegnano molto bene 当然。 他们教得很好 Mario：Ogni mattina, arrive all’aula molto presto 每天早上,很快到达教室 Mario：e leggo ad alta voce il testo 然后大声朗读课文 Mario：Durante la lezione, ascolto attentamente la spiegazione grammaticale 在课程中，我仔细聆听语法解释 Mario：prendo gli appunti, e partecipo attivamente alla discussione 我做笔记，并积极参与讨论 Mario：Dopo la lezione, faccio seriamente gli esercizi 课后，我认真地做练习 Anna：Bravo! Sono convinta che sei uno dei migliori studenti della classe! 好样的！ 我相信你是班上最好的学生之一！ Mario：Speriamo! Faccio tutto il possibile per migliorare la mia lingua 但愿！ 我尽我所能来改善我的语言 Mario：Come dice il proverbio, chi cerca, trova! 俗话说，那些寻求，找到！（有志者事竟成） Anna：Avete il lettore cinese, immagino? 你们中有中国读者，对吗？ Mario：Si, c’è una lettrice cinese molto giovane, ha solo 24 anni 是的，有一个非常年轻的中国读者，她才24岁 Mario：Lei parla perfettamente italiano 她讲完美的意大利语 Mario：Quando incontro difficoltà 当我遇到困难时 Mario：chiedo spesso il suo aiuto nello studio, e mi aiuta volentieri 我经常在研究中寻求她的帮助，她心甘情愿地帮助我 对话2Quanti anni hai？ 你年纪多大了？ Ho 20 anni 我20岁 Ne ho 20 我有20 Quanti anni ha il ragazzo di Olivia? Olivia的男朋友多大年纪？ Non lo so. Sembra un trentenne 我不知道。大概30岁了 Quanti anni ha il tuo professore 你们老师多大年纪？ Ha 30 anni. È molto giovane. Ma ne dimostra di più 他今年30岁。 他很年轻。 但它显示更多（看起来更老） Quanti anni ha tua sorella? 你妹妹多大年纪？ Ne ha solo 12. Ma ne dimostra di meno 她只有12岁。但是表现得更少（看起来更小一点）]]></content>
      <categories>
        <category>意大利语学习</category>
      </categories>
      <tags>
        <tag>意大利语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意大利语学习（五）：我的家（中）]]></title>
    <url>%2F2019%2F07%2F01%2F%E6%84%8F%E5%A4%A7%E5%88%A9%E8%AF%AD%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%88%91%E7%9A%84%E5%AE%B6%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[对话对话1Cristina：Ciao Alessandro, come va? 你好Alessandro！最近怎么样？ Alessandro：Oh, ciao Cristina, bene, grazie, e tu? 哦，Cristina你好，我们好，你呢？ Cristina：Al solito. Senti, domenica organizzo una festa a casa mia. Vieni? 我还是老样子。周日我要在家组织个小聚会。你来吗？ Alessandro：Domenica sera… Certo! Solo che non so dove abiti 周日晚上，当然！不过我还不知道你住在哪儿呢 Cristina：In via Nomentana, 891 我住在Nomentana路，891号 Alessandro：Via Nomentana, 891, dov’è? Nomentana路，891号，那是哪儿？ Alessandro：In centro, vicino al Colosseo? 是在市中心，离斗兽场很近？ Cristina：Oh dio no, la Via Nomentana è lunghissima 欧上帝不是的，Nomentana路特别长 Cristina：Abito alla periferia, vicino al Largo Pugliese 我住在郊区，离Pugliese湖很近 Cristina：Se vieni in autobus, prendi il 341 你要是做公交车的话，就坐341路 Alessandro：Ah, ok, il 341. Ma è una casa o un appartamento? 好的，341路。你住的是大房子还是公寓 Cristina：Un appartamento al sesto piano 公寓，6楼 Alessandro：Con ascensore, spero! 用电梯的，希望是！ Cristina：Certo, tranquillo! È un palazzo moderno! 当然啦，放心吧！这是一个现代化的公寓 Alessandro：Com’è questo appartamento? 这个公寓是什么样子的？ Cristina：Non troppo grande, ma direi molto luminoso 不算很大，不过采光很好 Cristina：Il balcone da su un giardino bellissimo 阳台正对着一个非常美的花园 Alessandro：Una bella vista! Beata te! 视野一定很好！你真幸福！ Alessandro：Anch’io penso di cambiare l’appartamento 我也想着换房子呢 Alessandro：Casa mia è troppo piccola. Pago 600 euro d’affitto 我的房子太小了。而且每个月租金要600欧 Alessandro：Tu paghi molto? 你的房租多吗？ Cristina：550 euro al mese 550欧每月 Cristina：Il palazzo è nuovo e l’appartamento è ben ammobiliato perciò ne vale la pena 因为房子是挺新的，而且公寓是精装修的所以还是挺值的 Cristina：Allora, siamo intesi, domenica sera? 好啦，我们说定了，周日晚上见？ Alessandro：D’accordo! Ci vediamo domenica! 好吧！周日见！ 短文1Le città italiane sono quasi tutte molto antiche 意大利的城市基本上都很古老 e sono costruite intorno a un centro storico che 它们都是围着一个老城区建成的 mantiene in moltissimi casi 在大部分情况下 la vecchia struttura medievale o rinascimentale （这个历史城区保存着）中世纪或者文艺复兴时期的古老建筑 Nei centri storici di molte città 在许多城市的历史中心 sono ancora tante le case costruite negli ultimi secoli 有许多在过去的几个世纪里建成的房子 e che sono ancora abitate 仍然有人居住 Le città si sono sviluppate soprattutto nel secolo scorso 这些城市特别是在上个世纪发展起来的 quando a causa della forte industrializzazione 当时由于强大的工业化 le persone hanno cominciato a lasciare le campagne e a trasferirsi in città 人们开始离开农村，搬到城里 Sono così nate abitazioni sempre più moderne 因此，越来越多的现代住宅诞生了 Si tratta di palazzi con molti piani e tanti appartamenti 这些住房通常是高层建筑，里面有许多公寓 Il palazzo moderno è chiamato anche condominio 现代建筑也被称为共管公寓 Questa parola indica che la proprietà dell’edificio 这个词表示建筑物的所有权 è divisa tra gli abitanti degli appartamenti 在公寓的居民之间分配]]></content>
      <categories>
        <category>意大利语学习</category>
      </categories>
      <tags>
        <tag>意大利语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意大利语学习（四）：我的家（上）]]></title>
    <url>%2F2019%2F07%2F01%2F%E6%84%8F%E5%A4%A7%E5%88%A9%E8%AF%AD%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%88%91%E7%9A%84%E5%AE%B6%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[对话对话1Anna：Che bella foto, Mario! È la tua famiglia? 这张照片真好看，Mario！这是你的家人吗？ Mario：Sì, la mia è una famiglia abbastanza numerosa 是的，我家里人挺多的 Anna：In quanti siete? 你们有几口人？ Mario：Siamo in cinque. Mio padre, mia madre, mio fratello, mia sorella, ed io 有五个。我爸爸，我妈妈，我哥哥，我妹妹，和我 Anna：Tuo padre, che lavoro fa? È un professore? 你爸爸是做什么工作的？是老师么？ Mario：No. È un ingegnere. Lavora in una fabbrica 不。他是个工程师。在工厂上班 Anna：Anche tua madre lavora? 你妈妈呢？也工作么？ Mario：Non, è già pensionata 不，他已经退休了 Anna：Questa la tua sorellina? È davvero carina! 这是你的妹妹？她真可爱！ Mario：Grazie. Si chiama Federica, frequenta ancora il liceo 谢谢！她叫Federica。还在上高中 Anna：Tuo fratello invece? 那你的哥哥呢？ Mario：Mio fratello si è laureato 4 anni fa in giurisprudenza. Ora fa il giornalista 我哥哥四年前就从法律专业毕业了。他现在是一名记者 Anna：È molto fortunato! 真幸运！ Mario：Direi! Lavora molto, e guadagna di più! 那可不！他工作很多，赚的更多！ 段落1Ciao, mi chiamo Stefano. 你好，我叫Stefano La mia famiglia ed io abitiamo in città in una casa piccola ma comoda 我的家人和我住在城里，房子很小，但是很舒适 Mio padre lavora in banca e mia madre è casalinga 我的爸爸在银行工作，我的妈妈是一个家庭主妇 Ho una sorella ed un fratello più grandi di me: 我有一个姐姐，还有一个哥哥： mia sorella ha 23 (ventitré) anni e mio fratello 19 (diciannove) 我的姐姐今年23岁，我的哥哥今年19岁 Tutti e due studiano all’università 他们俩都在大学读书 La mattina, dopo colazione, andiamo tutti a studiare 每天早上，吃过早饭，我们就都去上课 La domenica stiamo insieme ai miei zii e ai loro figli 周日我们会和我们的叔叔们和他们的孩子们在一起 Cioè i miei cugini 我的堂弟们 che abitano insieme al nonno in una grande casa in campagna 和爷爷一起住在乡下的一个大房子 Non vedo l’ora di andare al lago a pescare con mio nonno 我迫不及待要和我爷爷一起去湖边钓鱼 O fare anche una lunga passeggiata con mio cugino Pietro e la mia cugina Caterina 或者是和我的表哥Pietro还有我的表妹Caterina一起散步 Mio nonno dice che la casa è più bella quando ci sono i suoi nipoti 我爷爷说，自己的孙子们来了，家就更美好了 Io dico invece, che è bella perché la mia cara nonna prepara dei dolci buonissimi! 不过我却觉得，因为我亲爱的奶奶会给我们做特别好吃的甜点，所以家才更美好！]]></content>
      <categories>
        <category>意大利语学习</category>
      </categories>
      <tags>
        <tag>意大利语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意大利语学习（三）：现在几点了]]></title>
    <url>%2F2019%2F07%2F01%2F%E6%84%8F%E5%A4%A7%E5%88%A9%E8%AF%AD%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%8E%B0%E5%9C%A8%E5%87%A0%E7%82%B9%E4%BA%86%2F</url>
    <content type="text"><![CDATA[对话对话1Francesca：Ciao Marco, scusami, sono in ritardo. C’è un traffico tremendo 你好Marco，不好意思，我来晚了。今天实在是太堵了 Marco：Ciao Francesca, tranquilla 你好Francesca，没关系 Francesca：Oggi è sabato, ci sono troppe foto in circolazione 今天是周六，路上车会很多 Francesca：Il mio orologio non funziona. Sai dirmi che ora è? 我的手表坏了。你知道现在几点了吗？ Marco：Aspetta, il mio è indietro di 5 minuti, quindi sono le quante e un quarto 稍等啊，我的手表大概晚5分钟，那么现在是4点一刻 Francesca：A che ora comincia il film? 电影几点开始？ Marco：Il film comincia alle 5, c’è ancora tempo per un caffè！ 电影5点开始。我们还有时间喝杯咖啡呢！ Francesca：Meno male! Ci vorrebbe proprio un caffè! Vieni con me？ 不错！我现在正需要一杯咖啡！走，咱们一起去？ Marco：Volentieri! 好呀！ 对话2Marco：Scusi, buongiorno, mi potrebbe dire che ore sono? 不好意思，你好，您能告诉我现在几点了吗？ Francesca：Certo, è l’una meno un quarto 当然，现在1点差一刻 Marco：A che ora arriva il prossimo treno da Firenze? 下一班从佛罗伦萨来的火车几点到呢？ Francesca：Alle 14:45 14:45到 Marco：E a che ora parte l’intercity per Milano? 前往米兰的城际列车几点发车？ Francesca：Alle 16:30, si ricordi che la biglietteria chiude alle 2 16：30发车。还有，您记着，售票处中午2点关门 Marco：È aperta poi il pomeriggio? 下午还开吗？ Francesca：Penso di sì, credo dalle tre alle cinque 应该会开，没记错的话是从三点开到五点 Marco：Grazie mille, molto gentile! 非常感谢，你真好！ Francesca：Prego, buon viaggio! 不用谢，旅途愉快！ 问时间Che ore sono? 现在几点？ È l’una 现在一点 È l’una e mezzo/mezza 现在一点半 Sono le due in punto 现在两点整 Sono le due precise 现在两点整 È mezzogiorno 现在正午十二点 È mezzanotte 现在半夜十二点 Sono le due e cinque 现在两点五分 Sono le quattro e un quarto 现在四点一刻 Sono le sette e mezzo/mezza 现在七点半 Sono le cinque e quarantacinque 现在五点四十五 Sono le cinque e tre quarti 现在五点三刻 Sono le sei meno un quarto 现在差一刻六点 Sono le dieci e cinquanta 现在十点五十 Sono le undici meno dieci 现在十一点差十分 Mancano dieci minuti alle undici 差十分钟十一点 Sono circa le cinque 现在大约五点 Sono intorno alle quattro 现在四点左右 Sono verso le undici 现在快十一点了]]></content>
      <categories>
        <category>意大利语学习</category>
      </categories>
      <tags>
        <tag>意大利语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意大利语学习（二）：Un nuovo inizio一个新的开端]]></title>
    <url>%2F2019%2F07%2F01%2F%E6%84%8F%E5%A4%A7%E5%88%A9%E8%AF%AD%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AUn-nuovo-inizio%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%BC%80%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[对话Mario：Ciao Anna, Che sorpresa rivederti in Italia! Anna你好！在意大利见到你真高兴 Mario：Da tanto tempo non ci vediamo! 我们好久不见了！ Anna：Ciao Mario, e’ una sorpresa anche per me! Mario你好！我也很高兴！ Mario：Ma perche’ sei in Italia？ 你怎么会来意大利的？ Anna：Per frequentare il corso di specializzazione all’università’ di Padova 为了来帕多瓦大学上研究生课程 Mario：Sei proprio forte! 你真行 Mario：In bocca al lupo per i tuoi studi！ 祝你学习一切顺利 Anna：Grazie! E’ proprio un nuovo inizio per me! 感谢！对我来说，这的确是一个新的开始！ Mario：Come sono i tuoi compagni di classe 你的同学们怎么样 Mario：E In quanti siese？ 你们一个班多少人？ Anna：Nella mia classe ci sono una ventina di studenti, provenienti da diversi paesi del mondo 在我们班上有二十来个人，他们来自世界的不同国家 Anna：Sono simpatici e molto gentili 人都很好，很友善 Mario：E I tuoi professori? Sono tutti italiani? 你的老师们呢？他们都是意大利人么？ Anna：Si, sono tutti italiani 是的，他们都是意大利人 Anna：E una professoressa parla il cinese 而且有个女老师还会说汉语 Mario：Allora non hai difficolta’ nello studio 那么我估计你在学习上应该就没有什么困难了 Anna：Beh, a dire la verità, all’inizio si’ 哎，说实话，在一开始的时候还是有点难的 Anna：Pensa che di solito abbiamo 4 ore di lezione al giorno 你想想看，我们平时每天都有4节课 Che cosa è questo? Questo è …Anna：Che cosa è questo? È un panino? 这是什么？是面包么？ Mario：No, questo non è un panino, è una pizza 不，这不是面包，这是披萨 Anna：Che cosa è questa? È una penna? 这是什么？是钢笔吗？ Mario：No, questa non è una penna, è una matita 不，这不是钢笔，是铅笔 Anna：Che cosa è questo? È uno zaino? 这是什么？是背包么？ Mario：No, questo non è uno zaino, è una borsa 不，这不是背包，是挎包 Anna：Cosa è questa? È una poltrona? 这是什么？是扶手椅么？ Mario：No, questa non è uno poltrona. È un divano 不，这不是扶手椅，这是一个长沙发 Anna：Quelli sono dei quaderni? 那些是笔记本吗？ Mario：Sono delle sedie 那些是椅子 Anna：Che cosa sono quelli? 那些是什么？ Mario：Quelli sono dei quaderni 那些是笔记本 Cosa c’ e’ … / C’ e’ …Mario：Chi è quel ragazzo? 那个男孩是谁？ Anna：È uno studente italiano. 他是一个意大利学生 Mario：Chi è questa signora? 那位女士是谁？ Anna：È la professoressa d’italiano 她是位意大利语老师 Mario：Chi sono quei ragazzi? 那些男生是谁？ Anna：Sono gli studenti del primo anno 他们是一年级学生 Mario：Cosa c’e’ sul banco? 桌子上有什么？ Anna：C’e’ un dizionario 桌子上有一本字典 Mario：Cosa c’e’ nell’armadio? 衣橱里有什么？ Anna：Ci sono vestiti e cappelli 衣橱里有一些衣服和帽子 Mario：Che cosa c’e’ sullo scaffale? 书架上有什么？ Anna：Ci sono dei libri 书架上有一些书 Mario：Che cosa c’e’ nella tua borsa? 你的书包里有什么？ Anna：C’e’ un dizionario 有一本字典 Mario：Ci sono due porte e due finestre nella camera？ 房间里有两扇门，两扇窗么？ Anna：No, ci sono solo una porta e una finestra 不，只有一扇门，一扇窗]]></content>
      <categories>
        <category>意大利语学习</category>
      </categories>
      <tags>
        <tag>意大利语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[意大利语学习（一）：简单的问候]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%84%8F%E5%A4%A7%E5%88%A9%E8%AF%AD%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%AE%80%E5%8D%95%E7%9A%84%E9%97%AE%E5%80%99%2F</url>
    <content type="text"><![CDATA[对话对话1Anna：Buongiorno Professore! 老师您好！ Anna：Mi chiamo Anna. Anna Marchi 我叫Anna。Anna Marchi Anna：Sono una studentessa italiana 我是一名意大利女学生 Professore：Buongiorno Anna 你好，Anna Professore：Io sono il tuo professore di cinese 我是你们的中文老师 Professore：Benvenuto alla nostra facoltà’ 欢迎来到我们学院 对话2Teresa：Molto piacere. Sono Teresa 很高兴认识你。我是Teresa Teresa：Sei nuovo qui？ 你是新生吗？ Mario：Si. Sono del primo anno 是的。我今年一年级 Teresa：Qual’e’ il tuo nome e qual’e’ il tuo cognome？你的姓和名分别是什么？ Mario：Il mio nome e’ Mario 我的名字是Mario Mario：E Rossi e’ il mio cognome 姓Rossi Teresa：E la tua ragazza？ 你的女朋友呢？ Mario：Si chiama Roberta, e’ cinese di Shanghai 她叫Roberta，她是中国人，来自上海 Mario：Parla pochissimo italiano 不过她只会说一点点意大利语 Mario：Pensa che sia una lingua difficile 她觉得意大利语非常难 Teresa：Pazienza！耐心点吧 Teresa：Chi ben comincia e’ già’ alla meta’ dell’opera 好的开始是成功的一半 打招呼用语Ciao 打招呼，你好/再见 Buongiorno 你好，正式/一般场合 Buon pomeriggio 下午好，比较正式 Buonasera 晚上好 Buonasera! Benvenuto al nostro corso d’italiano! 晚上好！欢迎参加意大利语课程！ Salve! 你好！不分场合 Buonanotte 晚安（用于告别） Buona serata 晚上再见 Buonanotte e sogni d’oro 晚安，做个好梦 Arrivederci 再见 Ci vediamo 回头见 Ci sentiamo 回头电话联系]]></content>
      <categories>
        <category>意大利语学习</category>
      </categories>
      <tags>
        <tag>意大利语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代服务业：昨天、今天、明天]]></title>
    <url>%2F2019%2F06%2F23%2F%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E3%80%81%E6%9C%8D%E5%8A%A1%E4%B8%9A%E3%80%81%E7%8E%B0%E4%BB%A3%E6%9C%8D%E5%8A%A1%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[昨天：传统服务及传统服务业传统服务的定义具有无形特征却可以给人带来某种利益或满足感的一种(一系列)交互行为及其过程 传统服务的特性服务的特性（Edward Livingston Trudeau, 1848 – 1915）： To cure sometimes To relieve often To comfort always 传统服务业定义提供服务的行业，包括是国民经济中在流通、生产生活、科学文化教育、社会公共需求等领域提供各种服务产品的部门或行业 传统服务业在各个产业中的体现 第一产业（农林牧副渔等）：产品直接取自自然界的部门(300$/人)，主要指农业（农、林、牧、渔 ），是国民经济的基础 农业种植业包括育种、播种、灌溉、施肥、除草、土壤改造、病虫防治、收割、分拣、运输、储存等 第二产业（包括制造和采掘业等）：对初级产品进行再加工部门，工业 (800$/人) （采掘、制造、自来水、电力蒸汽热水、煤气和建筑） 制造业的生产运营包括研发、设计、品牌、制造、物流配送、渠道控制和销售服务等七个主要环节，其中除制造外的六个环节都是服务；从产业价值链角度来看，这些服务环节创造的附加价值往往远高于制造加工环节的产品价值 采掘业包括勘探、采掘、分拣、运输、提炼/加工、储存等，主要环节也是服务 三次产业：一、二产业之外，为生产和消费提供各种服务的部门(1500$/人) 20世纪30年代 ，英国经济学家AG Fisher在《安全与进步的冲突》一书中提出“第三产业”的概念 产业融合产业交叉及其跨界发展，如：农业+物联网+互联网，服务型制造 今天：现代服务业现代服务定义现代服务（线上服务，新服务）是以协同创造、获取价值为目标，服务提供商(SP)与顾客(C)之间的交互行为及其过程 服务的要素 价值共创： SP与C共同参与创造过程与结果 不仅包括经济价值，还可能包括非经济的目标 经济价值测度方法也与工业经济有差别(完全市场交易vs拍卖？) 服务关系:不仅包括SP与C之间关系，往往不是二元关系 服务供给：有效的服务供给永远是短缺的（例如，考虑客户需求反应的时间性等） 现代服务业的特征 服务系统化 系统指服务流程、服务供应链，更多的是服务生态系统。服务系统中顾客、信息主体、资源主体和环境等参与要素间形成动态的关联 服务系统具有明显的开放性特征 服务关系化 服务系统包括多元化价值主体，不仅仅包括盈利组织和目标 主体间广泛的连接形成关系，多种关系尤其是客户/潜在客户之间及其与服务提供者之间关系对客户行为和服务价值的影响大 服务交互与接触方式的数量大大增加且可以动态切换，各种社交媒体的综合应用等使得客户的选择与决策产生相互影响 关系可跨越时空限制，现代服务通常在较大地理空间内动态进行 资源整合化 服务资源概念发生变化；显著依赖于专门领域的专业知识 产品只是服务交付的载体，服务是生产的最终目的-&gt;制造服务化 强调社会服务资源协同地满足社会服务需求，而不是单个企业孤立地满足若干细分市场的需求 现代服务业分类 基础服务：通信和信息服务 生产和市场服务：创意、研发、设计、金融、物流、电子商务、咨询、农业支撑及中介和咨询 个人消费服务：教育、医疗保健、住宿、餐饮、文化娱乐、旅游、房地产及商品零售 公共服务：政府的公共管理服务、基础教育、公共卫生、医疗及公益性信息服务 现代服务业在各个领域内应用智能电网电力生产传输-&gt;用能的效用 建立在集成的高速双向通信网络基础之上，利用传感器对发电、输电、配电、供电等关键设备（能力）的运行状况进行实时监控，然后综合能力与需求信息，对电力系统运行进行优化管理 智能医疗专业服务-&gt;围绕患者的个性化集成服务 智能医疗是以患者为本的网络化服务系统，利用ICT技术实现服务创新、资源共享，和医疗服务能力与需求的动态匹配，以改善疾病预防、诊断和治疗。 智能出行（携程旅行网）专业服务-&gt;现代旅游资源集成服务 现代旅行服务业,创立于1999年，总部设在上海，目前已在北京、广州、深圳、成都、杭州、厦门、青岛、南京、武汉、沈阳等10个城市设立分公司，员工近7000人;作为中国领先的在线旅行服务公司，携程旅行网成功整合了高科技产业与传统旅行业，向超过1800万会员提供集酒店预订、机票预订、度假预订、商旅管理、特约商户及旅游资讯在内的全方位旅行服务，被誉为互联网和传统旅游无缝结合的典范;凭借稳定的业务发展和优异的盈利能力，Ctrip于2003年12月在美国纳斯达克成功上市。 酒店预订 拥有中国领先的酒店预订服务中心，为会员提供即时预订服务 合作酒店超过28000家，遍布全球134个国家和地区的5900余个城市 不仅为会员提供优惠房价预订，在主要酒店拥有大量保留房，为会员出行提供保障 机票预订 拥有全国联网的机票预订、配送和各大机场的现场服务系统，为会员提供国际和国内机票的查询预订服务 机票预订覆盖各大航空公司的绝大多数航线，实现国内48个城市市内免费送票，实现异地机票，本地预订、异地取送 度假预订 为会员提供自由行、海外团队游、半自助游、自驾游、签证、自由行PASS、代驾租车等多种度假产品 依托充足的行业资源，提供丰富多样的酒店、航班、轮船、火车、专线巴士等搭配完善的配套服务 摈弃传统团队走马观花的形式，以合理的行程安排和深入的旅行体验为特色 商旅管理 面向国内外各大企业与集团，以提升企业整体商旅管理水平与资源整合能力为服务宗旨 资源共享服务资源所有-&gt;资源所用 Gig Economy：An environment in which temporary positions are common and organizations contract with independent workers for short-term engagements, on demand. McKinsey’s taxonomy (2016): 1. Free agents (自由职业者): those who actively choose independent work and derive their primary income from independent work 2. Casual earners (偶尔赚外快者): those who use independent work for supplemental income, and do so by choice 3. Reluctant(无法取得固定岗位者): those who make their primary living from independent work, but would prefer traditional jobs 4. Financially strapped(财务困难赚外快者): those who do supplemental independent work out of necessity Sharing Economy：The coordination of exchanges between individuals as would a traditional market, but in a flexible, self-governing, and potentially revolutionary way明天：服务科学服务科学的概念是2002年IBM的Almaden 研究中心与UC Berkely 大学组成的合作研究团队首次提出的；2005年IBM正式提出服务科学管理和工程（SSME）的概念，认为服务科学是科学、工程和管理三个维度的结合。 服务运作管理：主要来源于生产运作管理，包括商业模式分析、服务流程分析、服务排程与决策优化、服务质量管理和收益管理等 服务营销：提出了服务行为、服务包的概念和服务主导逻辑 服务计算：从面向对象和面向构件的计算演化而来的一种分布式计算模式，通过分布在企业内部或者跨企业边界的不同商业应用系统实现快捷、灵活的无缝集成与相互协作，实现消除商业服务和信息技术服务之间鸿沟的目的 国内外部分研究机构、刊物 浙江大学 服务科学研究中心、电子服务研究中心 台湾清华大学 服务科学研究所 http://www.iss.nthu.edu.tw/ Service Science, IBM Research, http://researcher.watson.ibm.com/researcher/view_group.php?id=1230 University of Tokyo, Service Innovation Working Group http://www.ducr.u-tokyo.ac.jp/en/2006service_innovation/index.html Arizona State University, the Center for Services Leadership (CSL), https://wpcarey.asu.edu/research/services-leadership Carnegie Mellon University, IT Services Qualification Center (ITSQC) http://www.itsqc.cs.cmu.edu/ Georgia Institute of Technology, Tennenbaum Institute http://www.ti.gatech.edu/ Ohio State University, Fisher College of Business, Initiative for Managing Services http://fisher.osu.edu/centers/ims Stanford University, Center for Work, Technology &amp; Organization (WTO) http://web.stanford.edu/group/wto/cgi-bin/wp/ University of Maryland, Center for Excellence in Service http://www.rhsmith.umd.edu/centers-excellence/center-excellence-service University of Pennsylvania, Wharton Business School, Fishman-Davidson Center for Service and Operations Management http://opim.wharton.upenn.edu/fd/ Service Science (INFORMS journal) http://pubsonline.informs.org/journal/serv IEEE Transactions on Service Computing http://www.computer.org/portal/web/tsc Service Oriented Computing and Applications http://www.springer.com/computer/communication+ networks/journal/11761 IEEE Transactions on Network and Service Management http://www.comsoc.org/tnsm Journal of Service Research http://jsr.sagepub.com 服务科学和管理 http://www.hanspub.org/journal/ssem/ 服务科学的特征 自然科学特征 实践工具、部分研究问题 强调量化、可重复 依靠实验 社会科学特征 实践目标、部分研究问题 强调客户参与、体验 依靠假设-&gt;分析验证、仿真、情境分析/决策支持 研究趋势传感与接入 传感与接入：感知对象（人或物）的状态，将状态参数转换为可存储、可传输数据，并将数据接入到可共享的系统中，如：传感器、智能穿戴、移动定位设备等 物联网又名传感网，指将各种信息传感设备与互联网结合起来而形成一个物物相联的网络以进行识别和管理 智能穿戴在2013年逐渐成为热词；目前的技术路径 基于通讯的智能穿戴产品，以三星等传统通讯企业为代表 基于定位、运动娱乐智能穿戴产品，以耐克等传统运动娱乐企业为代表 基于眼镜类的虚拟现实或沉浸式的智能穿戴产品，以谷歌眼镜为代表 基于血压、心率、血糖、新陈代谢等监测可穿戴设备，以移动医疗为主 移动定位设备：主要用于基于位置的服务（如位置获取基础上的导航、交友、紧急呼叫、周边服务搜索等服务) 天网工程 智能交通中卡口与收费站等各种视频采集设备 万物互联物物互联 云计算：网络连接起来的浩大数据、计算、服务、设施资源进行统一管理、协调，形成一个内容丰富、能量强大的资源服务体系，按社会和用户需求进行分配提供；云计算=计算与存储资源的分布式存在与互联整合 车联网：指装载在车辆上的电子标签通过无线射频等识别技术，实现在信息网络平合上对车辆的属性信息和静动态信息进行提取和有效利用，对车辆运行状态进行有效的监管和提供综合服务 M2M：M2M是将数据从一台终端传送到另一台终端，也就是机器与机器的对话。三一重工在其销往全球的工程机械(关键部件)上加装数据采集终端,机械的运行数据通过网络汇总到三一集团ECC(Enterprise Control Center), ECC随时发现设备运行中存在的问题,智能设备控制器检测的油温、转速、工作压力等运行数据通过通信网络实时发送至ECC，一旦发现异常情况，ECC立即指导客户排除故障或派出维修人员上门服务 智能电网（Smart Grid, SG）, 又叫互动电网，是建立在集成的高速双向通信网络基础之上，利用传感器对发电、输电、配电、供电等关键设备（能力）的运行状况进行实时监控，然后综合能力与需求信息，对电力系统运行进行优化管理 人人互联 电话：仍是人际沟通与联系的主要工具；但IT发展改变了电话的形式与内涵 (固定电话-&gt;移动电话-&gt;网络电话) 社交媒体(Social Media)指借助允许人们撰写、分享、评价、讨论、相互沟通的网站和技术，实现人们彼此之间用来分享意见、见解、经验和观点的工具和平台。现阶段主要包括微信(2011), Mini-Blog(2007), Google+(2011)，手机QQ(2003), Facebook(2004), Twitter(2006), Blog(2002-2005), Email(1987/1998)等 UGC（User Generated Content）：指用户原创内容，是伴随着以提倡个性化为主要特点的Web2.0概念而兴起的。它并不是某一种具体的业务，而是一种用户使用互联网的新方式，即由原来的以下载为主变成下载和上传并重，如视频分享，直播，照片分享，知识分享，社区论坛等 大型开放式网络课程，即MOOC ，是信息技术、网络技术与优质教育的结合，通过这个平台将教育资源送到世界的各个角落。具有工具资源多元化、课程易于使用、课程受众面广、课程参与自主性的特点 创客空间。创客指不以盈利为目标,出于兴趣与爱好，努力把各种创意转变为现实的人 人物互联 智能家居(smart home, home automation)是在互联网影响之下物联化的体现。它以住宅为平台，通过物联网技术将家居生活有关的设施集成，提供控制、遥控、报警、监测、以及定时等多种功能和手段 服务机器人：在非结构环境下为人类提供必要服务的多种高技术集成的智能化装备。IR工作环境已知，SR工作环境绝大多数未知 面向个人与社会群体的数字化 面向个人与社会群体数据爆发式增长的推手：硬件成本的降低，网络带宽的提升，云计算的兴起，网络技术的发展，智能终端的普及，电子商务、社交网络和电子地图等的全面应用，物联网 近几年（2009年以后)数字化表现的主要特征与趋势 以服务为主，大多采用平台模式 数字资源系统开放 虚拟空间与物理空间融合 互联网大数据时代及其直接影响 大数据的概念是2008年提出的；因为政治经济的发展需要和媒体宣传，使人们认识到大数据技术对个人、社会和国家重要而深刻的影响，因此认为我们正在进入大数据时代 数据与数据技术对社会和人们生活产生重要影响的事，主要发生在近几年：从传感与接入、互联和面向个人与群体的数字化三个维度看，这些事主要发生在十年左右 面向个人与群体的数字化的直接影响 数据的爆炸式增长（数字化主体的爆炸式增长），服务科学化成为可能 生产过程与消费过程的融合，导致人类社会从工业社会进入信息社会，从制造经济进入服务经济 个人(用户)在生产、消费等活动中的主体地位将日益得到明确与体现，不断形成新的服务产品和服务模式 大数据推动服务研究科学化 客户体验的测量 客户个体特征的识别 新型服务关系发现 服务价值多元化传统商业研究与产业发展侧重短期与长期经济利益，其价值观点立足于消费者与生产者，认为企业是价值创造者，顾客是价值破坏者(Norman &amp; Ramírez, HBR 71(4): 65-77,1993)；在现代服务中，客户成为其价值共创的参与者与重要资源，服务提供者（企业）必须与客户的价值形成有效融合，才能实现价值共创。 产品（工业经济）满足用户生理需求、安全需求或者社交需求其中之一的满足，侧重经济价值；服务过程（体验经济）不仅需要有效整合各种资源（服务提供者），还常常需要考虑同时满足客户尊重与自我实现等多种需求，因此包括了经济价值与社会价值 服务的新产品与新模式不断涌现 服务科学研究的需求与应用背景医养结合的居家养老服务 我国老年人口情况 65岁+人口:2013年末1.32亿 2017年末1.58亿 2018年末1.67亿 65岁+人口年增加：2013年前400万 2018年800+万 65岁+人口占比11.9%；2030年全球65岁+人口占比23.5% 医疗服务需求 我国65岁+慢性病患病率54%；慢性病患者近3亿 2011-2030年慢性病造成的全球经济损失47万亿美元 共性问题：有效服务供给不足，服务需求差异巨大 服务型制造世界一流的制造企业都是高度国际化的服务型制造提供商：以开创性的服务理念、先进的制造服务化模式和国际化的服务运营视角在全球组织制造和服务资源 服务型制造：强调制造企业从出售产品向出售一体化的解决方案转变 服务型制造是制造企业实现跨越式的转型升级，实现从制造大国向制造强国迈进的重要手段 制造服务提供商的服务创新能力，包括技术创新和服务模式创新能力是其能否成功转型升级的关键 共性特征： 集成客户域中的服务需求 打通制造组织域中的线上数据分析和线下智能生产过程 整合内外部制造与服务资源，创造全新的产品服务 基于平台的资源共享服务互联网与大数据技术的发展及广泛应用，为服务资源组织效率和满足客户的个性化服务需求的能力建设、从而提高服务质量提供了新的可能与发展空间。 改变了人们的资源观：资源所有-&gt;资源所用 耐用品（自行车、房屋）、稀缺品（如关键设备与装备等） 数据、智力（知识、创造力） 服务供给侧改革的重要举措，也是社会经济可持续发展的一个可能的促进措施 共性特征：通过资源状态的实时感知，在较大时空范围内实现个性化服务需求的关联，及其与服务能力(资源)的动态匹配 supervised by Prof. Zhongsheng Hua of Zhejiang University]]></content>
      <categories>
        <category>昨天、今天、明天</category>
      </categories>
      <tags>
        <tag>服务</tag>
        <tag>Service</tag>
        <tag>Service Industry</tag>
        <tag>服务业</tag>
        <tag>现代服务业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《海贼王》与日本社会的映射关系及相关思考]]></title>
    <url>%2F2019%2F06%2F20%2F%E3%80%8A%E6%B5%B7%E8%B4%BC%E7%8E%8B%E3%80%8B%E4%B8%8E%E6%97%A5%E6%9C%AC%E7%A4%BE%E4%BC%9A%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[为什么要讨论这个问题？漫画作为一种文化载体，和书籍、影视作品一样，是能够对人的思想、情感造成影响的。况且《海贼王》是一部影响重大的现象级作品，不仅在日本国内的影响巨大，更是日本文化输出的一个重要载体。面对这样一部影响力、阅读人数已经远超许多“教科书”的作品，如果不对其表达的思想进行研究、对其政治倾向进行探讨，才会显得奇怪。 日本社会、文化背景要理解海贼王，首先要理解日本当前的一个社会文化背景： 日本放弃战争权，但是没有对民众讲清楚 日本文化中，暴力是不好的 日本社会极度秩序井然 而文化作品（如周刊jump）却强调正当使用暴力 何时可以使用暴力、暴力和秩序之间的关系，一直被思考 漫画成为了发泄现实中无法使用的暴力的一个重要载体。 那么海贼王中如何“正当的使用暴力”呢？漫画中为了使用暴力常用的世界观背景： 有政府和秩序系统 秩序系统无法解决问题（龙珠） 在秩序内搏斗（运动、美食系漫画） 在边缘试探（猫眼三姐妹） 没有政府和秩序系统 废土、架空世界（北斗神拳） 历史上的“无秩序”时代（浪客剑心） 海贼王显然属于有政府但不解决问题的那一种。那么海贼王中使用暴力主要对抗什么呢？ 不同于龙珠，暴力的使用并非来自生存的压力（地球毁灭之类的），海贼王中的暴力使用主要用于对抗秩序系统的不合理性。 海贼王中的势力划分及现实对应关系海贼王中的团体类别粗略的划分，主要有三个： 世界政府 天龙人 海军 各个国家 七武海* 海贼 七武海* 四皇 小海贼 革命军 可以看到不论是哪一个类别的势力，都有“好”有“坏”。既有好的海军，也有坏的海军；既有好的海贼，也有坏的海贼。革命军出场较少，暂且不谈。 其实这里我们可以做一个对应，我更倾向于将一个个海贼团体看作现实社会中的非执政党，将世界政府看作执政党和政府，革命军是放弃了合法上位的、以革命为第一上位手段的政治团体（或者说是恐怖分子）。如果再把前半段看作海内，新世界看作海外，这里我们就可以把海贼王的世界观和日本现状做一个进一步的对应： 世界政府(执政党/政府) 天龙人：天皇 海军：执法机关/自卫队 各个国家：各个州县 七武海*：与执政党合作的在野党 海贼 七武海*：官职与合法性由执政党赋予，本质上还是在野党 四皇：影响力较大的海外势力/党派 小海贼：小的在野党派 革命军：想要推翻政府的恐怖势力 海贼王架构与现实架构对应这里我们就可以把海贼王用现实的视角重新梳理一遍了： 天皇（天龙人）主要是由血缘维持的世袭制无所事事轻松自在，而普通民众生存压力大且困难，为了迎合民众的不满、尾田对其进行了丑化；自卫队（海军）虽然帮助维护秩序，但是内部贪污腐败、良莠不齐；各个州县（海贼王中各个国家）的领导人，虽然名义上是选举，但是日本近年来阶层固化，政治家的儿子还是政治家，实际上接近世袭。 执政党（世界政府）无论如何都是想清除掉在野党的（海贼），这可以稳固自己的统治和政治；如果有较为强大的在野势力（七武海），就收为己用；对于海外的大型势力（四皇），则保持一种默契，井水不犯河水。这种大型海外势力（四皇），可以是家族（白胡子），可以是中立势力（红发），可以是国家（凯多），可以是邪教（大妈），可以是犯罪团体（黑胡子），是一种团体或者势力的高度抽象。 基于以上对应关系，我们可以提出一些猜测：消失的一百年历史极有可能对应二战日本侵略的历史，政府想要掩盖，新一代已经被选择了忘记，在海贼王中的表现应该和屠杀相关；而历史文本对应的就是在日本国外的客观公正第三方的史册；而历史文本指向的One Piece可能就是世界的真理与真相、绝对的公平正义之类的。 路飞及D之一族的现实意义与内涵路飞在作品中，其实是大多数日本民众脑中的主观正义的化身。之所以说是主观正义，是因为这种正义是不依赖于当前政府及其秩序系统的、不关心程序正确、只关心结果正确的一种“天降正义”。尾田清楚，这种正义，不可能由任何一方产生，因此将路飞设定成海军的孙子、革命军的儿子、海贼意志的继承者的复杂身世，代表了一种混沌的中立和绝对平衡的正义状态。 海贼王的大热，也是得益于路飞及其海贼团有关的剧情设置满足了大众的一些心理诉求。 比如船员配置： 这种正义（路飞）会从腐败政府机构下保护民众（索隆），从黑恶势力下保护民众（娜美） 接纳社会中的各种边缘人（骷髅、驯鹿、弗兰奇） 保护民众认为无罪的政治犯（罗宾） 能够帮助能力不足的人实现梦想（乌索普、山治） 比如暴力使用：这种正义（路飞），可以 对抗腐败势力（打瓦波尔） 恢复地区秩序（打老沙） 制约天皇（天龙人）特权（打多弗朗明哥） 无视政府，保护自身及一般民众合法权益（打海军救罗宾、救艾斯、自救） 比如打四皇那为什么要打四皇呢？前文我们也说了，伟大航线前半段是海内，新世界是海外，因此红土大陆其实代表的是海关，过人鱼岛为什么那么难？偷渡当然难了！回到四皇上来，路飞打四皇，是对于该形象的一种升华，路飞不仅仅局限于日本（前半段），而是成为一种世界性的、全人类的正义和良知的标杆。 先说大妈，大妈海贼团代表了一种邪教，通过吸食下级信徒的资源（食材、灵魂）来满足上级暴力统治者（大妈）的欲望（甜品、永生），并通过这些资源（灵魂）来巩固自己的统治地位（玩具兵）。因此，打击邪教，义不容辞。 再说凯多，凯多代表了海外的暴政，因此我们的正义（路飞），也要将畸形的国家矫正到一个正确的政治形态。 最后黑胡子，黑胡子团体代表了逃亡海外的犯人们，政府无法拿他们怎么样，因此需要我们的正义化身（路飞）出手。 而至于白胡子和红发，一个说明了家族势力不能对抗政府机关（顶上之战），而另一个的境遇则和现实中的中立势力的地位及其相似：大家都要给一个面子。 关于D之一族现在就清楚为什么有人要求路飞当他们的领导，路飞不会留下来了。因为路飞代表的是一种普世的、绝对的、超脱于法律之外的“绝对正义”，一旦在某个地方成为头头，就会降格为地区性普通执法机关，后边就难画了，关键是丢份儿。 现在D之一族的定位的比较清楚了：如果路飞是民众的“绝对正义”，那么多拉格代表变革者心中的“绝对正义”，卡普代表当权者心中的“绝对正义”，黑胡子代表恶徒心中的“绝对正义”。D之一族在作品中的地位几乎皆是如此，只是代表的阶级和群体不同。 那么海贼王这个身份代表什么呢？海贼王及其船队这一势力已经脱离的普通的政治团体，成为了一种宗教。这种宗教叫自由。海贼王这一身份则代表教皇这一职位，也代表了绝对的自由。 那么罗杰的下场也能够得以解释：没有限制的自由（海贼王），最终会走向末路（不治之症）。而如果想要寻求秩序（罗杰自首），则自由会被摧毁（罗杰被斩首）。 这里罗杰向卡普托孤，是希望执政党中的良知，可以在已有秩序之下，保护自由的火苗（艾斯）；罗杰爆料One Piece的存在，是希望民众不要在统治中变得麻木，为了激励人们追寻真正的自由。 写在最后One Piece真的存在么？ 也许One Piece是一大笔财富；也许One Piece是一本自由主义的“圣经”；也许罗杰只是为了激起麻木的人们对自由向往；也许白胡子就是理解了罗杰的意图，才故意说出“One Piece是真实存在的这种话”……没有人说过One Piece一定是实体的物品，也许在追寻One Piece过程中，收获的伙伴、了解到的历史的真相、获得成长的自己以及自己的思想，才是真正的One Piece吧 写在最最后纯属脑洞，海贼王这么长，肯定还有很多东西没讲到，就算尾田想对应，也不一定做的很严谨，大家看了就当一乐吧]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>One Piece</tag>
        <tag>海贼王</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机应用数学学习笔记（三）：通过稀疏表示进行图像修复（IMAGE INPAINTING VIA SPARSE REPRESENTATION）]]></title>
    <url>%2F2019%2F06%2F19%2F%E9%80%9A%E8%BF%87%E7%A8%80%E7%96%8F%E8%A1%A8%E7%A4%BA%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E4%BF%AE%E5%A4%8D%EF%BC%88IMAGE-INPAINTING-VIA-SPARSE-REPRESENTATION%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这篇文章提出了一种新的基于冗余字典的图像信号稀疏表示的补丁式图像修复算法，该算法保证低风险的条件下，在处理大的孔的同时，保存图像细节。 与现有的所有工作不同，这篇文章假设每个图像块在冗余字典上允许稀疏表示的假设下，从连续不完全信号恢复的角度考虑图像修复问题。为了保证填充孔与周围环境之间的视觉合理性和一致性约束，这篇文章建议直接从当前图像的完整源区域采样，构造一个冗余信号字典。然后，我们依次计算出孔边界上每个不完整补片的稀疏表示，并将其恢复到整个孔被填满为止。 实验结果表明，该方法能够有效地填充视觉上可信的信息，并降低引入不需要的对象的风险。 简介一般而言，文献中有两种主要的图像修复方法：基于PDE的方法和基于范例的方法。 基于PDE的方法目的是将已知区域中的线或边缘延伸到用户指定的区域，这些区域充分注意结构传播，但由于其情况下的模糊效应而不适合处理大区域。 基于范例的方法采用纹理合成方法来合成用户指定区域中的像素。 这篇文章主要的贡献是借用信号稀疏表示技术来解决修复问题，并弥合稀疏表示和纹理合成之间的差距。 信号稀疏表示意味着信号允许在冗余字典上进行稀疏表示，我们将在下一节中进行讨论。在这篇文章中，我们将此问题视为不完整图像信号的恢复，每个信号对应一个补丁。他们根据每个补丁的稀疏表示智能地填补漏洞。 稀疏表示Donoho证明了L1范数是L0范数的良好近似。因此，许多技术得到了支持。 Tibshirani提出了一种回归方法：Lasso。他在普通最小二乘回归的损失函数中加入了L1范数罚分，导致系数的稀疏性。 给定字典 $\mathbf{x}=\left[\mathbf{x}^{1}, \mathbf{x}^{2}, \ldots, \mathbf{x}^{\mathbf{N}}\right]$ 以及输入信号 $\mathbf{y}=\left[y_{1}, y_{2}, \dots, y_{p}\right]^{T}$ ，并假定两者都已经进行了正则化。Lasso算法是用来在给定字典情况下估算一个信号的系数 $\beta$ 通过公式： $\widehat{\boldsymbol{\beta}}=\arg\min\lbrace||\mathbf{y}-\mathbf{x} \boldsymbol{\beta}||_2^2+\lambda||\boldsymbol{\beta}||_1\rbrace$ $||\boldsymbol{\beta}||_{1}$ 引入拟合系数向量的稀疏性，参数 $\lambda$ 控制重构误差与稀疏性之间的权衡。这个公式基于模型 $\mathbf{y}=\mathbf{x} \boldsymbol{\beta}$ 且 $\boldsymbol{\beta}$ 需要是稀疏的。 更有趣的是，当信号的某些组件被破坏时，这意味着模型被修改为 $\mathbf{y}=\mathbf{x} \boldsymbol{\beta}+\mathbf{e}$ 其中 $\mathbf{e}$ 代表误差，当且仅当 $y_i$ 是损坏的情况下， $e_i$ 非零。这可以用来帮助我们找到损坏的信号。但是在这篇应用中，需要被修正的区域已经被用户标记，因此我们可以直接判断像素点是否已经被损坏。 我们将损坏的信号的索引集标记为 $I,I=\lbrace i|e_i\neq0\rbrace$ 。 $\boldsymbol{y}_{|I}$ 表示从 $\boldsymbol{y}$ 中去掉索引在 $I$ 中部分剩下的向量。 $\boldsymbol{x}_{|I}$ 是对应的词典矩阵，从去掉了 $\boldsymbol{x}$ 中所有索引在 $I$ 中部分剩下的列得到。 现在稀疏系数 $\boldsymbol{\beta}$ 可以通过下边公式来进行计算： $\widehat{\boldsymbol{\beta}} = \arg \min\lbrace || \mathbf{y}_{|I}-\mathbf{x}_{|I}\boldsymbol{\beta}||_2^2+\lambda||\boldsymbol{\beta}||_1\rbrace$ 然后我们通过计算出的 $\widehat{\boldsymbol{\beta}}$ 来修复受损的信号： $\hat{y}_{i}=\left\lbrace\begin{array}{ll}{y_i,} &amp; {\text { if } i \notin I} \\ {(\mathbf{x} \hat{\boldsymbol{\beta}})_i,} &amp; {\text { if } i \in I}\end{array}\right.$ 图像修复算法填补顺序给定输入图像，用户选择要移除和填充的目标区域。然后通常将丢失的部分视为目标区域。当然，它也可以由用户指定。我们用 $\Omega$ 表示目标区域，用 $\Phi$ 表示源区域，用 $\delta\Omega$ 表示目标区域的边缘。 这篇文章从孔的边界向内部生成图像。这篇工作里按照[6]来确定填充顺序，因为它有效地保留了结构信息。 在每次迭代过程中，我们计算边缘 $\delta\Omega$ 上的每个像素 $p$ 的优先级 $P(p)$ ，并选择优先级最高的像素设为 $p_m$ 。以 $p_m$ 为中心的补丁将在当前迭代中解决。由于不定的中心在边界上，补丁的一部分像素在目标区域中。因此这个补丁可以被看作是一个不完整的信号，现有部分的信号来自源区域，而缺失的部分来自目标区域。接下来通过稀疏表示来补全这个信号即可。当前不定补全之后再更新边界，进行下一轮迭代即可。 信号恢复现在我们已经定位了像素 $p_m$ 。用一个k维向量 $\Psi_{P_m}$ 表示以 $p_m$ 为中心的补丁。显然 k=nxn ，这里n表示补丁的宽和高。现在根据之前讲的通过稀疏表示，将 $\Psi_{P_m}$ 看作 $\boldsymbol{y}$ ，也就是需要恢复的信号，更加直观地说， $\boldsymbol{y}$ 中属于目标区域的部分的索引集可以被看作 $\boldsymbol{I}$ 。 因此现在，我们可以通过以下两个公式来计算稀疏表示： $\widehat{\boldsymbol{\beta}} = \arg \min\lbrace ||\Psi_{Pm|I}-\mathbf{x}_{|I} \boldsymbol{\beta}||_2^2+\lambda||\boldsymbol{\beta}||_1\rbrace$ $\hat{\Psi}_{p_m}^i=\left\lbrace\begin{array}{ll}{\Psi_{p_m}^i,} &amp; {\text { if } i \notin I} \\ {(\mathbf{x} \hat{\boldsymbol{\beta}})_i,} &amp; {\text { if } i \in I}\end{array}\right.$ 字典构建为了计算信号的稀疏表示，我们首先需要构造一个字典，并在此基础上求解拉索回归。可以采用许多技术来修复字典，例如匹配追踪、基追踪、或K-SVD。 根据我们的观察，填充的目标区域应该在视觉上与源区域一致，这样整个图像看起来似乎是可信的，这意味着不仅纹理应该一致，而且噪音也应该是相同的水平。因此，我们直接对源区域中的所有补丁进行采样，甚至使用它们来构造字典，而不需要进行任何预处理。 例如，如果我们从源区域获得m个补丁，那么固定字典应该有m列。每列对应一个补丁。这种将原始图像作为词典的技术已经应用于人脸识别、背景建模等领域，取得了令人鼓舞的效果。 整体算法 reference:https://www.mendeley.com/catalogue/image-inpainting-via-sparse-representation/]]></content>
      <categories>
        <category>计算机应用数学</category>
      </categories>
      <tags>
        <tag>计算机应用数学</tag>
        <tag>image inpainting</tag>
        <tag>sparse representation</tag>
        <tag>稀疏表示</tag>
        <tag>图像修复</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Modeling：建模的意义、方法和步骤]]></title>
    <url>%2F2019%2F06%2F13%2FModeling%EF%BC%9A%E5%BB%BA%E6%A8%A1%E7%9A%84%E6%84%8F%E4%B9%89%E3%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[建模就是建立模型，就是为了理解事物而对事物做出的一种抽象，是对事物的一种无歧义的书面描述。建立系统模型的过程，又称模型化。建模是研究系统的重要手段和前提。凡是用模型描述系统的因果关系或相互关系的过程都属于建模。因描述的关系各异，所以实现这一过程的手段和方法也是多种多样的。可以通过对系统本身运动规律的分析，根据事物的机理来建模;也可以通过对系统的实验或统计数据的处理，并根据关于系统的已有的知识和经验来建模。还可以同时使用几种方法。建模的意义系统建模主要用于三个方面。 分析和设计实际系统。例如工程界在分析设计一个新系统时，通常先进行数学仿真和物理仿真实验，最后再到现场作实物实验。数学仿真比物理仿真简单、易行。用数学仿真来分析和设计一个实际系统时，必须有一个描述系统特征的模型。对于许多复杂的工业控制过程，建模往往是最关键和最困难的任务。对社会和经济系统的定性或定量研究也是从建模着手的。例如在人口控制论中，建立各种类型的人口模型，改变模型中的某些参量，可以分析研究人口政策对于人口发展的影响。 预测或预报实际系统的某些状态的未来发展趋势。预测或预报基于事物发展过程的连贯性。例如根据以往的测量数据建立气象变化的数学模型，用于预报未来的气象。 对系统实行最优控制。运用控制理论设计控制器或最优控制律的关键或前提是有一个能表征系统特征的数学模型。在建模的基础上，再根据极大值原理、动态规划、反馈、解耦、极点配置、自组织、自适应和智能控制等方法，设计各种各样的控制器或控制律。 系统建模主要用于3个方面对于同一个实际系统，人们可以根据不同的用途和目的建立不同的模型。但建立的任何模型都只是实际系统原型的简化，因为既不可能也没必要把实际系统的所有细节都列举出来。如果在简化模型中能保留系统原型的一些本质特征，那么就可认为模型与系统原型是相似的，是可以用来描述原系统的。因此，实际建模时，必须在模型的简化与分析结果的准确性之间作出适当的折中，这常是建模遵循的一条原则。 建模的常用方法实体建模法实体是现实世界中存在的事物或发生的事件，是现实世界中任何可识别、可区分的事物。实体可以是人，可以是物，也可以是发生的某件事，比如一场篮球比赛。每一个实体都必须具备一定的特征，用来区分一个个实体，这些特征称为属性，每个实体可以用若干个属性来刻画，每个属性又有一定的取值类型和取值范围，属性是变量，其取值范围是属性的值域。实体建模法是根据客观世界中的一个个实体，以及实体之间的关系，在数据建模的过程中引入这种区分方法，将整个业务分成一个个实体，从而建立数据模型。实体建模可以比较容易的实现模型的划分，抽象出具体的业务概念，创建符合自己需要的数据库模型。实体建模是对客观世界的抽象，因此该方法建立的模型具有一定的局限性，适合于特定的领域。 纬度建模法维度在数学上指独立参数的数据，在数据分析领域，是指描述事物的角度和方面，是数据库当中，描述某一事物的方法和属性的数目。维度建模就是针对给定的事物，使用不同的描述方法，记录该事物在不同分类方法当中每个属性的值。如对人进行维度建模时，按照性别的维度可以分为男和女，按照年龄段可以分为儿童、少年、青年、中年、老年，按照收入水平可以分为3000以下、3000-6000、6000-10000，10000以上等集中类别。 维度建模法的好处是对于某个事物，可以在各个维度进行预处理，进行统计、分类、排序等，提高数据库操作性能，同时维度建模法建立的数据模型比较直观，可以紧密围绕业务需求建立模型，直观的反应业务中的问题，建模方法简单，不需要进行特别的抽象处理。但是维度建模法同时也存在缺点，一是在数据建模时需要进行预处理，存在大量的预处理工作，并且当业务需求发生变化时，需要重新定义维度，重新进行新维度的数据预处理，在数据预处理过程中往往存在大量数据冗余，另外就是在进行维度建模时，仅仅依靠维度进行建模，不能保证数据来源的准确性和一致性，不适合在数据库底层使用。 范式建模法范式就是规则，是符合某一级别关系模式的集合，构造数据库时必须遵循一定的规则。关系数据库中的关系必须满足一定的规则，即满足不同的范式。 范式建模法是将原始数据信息根据一定的数据结构和转换模型，分解、转化为规范的格式，使数据遵守一定的约束条件，每一个数据项所表达的意思明确，不产生歧义，同时各条数据之间相互独立，不存在依赖关系。 数学建模的步骤五步方法顾名思义，通过五个步骤完成用数学模型解决实际问题。它包含以下五个步骤： 第一步，提出问题 列出问题中涉及到的变量，包括适当的单位 注意不要混淆了变量和常量 列出对变量所做的全部假设，包括等式和不等式 检查单位从而保证假设是有意义的 用准确的数学表达式给出问题的目标 第二步，选择建模方法 选择解决问题的一个一般的求解方法 一般地，这一步需要有一定的数学建模经验和技巧。同时需要熟悉相关的文献 第三步，推导模型的公式 将第一步中得到的问题重新表达成第二步选定的建模方法所需要的形式 确保第一步中的变量名与第二步的一致 记下任何补充假设，这些假设是为了使第一步中描述的问题与第二步中选定的数学结构相适应而做出的 第四步，求解模型 将第二步中所选方法应用于第三步得到的表达式 注意数学推导，确保推导过程无误且结果有意义 采用适当的方法扩大解决问题的范围并减少计算错误 第五步，回答问题 用非技术性的语言将第四步的结果重新表述 避免数学符号和术语 reference:https://baike.baidu.com/item/建模/814831?fr=aladdinhttps://blog.csdn.net/qq_27123591/article/details/82223552https://blog.csdn.net/hebi123s/article/details/84566377]]></content>
      <categories>
        <category>Modeling</category>
      </categories>
      <tags>
        <tag>建模</tag>
        <tag>Modeling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机应用数学学习笔记（二）：L0范式、L1范式、L2范式、...、L ∞ 范式]]></title>
    <url>%2F2019%2F06%2F11%2FL0%E8%8C%83%E5%BC%8F%E3%80%81L1%E8%8C%83%E5%BC%8F%E3%80%81L2%E8%8C%83%E5%BC%8F%E3%80%81-%E3%80%81L-%E2%88%9E-%E8%8C%83%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[什么是范式简单来说，一个 $l_p$ 范式可以被定义为 $||x||_p = \sqrt[p]{\Sigma_i|x_i|^p}$ l0范式定义根据定义，l0范式应该是： $||x||_0 = \sqrt[0]{\Sigma_i|x_i|^0}$ 严格地说，l0范数实际上不是一个范数。它是一个基数函数，尽管许多人称之为范式。显然，任何x&gt;0都会变成1，但是零次幂的定义，特别是零次根的定义问题，在这里是混乱的。因此实际上，大多数数学家和工程师使用以下定义来代替l0范式： $||x||_0 = \sharp(i|x_i \neq 0)$ 这是指一个向量中非零元素的总数。 优化许多应用，包括压缩感测，都试图将对应于某些约束的向量的l0范数最小化，因此称为“l0最小化”。标准最小化问题的公式如下： $min ||x||_0$ subject to $Ax = b$ 然而，这样做并不容易。由于缺乏l0范数的数学表示，l0最小化被计算机科学家视为一个NP难题，简单地说它太复杂，几乎不可能解决。 在许多情况下，l0最小化问题被放宽为高阶规范问题，如l1最小化和l2最小化。 l1范式定义$||x||_1 = \Sigma_i|x_i|$ 这个规范在规范家族中很常见。它在各个领域有许多名称和形式，如曼哈顿范式是它的别称。 应用如果计算两个向量或矩阵之间的差的l1范数，即 $SAD(x_1,x_2)=||x_1-x_2||1=\Sigma_i|x{1_i}-x_{2_i}|$ 它在计算机视觉科学家之间被称为绝对差异之和（SAD）。 在信号差测量的一般情况下，可通过以下方式将其缩放为单位矢量： $MAE(x_1, x_2) = \frac1n ||x_1-x_2|| 1 = \frac1n \Sigma_i |x{1_i} - x_{2_i}|$ where $n$ is a size of $x$ . 这就是所谓的平均绝对误差(MAE)。 l2范式定义所有范式中最流行的是l_2-norm。它几乎应用于整个工程和科学的各个领域。根据基本定义，l_2-norm定义为 $||x||_2 = \sqrt{\Sigma_i|x_i|^2}$ 应用l2范数也被称为欧几里得范数，它被用作测量向量差的标准量。在l1范数中，如果欧几里得范数是针对向量差计算的，则称为欧几里得距离： $||X_1-X_2||2=\sqrt{\Sigma_i(x{1_i}-x_{2_i})^2}$ 或者以平方形式，即计算机视觉科学家之间所说的平方差之和（SSD）： $SSD(x_1,x_2)=||X_1-X_2||2^2=\Sigma_i(x{1_i}-x_{2_i})^2$ 在信号处理领域最著名的应用是均方误差（MSE）测量，它用于计算两个信号之间的相似性、质量或相关性。最小均方误差 $MSE(x_1,x_2)=\frac1n||X_1-X_2||2^2=\frac1n\Sigma_i(x{1_i}-x_{2_i})^2$ 正如前面在L_0-优化部分讨论的那样，由于从计算和数学的角度来看有许多问题，许多L_0-优化问题放松自己，变成L_1-和L_2-优化。因此，我们现在将讨论L_2的优化。 l $\infty$ 范式定义$||x||_\infty = \sqrt[\infty]{\Sigma_i|x_i|^\infty}$ 现在，这个定义看起来又很棘手，但实际上它是相当狭隘的。考虑向量 $x$ ，假设 $x_j$ 是向量 $x$ 中的最高项，根据无穷大本身的属性，我们可以这样说 $x_j^\infty \gg x_i^\infty \forall i \neq j$ 然后 $\Sigma_ix_i^\infty=x_j^\infty$ 然后 $||x||_\infty=\sqrt[\infty]{\Sigma_ix_i^\infty}=\sqrt[\infty]{x_j^\infty}=|x_j|$ 现在我们可以将l $\infty$ 范式简化为 $||x||_\infty=max(|x_i|)$ 其实也就是该向量的最大项的大小。 ref：https://rorasa.wordpress.com/2012/05/13/l0-norm-l1-norm-l2-norm-l-infinity-norm/]]></content>
      <categories>
        <category>计算机应用数学</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机应用数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机应用数学学习笔记（一）：背景知识]]></title>
    <url>%2F2019%2F06%2F10%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%94%E7%94%A8%E6%95%B0%E5%AD%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[挑战计算机科学现在面临的最大挑战是大数据，所有的大公司都在收集数据。为了构建数据化的世界和生活，需要做许多枯燥乏味的工作。需要处理现有的数据然后在此基础上构造新的数据。 纯步骤合成vs纯数据纯步骤合成：紧凑，但依赖人造，很少在实践中使用 纯数据：质量更高，但是灵活性更低 贝叶斯推理 不确定性的原理建模 非结构化数据的通用模型 不确定性下数据拟合与分析的有效算法 但目前它一直被用作黑盒 数据驱动建模 数据驱动的相关技术 数据驱动系统学习系统不是直接编程来解决问题，而是根据以下内容开发自己的程序： 他们应该如何表现的例子 从尝试解决问题的试错经验中 与标准CS不同，要实现未知功能，只需要访问样本输入输出对（训练样本） 学习问题的主要分类根据培训示例中的可用信息，学习场景会有所不同 监督学习：纠正输出可用 分类：1-of-N output（语音识别，对象识别，医学诊断） 回归：实际值输出（预测市场价格、温度） 无监督学习：无反馈，需要构建良好输出的度量 聚类：将参考技术的数据分类为连贯的“聚类” 新颖性检测：检测新的偏离正常的数据点 强化学习：尺度反馈，可能是临时的 更多的应用场景 时间序列分析 降维 模型选择 通用方法 图形化模型 为什么需要数据驱动的方法 开发增强型计算机系统 自动适应用户，自定义 经常很难获得必要的知识 在大型数据库中离线发现模式（数据挖掘） 提高对人类、生物学习的理解 计算分析提供了具体的理论，预测 发掘在学习过程中分析大脑活动的方法 时机不错 越来越多的可用数据 廉价而强大的计算机 一套算法，理论已经发展 成功的数据驱动算法会是什么]]></content>
      <categories>
        <category>计算机应用数学</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>计算机应用数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[互联网医疗服务：昨天、今天、明天]]></title>
    <url>%2F2019%2F06%2F08%2F%E4%BA%92%E8%81%94%E7%BD%91%E5%8C%BB%E7%96%97%E6%9C%8D%E5%8A%A1%EF%BC%9A%E6%98%A8%E5%A4%A9%E3%80%81%E4%BB%8A%E5%A4%A9%E3%80%81%E6%98%8E%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[自党的十八届五中全会明确将“互联网+”行动计划作为未来发展战略，“互联网+健康医疗”便逐渐成为我国医疗行业发展的新方向。2016年6月24日“首届国际互联网医疗大会暨中国互联网医疗健康产业联盟成立大会”在乌镇召开，对医疗、医药、保险等产业链各节点、及线上线下更有效率地融合；如何使相关政策、行业标准的推出与产业创新更好协同；如何有效推进互联网医疗健康产业发展等问题，进行了深入探讨。“互联网+健康医疗”新型服务模式有利于改善医疗质量、减少患者入院率、降低医疗成本、提高效率，是我国深化医疗卫生体制改革的重要任务和支撑，其对于我国建设跨地域、跨机构就诊信息共享的区域医疗联合体有着较强的现实和理论意义。 互联网的飞速发展催生了新的医疗服务模式，互联网医疗已成为医疗卫生和预防保健领域中不可或缺的一部分。随着李克强总理提出制定“互联网+”行动计划，医疗领域中“互联网+医疗”的产品和服务如雨后春笋般涌现，而建立以互联网为载体、患者主动参与疾病诊疗、可随时随地进行线上线下互动的医疗服务管理新模式，构建新的互联网医疗服务体系，能使广大群众享受更加高效、公平和便捷的医疗卫生和预防保健服务。本文在介绍近年来国内、外互联网医疗服务主要模式的基础上，就互联网医疗发展面临的机遇、挑战和未来走势作一探讨。昨天：我国传统医疗服务模式传统医疗服务模式结构我国传统医疗服务模式是以医院为中心的星型结构（如下图），医院处于中心地位。药企、医疗器械，保险公司、医保等机构以及患者、其他医疗服务都围绕医院展开。从检查、科室就医，处方药，患者就医流程都由医生主导，医患信息不透明。另外，政府对于医院财政支出不足，而随着我国老龄化加剧，现今的医保资金难以满足逐渐增加的参保人数需求，所以医保资金的压力逐渐转移到医院。第三，处方药作为医院收入的一大来源，也是一定程度上掌握在医院手里。 传统医疗的不足传统医疗服务模式中，由于资金流、信息流以及物料流等以医院为核心环节，其他各环节信息流通不畅导致工作效率低下，引起以下诸多弊端。首先，医疗资源分布不均。由于三甲医院对基层医疗机构人才和资源的虹吸效应，优质医疗资源过度集中于大城市，基层医疗人员数量不足、诊疗水平达不到标准，导致“乡镇医院无患者可医，大医院人满为患”。再者，就医方式效率低，就医体验“三长一短”，服务质量不尽如人意，导致医患关系紧张。且仅有单纯的院内服务，缺乏院后服务。其次，政府财政支持不足，医保缺口明显。目前医院正常运营大部分资金来源于自身盈利，但其本质的公益性又使得收入有所限制，加之政府的宏观调控，使得医院处于两难境地。导致这些弊端本质在于人们日益增长的医疗保健需求同传统医疗服务所提供的资源不对称，无法满足当今人们需求变化的节奏。 今天：互联网医疗服务的主要模式国外的主要模式国外互联网医疗的建设起步较早，现已形成相对完善的管理和组织体系。考虑到人们对医疗保健知识的渴求日益增强，而在医疗环境中获取的健康信息及其可用性又很有限，因此越来越多的互联网医疗服务软件被开发出来并得到广泛应用。一项调查结果表明，美国居民中约31%的手机用户使用手机寻找健康或医疗信息，约35%的手机用户下载了应用程序来跟踪或管理自己的健康状况。另一项相似调查的结果显示，72%的成年人在互联网上查询健康信息，65%的互联网用户表示使用互联网和手机可更好地了解健康信息，互联网医疗干预的灵活性受到了广泛的追捧和欢迎。 可穿戴医疗设备可穿戴医疗设备能通过传感器及时获取生理、行为和健康相关的数据，研究人员则可通过互联网同步获得这些数据并分析可能的影响因素。便携式和可穿戴传感器已越来越多地用于采集个人的生物、心理和行为数据，用于个人保健和健康的监测。通过可穿戴医疗设备获取的信息除能用于医疗保健外，还能用于相关医学研究并为制定公共卫生政策提供依据。 数据平台的构建和共享在美国的医疗服务体系中，患者的电子病历和电子处方可在医生之间共享，当居民在异地发生意外时，医疗机构就能通过他的身份信息迅速获取其电子病历及处方，帮助医生及时、准确地了解他的疾病史等情况。这种数据共享也有利于远程医疗的开展，利用医生、患者和科研机构三者之间形成的互联网数据大平台，医生、患者和科研人员可根据自己的需要利用和获取相关信息，有利于诊疗活动的开展，并提高患者的就医满意度，保障患者健康。 监测和记录利用互联网医疗设备进行生物信息监测和健康指导已渐走入大众生活，通过监测可帮助患者及医护人员及时发现相关风险，提高患者的自我健康管理能力。ZEO通过蓝牙手机和床旁设备相连接，通过睡眠监测得出综合睡眠报告，用户也可通过监测得分的变化或与同年龄组平均分相比较而了解自己的睡眠状况。另外，越来越多的智能手机内置了运动传感器，可检测用户的异常行为，如老年人的跌倒、帕金森病患者的步态僵直等。还有的互联网医疗服务软件能监测睡眠状况、检测心血管疾病、警示健康状况或监测慢性阻塞性肺疾病患者的血氧饱和度和呼吸等指标值。类似的，血压仪、血糖仪和电子心电仪等医疗监测设备已得到广泛使用，这些便携式医疗设备能帮助患者在家中进行自我健康监测，时刻为患者提供健康信息及服务。 信息化诊所运营商互联网医疗的移动性使得人们无论是在家中、还是在路途中都能得到医疗服务和获取各种与健康相关的信息，避免了传统就医模式中的看病难、流程繁琐等问题，节省时间的同时还降低了就医成本，并具有促进自我健康管理的作用。One Medical Group运营了多家诊所，患者可网上预约就诊或在线购买药品、甚至在线查询检查结果。新技术提高了临床医疗的透明度，但仍存在相关信息的所有权和医疗记录访问的权限等敏感问题，需予进一步关注。互联网医疗的有效性、安全性和成本—效益的评估将是对其未来研究工作的重要部分。 慢性病管理平台随着经济、社会的迅速发展，慢性病发病率逐年升高，已成为首要的公共卫生问题，使得研究者和企业都非常关注对慢性病人群的医疗服务问题。WellDoc是一种糖尿病患者用血糖水平自我管理软件，通过手机和云端平台记录和存储血糖水平数据，患者能用其监测自己的血糖水平变化情况。移动健康工具的出现推动了卫生保健领域、尤其是慢性病管理的发展。有研究显示，69%的美国成年人使用互联网技术监测健康指标来管理和控制自己的慢性病。互联网医疗可提高慢性病患者的疾病自我管理能力，提高其生活质量。 国内主要模式国内医疗资源短缺且配置不合理，互联网医疗也相对落后。目前，我国互联网医疗可按诊疗时间分为诊疗前、诊疗中和诊疗后3个环节，按诊疗内容分为预约挂号、检查诊疗、药物配送、健康监测和支付保险5项服务，按适用对象分为面向医生和直接面向用户2类，按建设机构分为医院自建、企业自建和医院、企业合建3型。 网上就医服务在互联网医疗模式下，患者可通过手机应用软件或相关网站选择合适的医院进行预约挂号及完成在线支付，并可通过网络实时查看目前排队情况以方便就医，节省就医时间。微信医院或互联网医院主要是为患者提供就医服务，包括预约挂号、预约就诊等。由于微信应用广泛并具有简单、快捷的特点，微信医院得到了患者更多的认同和接受。以“掌上药店”和“天猫药馆”为代表的线上药品销售商店会自动显示附近联网的药房，患者可根据自己情况进行线上下单和结算，然后选择自取或快递的配送方式，购药变得十分方便。 医疗咨询和医患沟通以“平安医生”、“轻问诊”为代表的网络医疗咨询平台具有问诊、自诊、健康信息搜索、健康状况提醒等功能，受到患者和人们的欢迎和追捧。随着我国经济水平整体提高和疾病谱改变，人们的医疗卫生观念正逐渐由“治已病”向“防未病”转变，并希望能通过互联网获取更多的医疗保健知识。互联网医疗通过搭建医疗咨询和医患沟通平台拉近医患之间的距离，向患者提供医疗信息的同时树立了医生的个人品牌，有利于缓解医院门诊压力。 大数据平台在互联网医疗模式下，患者的医疗信息可存储于计算机，并通过云端平台发送给医疗人员和相关机构。阿里云的“未来医院”能帮助医院建立移动医疗服务平台，利用电子平台完成从门诊挂号到住院缴费、电子处方、药品配送、患者转诊、医保实时报销等各环节。目前，互联网医疗也已进军医保领域，包括线上投保及查询、医保结算以及医保机构对居民健康大数据的分析、评估和预测。 医生集团互联网的迅猛发展为医生与患者之间的信息交流提供了便捷渠道，一定程度上降低了医疗信息的不对称状况和沟通成本，有助于医生更好地建立个人品牌，而医生集团则为医生自由执业提供了一个新的选项。“张强医生集团”是国内出现的首个医生集团，现已有更多的医生集团。医生集团在增加医生自由执业路径的同时，也面临着医疗制度和法律、法规的制约，其未来的发展还有待相应制度、体制的进一步完善及支持。 明天：互联网医疗的走势分析机遇 传统医疗服务的痛点催生了互联网医疗。我国医疗体系存在医疗资源短缺且分布不均衡的问题，同时基层医疗服务水平也亟待提高，人们对医疗体制改革的呼声很高。患者有看病难、看病贵、看病繁琐、费用昂贵、渴望能够获得个性化的医疗和卫生保健知识等问题，医生则有难以与患者高效互动、缺乏接受培训和进行科研的时间等问题。在此情况下，互联网医疗顺势而出，在建立以患者为核心的医疗服务模式、诊疗信息的互联互通、健康管理和慢性病监测等方面顺应了患者的需求，同时也为医生带来了更多的职业便利和执业机会。 人口老龄化、慢性病普遍化为互联网医疗发展带来了机遇。人口老龄化，慢性病患病率逐渐提高，由此加重了我国医疗资源的紧张程度和人均医疗费用的增长速度。慢性病和老年患者多需反复就诊、长期用药、定期检测，患者的疾病自我管理能力和治疗依从性影响到疾病的进展，而通过可穿戴医疗设备等互联网医疗的监测和慢性病管理正可在一定程度上解决这些问题。 科技创新将推动互联网医疗快速发展。智能移动终端和移动网络的普及促进了互联网医疗的快速发展，可穿戴医疗设备、慢性病管理平台、智能设备等的出现改变了传统的就医诊疗模式，数据云端处理及分析的广泛应用则宣告着精准医疗和生物信息学时代的到来，医疗模式将从治疗疾病向预防疾病方向转变。 挑战 相关法律、法规亟待完善。互联网医疗服务的主体已从患者、医生和医院转变为如今的医疗服务需求者、医疗机构、资源提供者、医保机构和第三方医疗服务商，各主体间相互联系、相互影响、相互制约，构成了完整的服务网络。然而，我国互联网医疗起步较晚，相关法律、法规亟待完善。医疗活动具有严肃性和复杂性，承担着重大的社会责任，有关医生多点执业的实施、互联网医疗的开展、药品网络营销的安全性、医生实名制的真实性、患者隐私信息的保护、医疗数据能否真实反映患者的实际病情、医疗责任划分及保险制度等都需有进一步的相关法律、法规的制约或支持。 加强科技创新和技术发展。我国互联网医疗尚不如其他行业那样具有完善的管理体制和成熟的技术，目前整体发展水平相对滞后，必须有相关行业的支持和技术支撑，使医学、技术和管理有机结合，形成相互补充、相互促进的联合体，方能使之达到可持续发展的状态。因此，需对医生进行必要的培训，使其具备相应的计算机应用技能;医院必须与企业进行合作，及时更新和强化硬件实力，但应注意患者数据的安全性和隐私保护。 建立品牌，提高影响力。传统医疗服务依赖于医院实体运行，医院高墙耸立，信息不对外流通，而互联网医疗是一个开放的平台，医生自身品牌及影响力的建立就显得尤为重要。然而，受传统就医模式及思维的影响，普遍群众对互联网医疗的认知和接受程度都较低，且缺乏信任感。这就需要互联网医疗在坚持医疗服务的同时，还需利用新媒体等手段建立品牌，以促进自己的发展和良性运行。 reference:http://news.hc3i.cn/art/201704/38557.htmhttp://xueshu.baidu.com/usercenter/paper/show?paperid=2932796969c7427f0fe6772845e28776&amp;site=xueshu_se]]></content>
      <categories>
        <category>昨天、今天、明天</category>
      </categories>
      <tags>
        <tag>互联网医疗</tag>
        <tag>服务</tag>
        <tag>SERVICE</tag>
        <tag>昨天、今天、明天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[边缘计算：愿景和挑战]]></title>
    <url>%2F2019%2F06%2F07%2F%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%EF%BC%9A%E6%84%BF%E6%99%AF%E5%92%8C%E6%8C%91%E6%88%98%2F</url>
    <content type="text"><![CDATA[边缘计算有可能解决响应时间要求、电池寿命限制、带宽成本节约以及数据安全和隐私等问题。本文首先介绍了边缘计算的定义，然后介绍了从云卸载到智能家居和城市，以及协同边缘到实现边缘计算概念的几个案例研究。最后，我们提出了边缘计算领域的一些挑战和机遇，希望本文能引起社会的关注，并对这一方向的研究有所启发。为什么要研究边缘计算到2019年，由人、机器和事物产生的数据将达到500 zettabytes，正如思科全球云指数所估计的那样，但是到那时全球数据中心IP流量将仅达到10.4 zettabytes。到2019年，45%的物联网创建数据将存储、处理、分析，并在网络附近或边缘采取行动。思科互联网业务解决方案集团（Cisco Internet Business Solutions Group）预测，到2020年，将有500亿台设备连接到互联网上。有些物联网应用可能需要很短的响应时间，有些可能涉及到私有数据，有些可能产生大量的数据，这对网络来说可能是一个沉重的负担。云计算的效率不足以支持这些应用程序。 什么是边缘计算数据在网络边缘的生成越来越多，因此，在网络边缘处理数据也会更有效。以前的工作，如微型数据中心、Cloudlet和雾计算，已经引入到社区，因为当数据在网络边缘生成时，云计算并不总是有效的数据处理。在这一部分中，我们列出了一些原因，为什么对于某些计算服务，边缘计算比云计算更有效，然后我们给出了我们对边缘计算的定义和理解。 为什么需要边缘计算来自云计算的推动随着边缘数据生成量的不断增加，数据传输速度正成为云计算范式的瓶颈。例如，波音787每秒将生成大约5千兆字节的数据，但飞机与地面卫星或基站之间的带宽不足以传输数据。 来自物联网的拉动可以肯定的是，网络边缘的事物数量在几年内将发展到数十亿以上。因此，它们产生的原始数据将是巨大的，使得传统的云计算效率不足以处理所有这些数据。这意味着物联网产生的大部分数据将永远不会传输到云，而是将在网络边缘消耗。 从数据消费者到生产者的改变从数据消费者到数据生产者/消费者的变化需要在边缘放置更多的函数。例如，今天人们拍照或录像，然后通过云服务（如YouTube、Facebook、Twitter或Instagram）共享数据，这是很正常的。 此外，每一分钟内，YouTube用户上传72小时的新视频内容；Facebook用户分享近250万条内容；Twitter用户推特推特推特推特推特推特近30万次；Instagram用户发布近22万张新照片。 边缘计算是什么边缘计算是指允许在网络边缘、代表云服务的下游数据和代表物联网服务的上游数据进行计算的启用技术。在这里，我们将“边缘”定义为数据源和云数据中心之间的任何计算和网络资源。 边缘计算可以与雾计算互换，但是边缘计算更多地集中在事物方面，而雾计算更多地集中在基础设施方面。 边缘计算的优势在边缘计算中，我们希望将计算放在数据源附近。与传统的基于云的计算模式相比，这有几个好处。在这里，我们使用社区的一些早期结果来展示潜在的好处。研究人员建立了一个概念验证平台，用于运行人脸识别应用程序，通过将计算从云端移动到边缘，将响应时间从900 ms缩短到169ms。Ha等人使用Cloudlet卸载可穿戴认知辅助的计算任务，结果表明，响应时间在80-200ms之间，而且Cloudlet卸载还可以减少30%-40%的能耗。clonecloud在移动与云的结合分区、迁移与合并、按需实例化分区等方面，其原型可以为测试应用减少20倍的运行时间和能源。 案例研究云卸载在传统的内容交付网络中，只有数据缓存在边缘服务器上。这是基于内容提供商在互联网上提供数据的事实，这在过去几十年中是正确的。在物联网中，数据在边缘产生和消耗。因此，在边缘计算范式中，不仅应该在边缘缓存数据，还应该缓存应用于数据上的操作。 应用： 导航应用程序可以将导航或搜索服务移动到局部区域的边缘，在这种情况下，只涉及几个地图块。 可以在边缘节点上进行内容过滤/聚合，以减少要传输的数据量。 视觉辅助娱乐游戏、增强现实、互联健康等实时应用可以通过边缘节点快速响应。 视频分析由于数据传输延迟和隐私问题，云计算不再适用于需要视频分析的应用程序。 与单独的云计算相比，可以在每台边缘设备上利用数据和计算能力，并更快地获得结果。 智能家居下图显示了智能家居环境中Edgeos的一个变体的结构。Edgeos需要通过Wi-Fi、蓝牙、ZigBee或蜂窝网络等多种通信方式从移动设备和各种事物收集数据。来自不同来源的数据需要在数据抽象层中进行融合和按摩。 智慧城市 大数据分析：到2019年，拥有100万人口的城市每天将产生180 PB的数据。 低延迟 位置感知 边缘协作协作边缘将地理上分布的多个利益相关者的边缘连接起来，尽管这些利益相关者的物理位置和网络结构不同。这些特殊的连接边缘为利益相关者提供了共享和合作数据的机会。 例如医院会总结并分享某次流感爆发的信息，如平均成本、症状和人口等。理论上，患者会按照处方从药房获得药片。一种可能是病人没有接受治疗。然后医院必须承担再入院的责任，因为它不能得到病人没有服用药物的证据。现在，通过协作边缘，药房可以向医院提供患者的购买记录，这大大简化了医疗保健责任。 挑战和机遇可编程性通常，程序是用一种编程语言编写的，并为特定的目标平台编译，因为程序只在云中运行。然而，在边缘计算中，计算是从云上卸载的，边缘节点很可能是异构平台。在这种情况下，这些节点的运行时是不同的，程序员编写一个可能部署在边缘计算范式中的应用程序面临着巨大的困难。 命名在边缘计算中，一个重要的假设是事物的数量是巨大的。在边缘节点的顶部，有许多应用程序在运行，每个应用程序都有其自己的结构，说明如何提供服务。与所有计算机系统一样，边缘计算中的命名方案对于编程、寻址、事物识别和数据通信都非常重要。然而，边缘计算范式的有效命名机制尚未建立和标准化。边缘从业者通常需要学习各种通信和网络协议，以便与系统中的异构事物进行通信。边缘计算的命名方案需要处理事物的移动性、高度动态的网络拓扑、隐私和安全保护，以及针对大量不可靠事物的可扩展性。 数据抽象通过服务管理层的空气位置指示器，各种应用程序可以运行在消耗数据或提供服务的EDGEOS上。在无线传感器网络和云计算范式中，数据抽象已经得到了很好的讨论和研究。然而，在边缘计算中，这个问题变得更具挑战性。有了物联网，网络中会有大量的数据生成器，这里我们以一个智能家庭环境为例。在智能家居中，几乎所有的东西都会向Edgeos报告数据，更不用说在家里部署了大量的东西。然而，网络边缘的大多数东西，只定期向网关报告感应到的数据。 来自不同事物的报告数据具有不同的格式 有时很难确定数据抽象的程度 数据抽象的另一个问题是对事物的适用操作 服务管理 差异化：随着物联网部署的快速增长，我们预计将在网络边缘部署多种服务，如智能家居。 可扩展性：可扩展性在网络边缘可能是一个巨大的挑战，与移动系统不同，物联网中的东西可能是非常动态的。 隔离：隔离是网络边缘的另一个问题。 可靠性：最后但不是最不重要的，可靠性也是网络边缘的一个关键挑战。我们可以从服务、系统和数据的不同角度来识别可靠性方面的挑战。 隐私和安全 社区的隐私和安全意识。 从Edge上收集的数据的所有权。 缺少有效的工具来保护网络边缘的数据隐私和安全。 优化指标 延迟：延迟是评估性能的最重要指标之一，特别是在交互应用程序/服务中。 带宽：从延迟的角度来看，高带宽可以减少传输时间，特别是对于大数据（如视频等）。 能源：能源是网络边缘最宝贵的资源。 成本：从服务提供商的角度，如YouTube、Amazon等，边缘计算为他们提供了更少的延迟和能源消耗，潜在的增加投入和改进的用户体验。 结论现在，越来越多的服务被从云推到网络的边缘，因为在边缘处理数据可以确保更短的响应时间和更好的可靠性。此外，如果可以在边缘处理更大的数据部分，而不是上传到云端，那么也可以节省带宽。物联网和通用移动设备的迅速发展改变了EDGE在计算范式中的角色，从数据消费者转变为数据生产者/消费者。在网络边缘处理或按摩数据会更有效。 论文原文：Edge Computing: Vision and Challenges]]></content>
      <categories>
        <category>Reading Notes</category>
        <category>Service Computing</category>
      </categories>
      <tags>
        <tag>Service Computing</tag>
        <tag>Edge Computing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年10大战略性科技趋势7·8·9·10]]></title>
    <url>%2F2019%2F06%2F05%2F2019%E5%B9%B410%E5%A4%A7%E6%88%98%E7%95%A5%E6%80%A7%E7%A7%91%E6%8A%80%E8%B6%8B%E5%8A%BF7%C2%B78%C2%B79%C2%B710%2F</url>
    <content type="text"><![CDATA[2019年十大战略技术趋势 趋势7:区块链区块链是一种分布式账本。分布式账本是一个按时间顺序扩展的加密签名、不可撤销的交易记录列表，由网络中的所有参与者共享。 区块链通过消除业务摩擦提供业务价值，通过使分类账独立于单个应用程序和参与者来实现这一点，并在分布式网络中复制分类账，以创建基于共识的重大事件权威记录。 区块链还支持分布式信任架构，允许不受信任方进行商业交易，并使用各种资产创造和交换价值。 区块链承诺通过建立信任、提供透明度和减少业务生态系统之间的摩擦、潜在地降低成本、减少交易结算时间和改善现金流来重塑行业。 完整的区块链解决方案面临着关键挑战，这些挑战将成为2023年强大的可扩展解决方案的交付的巨大阻碍。区块链技术和概念是不成熟的，在关键任务和规模业务运营中无法被理解和验证。 尽管如此，到2030年，区块链将创造3.1万亿美元的商业价值。 区块链的实用方法发展需求： 清楚了解业务机会和潜在的行业影响 清楚了解区块链技术的能力和局限性 信任架构 实现技术发展所需的技能 趋势8:智能空间智能空间是一种物理或数字环境，在这种环境中，人类和技术支持的系统在日益开放、连接、协调和智能的生态系统中相互作用。多个元素——包括人、流程、服务和事物——在一个智能空间中聚集在一起，为一组目标人物或行业场景创造一种更加沉浸式、交互式和自动化的体验。 一段时间以来，这一趋势一直围绕着智能城市、数字工作场所、智能家居和互联工厂等要素展开。我们相信，市场正进入一个快速交付强大智能空间的时期，无论是作为员工、客户、消费者、社区成员还是公民，技术都将成为我们日常生活中不可或缺的一部分。人工智能相关趋势、物联网连接边缘设备的扩展、物联网和组织的数字孪生兄弟的发展以及区块链的成熟，为推动目标环境中更多的连接、协调和智能解决方案提供了越来越多的机会。 智能空间正沿着五个关键维度发展： 开放 Openness 互联 Connectedness 协调 Coordination 智能 Intelligence 有界 Scope 一看就明白，不多解释了。 趋势9:数字伦理和隐私数字道德和隐私正日益受到个人、组织和政府的关注。消费者越来越意识到他们的个人信息是有价值的，并要求控制。各组织认识到保护和管理个人数据的风险越来越大，各国政府正在实施严格的立法，以确保做到这一点。 任何关于隐私的讨论都必须以更广泛的数字道德和客户、参与者和员工的信任为基础。虽然隐私和安全是建立信任的基础组件，但信任实际上不仅仅是这些组件。正如牛津词典所定义的，“信任”是对某人或某物的可靠性、真实性或能力的坚定信念。信任是在没有证据或调查的情况下接受陈述的真实性。最终，一个组织在隐私方面的立场必须由其在伦理和信任方面的更广泛立场所驱动。从隐私到道德的转变将对话从“我们是否顺从”转向“我们是否做了正确的事情”。从合规驱动的组织到道德驱动的组织的转变可以被描述为以下几个意图层次： Mind compliance：作为层次结构中的最低级别，心理依从性是由外部驱动的，并专注于避免问题。在这里，企业根据允许的内容来决定技术的使用。如果没有反对建议的规则，就允许这样做。 Mitigating risk：这一级别的重点是企业愿意承担的风险，而不会对自身造成伤害。这包括评估对他人造成伤害的风险，以及“被抓住”做一些会导致公众尴尬和名誉风险的事情。 Makeing a difference：伦理考虑可以用来改变客户、行业甚至整个社会。对于商业企业来说，这意味着通过在道德之外创造价值主张来实现竞争差异化。对于公共部门机构来说，这可能意味着根据他们的期望为公民创造价值。 Following your values：这是指由你的道德指南针驱动的决策。你的品牌代表什么？你有什么公司价值观？你的“品牌许可”是什么？ 趋势10:量子计算一种商业化、价格合理、可靠的量子计算（qc）产品或服务可以改变一个行业。一个例子是药品，在药品中，新的药物化合物可以快速衍生，客户或人群的细分可以发生在地方政府、航空公司、零售和金融服务部门。在过去的两年里，Gartner对质量控制的调查每年增加了三倍多。引起这一兴趣的因素有三个： 量子计算控制对密码术的威胁 对量子计算的能力和特定应用的时间框架的好奇 量子计算作为竞争优势的潜在用途 量子计算的主要潜在应用包括： 优化。优化问题很可能是质量控制的第一个用例。质量控制优化可能有助于机器学习、人工智能和神经网络。他们的承诺是，随着技术的成熟，到2023年，他们将能够显著提高模式识别的加速。 材料科学。质量控制可用于分析复杂的原子相互作用，从而更快地发现新材料，从而实现新经济和新发现。创造新的可申请专利的材料是关键行业早期采用者的主要潜在利润来源。 化学。qc可以在原子尺度上实现量子模拟，允许设计新的化学过程。 个性化药物。质量控制可以用来模拟原子水平的分子相互作用，以加快新的癌症治疗药物上市的时间。质量控制可以加速并更准确地预测蛋白质的相互作用，从而产生新的药物方法。 生物学。qc可用于光合作用等过程的自然量子模拟，或用于模拟能量系统和相互作用。质量控制可以帮助加速新的或改进肥料的开发，帮助改善世界粮食来源。 许多挑战仍然存在： 量子误差。当谈到量子优势时，最小化量子误差是很重要的。将通用的门模型量子计算机扩展到实际的有用尺寸将需要加入量子误差校正方案。人们相信，当量子计算机达到100到300个逻辑量子比特，并且有些复杂的问题需要更多的解决时，就可以完成有意义的工作。 去相干。当一个量子系统不完全与环境隔离，而是与环境接触时，相干随时间衰减。这个过程叫做量子退相干。量子算法只在相干到位时执行。目前，只有很短的相干时间是可能的。 缺乏标准的开发语言。由于系统的量子性质，质量控制开发语言将与现有的开发语言非常不同。随着硬件的进步，招募和培训开发人员，建立产品的思想共享，使其成为标准，这是一场竞赛。 摘译自：https://www.gartner.com]]></content>
      <categories>
        <category>Gartner</category>
        <category>趋势</category>
      </categories>
      <tags>
        <tag>科技趋势</tag>
        <tag>Gartner</tag>
        <tag>战略研究</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年10大战略性科技趋势5·6]]></title>
    <url>%2F2019%2F06%2F04%2F2019%E5%B9%B410%E5%A4%A7%E6%88%98%E7%95%A5%E6%80%A7%E7%A7%91%E6%8A%80%E8%B6%8B%E5%8A%BF5%C2%B76%2F</url>
    <content type="text"><![CDATA[2019年十大战略技术趋势 趋势5:赋能边缘边缘计算描述了一种计算拓扑结构，其中信息处理、内容收集和传递更靠近这些信息的源和存储库。边缘计算借鉴了网格网络和分布式处理的概念。它试图将流量和处理保持在本地，目标是减少流量和延迟。因此，边缘内容交付的概念已经存在很多年了。“在哪里处理数据”的钟摆在高度集中的方法（如大型机或集中云服务）和更分散的方法（如PC和移动设备）之间摇摆。连接和延迟挑战、带宽限制以及嵌入在边缘的更大功能都有利于分布式部署模型。处理能力的优势和在超尺度下运行的低成本，加上管理和协调数千个地理上分离的端点的复杂性，有利于集中化模型。 当前对边缘计算的大部分关注来自于物联网系统向特定行业（如制造业或零售业）的嵌入式物联网世界提供断开连接或分布式功能的需求。拓扑的广泛应用以及明确的应用和网络体系结构还不常见。需要扩展系统和网络管理平台，以包括边缘位置和边缘功能特定技术。边缘计算解决了许多紧迫的问题，例如高广域网成本和不可接受的延迟。边缘计算拓扑结构将使数字业务和IT解决方案在不久的将来具有独特的优势。 边缘计算和云计算是互补的概念 趋势6:沉浸体验到2028年，用户体验将经历用户对数字的感知方式的重大转变。世界以及他们如何与之互动。对话平台正在改变人们与数字世界互动的方式。虚拟现实（VR）、增强现实（AR）和混合现实（MR）正在改变人们对数字世界的感知方式。这种感知和交互模式的结合转变将带来未来的沉浸式用户体验。这种模式将从一个懂技术的人转变为一个懂技术的人。翻译意图的负担将从用户转移到计算机上。通过许多人的感官与用户交流的能力将为传递细微信息提供更丰富的环境。 VR and AR虚拟现实和现实现实是分开的，但相关的技术。MR扩展了两种方法，以更强大的方式将物理世界结合起来。体验的视觉方面很重要，但其他感官模型也很重要，如触觉（触觉反馈）和声音（空间音频）。特别是在MR中，用户可以与数字和现实世界中的对象交互，同时在物理世界中保持存在。 虚拟现实提供了一个计算机生成的三维环境，它围绕着一个用户，以一种自然的方式响应一个人的行为。这通常是通过一个身临其境的头戴式显示器（HMD），阻止用户的整个视野。手势识别或手持控制器提供手和身体跟踪，并可结合触摸敏感反馈。位置跟踪使一个或多个参与者能够在没有位置的房间中行走。基于房间的系统提供了更深的沉浸感，为多个参与者提供了一种3D体验，或者一个人可以在没有房间的房间里行走。 增强现实是以文本、图形、视频和其他与现实世界对象集成的虚拟增强的形式实时使用信息。它是使用HMD或移动设备呈现的。虚拟世界元素在现实世界背景上的叠加将AR与虚拟现实区分开来。增强现实旨在增强用户与真实物理环境的交互，而不是将它们与实际物理环境分离。这个定义也适用于MR。一般来说，MR使人们能够与虚拟对象交互。 摘译自：https://www.gartner.com]]></content>
      <categories>
        <category>Gartner</category>
        <category>趋势</category>
      </categories>
      <tags>
        <tag>科技趋势</tag>
        <tag>Gartner</tag>
        <tag>战略研究</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年10大战略性科技趋势3·4]]></title>
    <url>%2F2019%2F06%2F03%2FGartner-2019%E5%B9%B410%E5%A4%A7%E6%88%98%E7%95%A5%E6%80%A7%E7%A7%91%E6%8A%80%E8%B6%8B%E5%8A%BF%EF%BC%883%EF%BC%8C4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[2019年十大战略技术趋势 趋势3:AI驱动开发人工智能驱动的开发探索了将人工智能功能嵌入应用程序的工具、技术和最佳实践的演变。它还探讨了如何使用人工智能创建开发过程中使用的人工智能驱动工具。 这一趋势正沿着三个维度发展： 用于构建人工智能解决方案的工具正在从面向数据科学家的工具（人工智能基础设施、人工智能框架和人工智能平台）扩展到面向专业开发人员社区的工具（人工智能平台和人工智能服务）。 用于构建人工智能供电解决方案的工具本身被赋予了人工智能驱动能力，帮助专业开发人员并自动化与人工智能增强解决方案开发相关的任务。 特别是，支持人工智能的工具正在从帮助和自动化与应用程序开发（AD）相关的功能发展到利用业务领域专业知识进行增强，并自动化更高层次的广告流程堆栈（从一般开发到业务解决方案设计）活动。 趋势4:数字孪生数字孪生是指现实世界实体或系统的数字表示。数字孪生兄弟的实现是一个封装的软件对象或模型，反映了一个独特的物理对象。来自多个数字孪生兄弟的数据可以在多个现实世界实体（如发电厂或城市）中聚合为一个复合视图。对现实世界中的实体或系统进行数字表示的概念并不新鲜。它的传统可以追溯到计算机辅助的物理资产设计表示或个人客户的配置文件。数字双胞胎最新迭代的区别在于： 模型在于它们如何支持特定的业务结果的健壮性 数字孪生兄弟与现实世界的链接，可能实时监控 应用先进的大数据分析和人工智能来推动新的业务机会 与他们互动并评估“假设”情景的能力 在物联网项目的背景下，数字孪生正在引起人们的兴趣。精心设计的数字孪生资产可以显著提高企业的决策能力。它们与现实世界中的对应物相关联，用于了解事物或系统的状态、响应变化、改进操作和增加价值。 摘译自：https://www.gartner.com]]></content>
      <categories>
        <category>Gartner</category>
        <category>趋势</category>
      </categories>
      <tags>
        <tag>科技趋势</tag>
        <tag>Gartner</tag>
        <tag>战略研究</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年10大战略性科技趋势1·2]]></title>
    <url>%2F2019%2F05%2F25%2FGartner-2019%E5%B9%B410%E5%A4%A7%E6%88%98%E7%95%A5%E8%B6%8B%E5%8A%BF(12)%2F</url>
    <content type="text"><![CDATA[关键发现： AI开启了数字业务的新方向 我们对技术的感知和互动方式正在发生根本性的转变 事物和流程的数字化正在更多的被用于监控、分析和控制真实世界的环境 确定技术趋势并依据对业务的潜在影响排列优先级可以创造竞争优势 建议：通过技术创新进行业务转型的公司架构和技术创新领导者必须： 探索基本上可以通过AI驱动的自主功能为组织内的任何物理设备或客户环境提供支持的方式 与高级商业领袖一起教育，参与和思考他们的战略相关优先事项以及AI可以自动化或增强人类活动的地方 开发和部署混合平台，将对话交互与虚拟，增强和混合现实相结合，以针对目标用例创建身临其境的用户体验 通过开发和优先处理有针对性的高价值业务案例来构建物理事物和组织流程的数字双胞胎，从而支持物联网计划 在量子计算仍处于新兴状态时，了解并监控它。 找出具有潜力的现实问题并评估其对安全的可能影响 战略规划预测到2021年，10％的新车将具有自动驾驶功能，而2018年则不到1％。到2020年，公民数据科学家的数量将比专家数据科学家的数量增长快五倍。到2022年，至少40％的新应用程序开发项目将在团队中拥有人工智能联合开发人员。到2021年，一半的大型工业公司将使用数字双胞胎，使这些组织的效率提高10％。到2028年，存储，计算和高级AI和分析技术将扩展边缘设备的功能。到2022年，70％的企业将尝试使用沉浸式技术进行消费和企业使用，25％的企业将其部署到生产中。到2030年，区块链将创造3.1万亿美元的商业价值。到2022年，超过50％在工业4.0生态系统中合作的人将使用虚拟助手或智能代理与周围环境和人们进行更自然的交互。到2021年，那些绕过隐私要求并且缺乏隐私保护的组织将比遵守最佳实践的竞争对手支付高出100％的合规成本。到2023年，20％的组织将为量子计算项目编制预算，而2018年则不到1％。 分析数字化转型会导致企业不断更新其业务模型。企业领导需要接受并鼓励不断的改变，这也是在未来变化世界中的成功之道。 在未来，所有的智能设备和智能终端会组成一个“智能数字网”，这会成为一个颠覆性的技术趋势，所有的创新型公司都要做好准备应对。智能数字网的三个核心主题： 智能。智能主题探讨了AI，特别强调机器学习，如何渗透到几乎所有现有技术并创建全新的技术类别。 数字。数字主题专注于融合数字和物理世界，以创造自然和身临其境的数字增强体验。 网络。网络主题主要开发人、业务、设备、内容、服务等之间的联系。 2019年十大战略技术趋势 趋势1:自主事物自主事物通过AI来自动化执行原本由人类执行的行为。不同于之前死板的程式化的自动化，自主事物可以更好的在人类环境下进行更自然的交互。 自主物理事物and自主虚拟事物自主物理事物的应用： 巡逻机器人 高级农业 更安全的载具运输 自主虚拟事物的应用： 虚拟个人助理 独立代理 自主能力的范围 人工辅助 部分自动化 条件性自动化 高级自动化 全自动化 自主、智能、协调 Intel在2018年冬奥会开幕式上使用无人机群 迪拜警方准备使用自己部署的无人机盯梢 自主智能汽车可以互相通讯协调以优化城市交通 群智智能助理可以通过集成多终端数据满足复杂需求 多代理之间的自动协调可以是IT操作变得更加流畅和安全 趋势2:增强分析增强分析包括： 增强数据准备。它使用机器学习自动化来增强数据分析和数据质量，协调，建模，操作，丰富，元数据开发和编目。 增强分析。这使得业务用户和公民数据科学家能够自动查找，可视化和叙述相关发现，而无需构建模型或编写算法。 增强数据科学和机器学习。它使用AI来自动化数据科学和机器学习/AI建模的关键方面，例如特征工程，模型选择（自动机器学习[autoML]），模型操作，解释，调整和管理。 赋能民间数据科学家到2020年，民间数据科学家的数量将比专业数据科学家的数量的增长快五倍。 在民间数据科学家之上更多地使用机器学习以及自动化和人工增强模型将意味着更少的偏差。它将减少用户浏览数据所花费的时间，使他们有更多时间根据数据采取最相关的见解。它还将使一线工作人员能够获得更多情境化的分析见解和指导性建议，以改进决策和行动。 行动起来 接受增强分析作为数据化转型策略的一部分 通过增强分析寻找机会 开发一种定位增强分析的影响的策略 摘译自：https://www.gartner.com]]></content>
      <categories>
        <category>Gartner</category>
        <category>趋势</category>
      </categories>
      <tags>
        <tag>科技趋势</tag>
        <tag>Gartner</tag>
        <tag>战略研究</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Reading Notes] A Service Computing Manifesto: The Next Ten Years]]></title>
    <url>%2F2019%2F05%2F22%2FReading-Notes-A-Service-Computing-Manifesto-The-Next-Ten-Years%2F</url>
    <content type="text"><![CDATA[ABSTRACT这份宣言的主要内容 确定阻碍现实世界中服务计算发展和潜在实现的主要障碍 提出服务计算的研究方向 制定路线图，使服务计算领域能够重新定义自己和 成为社会和经济活动的强大引擎之一。 推荐关注于4个主要研究方向 服务设计 service design 服务集成 service composition 基于众包的信誉 crowdsourcing based reputation 物联网 the Internet of Things BACKGROUND服务计算的定义我们将服务计算（或者称为面向服务的计算）定义为：探索或开发为服务提供广泛支持的计算抽象、计算架构、计算技术和计算工具的学科。 We define service computing (alternatively termed service- oriented computing) as the discipline that seeks to develop computational abstractions, architectures, techniques, and tools to support services broadly. 服务计算的来源在计算的早期阶段，面临的挑战是以机器可读的格式表示信息，该格式由位和字节组成，称为数据。 随着时间的推移，人们对用意义补充数据产生了浓厚的兴趣，从而将其转化为信息。随着计算技术的进一步发展，人们开始在信息中加入推理，从而产生了知识。最近，对更高抽象级别的需求导致了向知识添加行动，从而产生服务的概念。 服务计算的目标服务计算的最终目标是弥合IT和业务服务之间的差距，使IT服务能够更有效地运行业务服务。 The ultimate goal of service computing is to bridge the gap between IT and business services to en- able IT services to run business services more effectively and efficiently. 服务计算的目标是利用服务范例的功能和简单性及其功能和非功能组件来构建模块化软件应用程序，并为选择和组合服务提供更高级别的抽象，从而将其提升到第一类对象状态。 服务计算的相关机构和会议为了自动化组合服务资源，以根据用户的目标和偏好提供定制的IT服务，标准化机构，如万维网联盟（W3C）和结构化信息标准促进组织（OASIS），已经为实施服务系统领导了规范和标准化工作。 服务计算的挑战现有的Web服务标准和技术无法为关键新兴领域的计算需求提供足够的支持，包括移动计算，云计算，大数据和社交计算。这些是IDC命名的第三平台的四项关键技术，目前正在影响全球业务的格局。 服务计算和SOA的区别面向服务的体系结构（SOA）是一种独立于技术的框架，用于定义，注册和调用服务。 服务计算比SOA更广泛，包括对较低级别的服务数据管理和分析的业务流程建模，管理和分析的上层。 SOA已成为服务计算的核心概念，并为实现服务计算提供了基础技术。 服务计算和传统计算的区别 服务计算的驱动因素是将服务计算与技术分离，以实现面向服务的系统，充分利用服务计算的承诺和期望 这项工作强调服务计算对计算新兴趋势的贡献和影响 CHALLENGES IN SERVICE COMPUTING RESEARCH 当前的服务计算研究主要集中在七个问题领域：架构，规范语言，协议，框架，生命周期，服务质量，以及跨越自治企业边界建立信任和声誉。 current service computing research focuses mostly on seven problem areas: architecture, specification languages, protocols, frameworks, lifecycle, quality of service, and the establishment of trust and reputation across the boundaries of autonomous enterprises. 服务计算中经常被忽视的战略挑战是分析为什么服务计算尚未在现实世界中发挥其全部潜力，以及需要采取哪些措施来改变这一点。 一项重大挑战是实现在不同平台上工作的多个组织的无缝合作，以满足消费者的需求。 我们确定了服务计算中的四个新兴研究挑战：服务设计，服务组合，基于群体的声誉和物联网（IoT）。 We identify four emerging research challenges in service computing: Service Design, Service Composition, Crowdsourcing-Based Reputation, and the Internet of Things (IoT). Challenges in Service Design服务设计是关于对服务性质及其关系的正式理解的映射。 现有设计方法： 通常不会考虑到服务系统固有地将自治部件集合在一起这一事实 没有任何全面的理论框架来定义和分析Web上复杂的服务系统 Challenges in Service Composition由于需要对大规模的Web和云服务进行组合，有以下几个挑战： 准确有效地从这些大型存储库中搜索服务正成为一个至关重要的挑战 现有服务选择，组合和推荐方法都是在假设静态数据环境下运行的，这是不充分的 从众多不断变化的设备和服务中选择和组合服务，以实时和上下文感知的方式满足用户需求 基于社会关系的服务构成构成了根本的严峻挑战 Challenges in Crowdsourcing-Based Reputation 众包的质量。鉴于声誉受到若干相关因素的影响，因此强烈需要预测众包声誉的结果。目前尚不清楚这些因素如何影响众包的质量。 众包贡献者的可信度。一些服务用户的意见可能是不公平的，甚至是对特定服务产品的恶意。 测试平台。对设计适当的评估指标以比较服务的信任和信誉模型存在强烈需求。 Challenges in the IoT物联网（IoT）是一个新兴和有前景的领域，它建议将每个有形实体转变为互联网上的一个节点。 物联网提出了两个基本挑战：（1）与事物的沟通（2）事物的管理。 一个挑战是资源有限，传统标准（如SOAP和BPEL）太庞大，无法应用于物联网。 此外，由于架构差异，现有的服务组合模型不能直接用于物联网互操作。与单类型Web服务组件模型（即，服务）相反，IoT组件模型是异构的和多层的（例如，设备，数据，服务和组织）。与传统设置相比，组件的所需功能更具动态性和上下文感知能力。 与服务计算相关的基本物联网挑战包括： 持续维护物联网设备的网络个性和环境。 特别是，物联网事物需要具有反映其物理空间的Web身份和Web表示（例如，Web代理）。 他们还需要在社交，环境，以用户为中心和应用程序环境中进行连接和通信，并且需要维护和管理此类上下文。 不断发现，集成和（重新）使用物联网事物及其数据。 具体而言，物联网环境是一个联合环境，其中事物及其数据，云服务和IT服务（例如，用于数据分析和可视化）通常由具有不同接口的独立提供商以及业务，成本提供。 和QoS模型。 为了提供新的互联网规模的服务，物联网必须（重新）使用他人部署的物联网和其他人为自己的目的收集的数据。 SERVICE COMPUTING RESEARCH ROADMAPService Design服务系统的设计应建立在正式的服务模型之上，以便能够有效地访问具有不同功能的大型服务空间。 服务模型支持不同服务及其操作之间的依赖关系非常重要。 总之，满足上述要求的正式服务模型将成为通过服务提供高效透明的计算资源访问的中心，这是充分发挥服务计算潜力的关键一步。 特别是，服务的三个关键特征至关重要：功能，行为和质量。 功能由服务提供的操作指定; 行为反映了如何调用服务操作，并由服务操作之间的依赖性约束决定; 质量决定了服务的非功能特性。 Service Composition几个研究方向： 大规模的Web和云服务组合。 服务组合研究应扩展到由纯文本描述的非WSDL描述的服务或服务。 大数据驱动的服务组合。当前大数据研究的一个重要主题是开发在线处理数据的算法和模型 基于社交网络的服务组合。大规模社交网络中的服务选择，推荐和组合应该结合社交网络和复杂的网络分析方法以及信任计算技术。 一个有希望的方向是结合记录服务用户与服务数据的交互的社交网络数据，以检测服务之间的隐藏关系并生成潜在的服务组合。可以通过捕获用户个人判断的社交媒体服务来提取反映用户选择和组合服务的兴趣的特定于域的质量特征 云计算环境为部署服务提供了一个有吸引力的选择，因为它提供了潜在的可扩展性和可访问性。 但是，它引入了与以下问题相关的问题： 维护 - 资源不受服务提供商的明确控制。 安全性 - 云可能不在服务提供商的企业边界内。 服务级别协议（SLA） - 资源分配是云提供商的责任。 例如，服务可能不可用，不仅是由于服务提供商的更新，还因为云提供商的更新。 Crowdsourcing-Based Reputation 众包的质量。应进行社会研究，以调查这些利益因素对众包可靠性的影响以及众包贡献者的范围。这两种因素，例如社会关系和个人偏好，可以同时相互影响。 未来的研究应该针对如何模拟两组因素之间的相互关系以及如何将它们整合起来预测它们对众包数据质量的影响。 众包贡献者的可信度。还应探索用于选择具有不同成本和可信赖的众包用户的权衡策略。 Internet of Things物联网研究的新方向在于设备发现和集成领域。一个有趣的方向是多跳连接，它利用人与物之间的相互作用来关联物联网事物。 CONCLUSION服务计算拥有光明的未来，支持新兴计算领域的巨大进步，如移动计算，云计算，大数据，社交计算等。 我们在本宣言中提出，服务计算的潜力远远大于迄今为止所取得的成就。 我们为将服务计算提升到创新的新高度铺平了道路。 为了开拓进取，我们做出了一个重要的声明，即，要使服务计算范例取得成功，就需要将其与当时的技术分离开来。 挑战可能很困难，但收益很大，没有理由为什么雄心勃勃的研究议程不会给计算机科学和社会带来巨大的好处。]]></content>
      <categories>
        <category>Reading Notes</category>
        <category>Service Computing</category>
      </categories>
      <tags>
        <tag>Service Computing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]109个数据指标，全方位剖析零售业]]></title>
    <url>%2F2019%2F05%2F11%2F109%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%8C%87%E6%A0%87%EF%BC%8C%E5%85%A8%E6%96%B9%E4%BD%8D%E5%89%96%E6%9E%90%E9%9B%B6%E5%94%AE%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.gzjundian.com/show-19-93-1.html 如何能让你的分析报告真正为企业带来价值？如何拉近一套数据与实际生活生产之间距离，做到报告从数据中来、分析到业务中去？今天我们就零售行业中涉及到的三大块业务，探究如何为零售企业做切实有用的分析报告。 众所周知，人、货、场是零售业基本的思维模式。无论是线上还是线下，人、货、场都是零售营运的核心三要素。我们今天的探讨就从零售行业的人、货、场三个维度开始思考。 人包括店铺员工、顾客和第三方人员等；货泛指商品；场指卖场、电子商务的销售平台、渠道等，因此，零售业常用的分析指标有： 人货场只是第一个层次，员工、顾客、卖场、商品等为第二层。 一、“人”的部分1.销售指标【成交率】=成交顾客数÷客流量×100% 成交率和店员和销售技巧、产品陈列、产品销售价格、促销价格等都有关系。但是在产品、促销状态等都一致的情况下，成交率就只和店员的销售技巧有关了，所以这个指标可以用来判断店铺员工的销售能力。 【完成率】=销售完成数÷目标数×100% 这是一个判断销售目标进度的一个指标，在人货场三个领域都可以用到。 2.服务指标【平均成交时长】=每一位顾客成交的时间总和÷成交顾客数 这是一个考察店铺员工效率的指标。一般还需要和客单价结合起来看会比较客观（可以做四象限），用最短的时间成交最高的金额，这样员工一般认为都是最优秀的员工。 【平均接待时长】=接待每一位顾客的时间总和÷接待顾客数 目前需要店铺手动计算这个指标。还有一个指标和平均接待时长类似，就是顾客平均停留时长。区别是前者是从开始接待顾客到离开店铺的时间段计算时长，后者是用顾客进门到出门的时间段来计算的。这两个指标同样不仅仅和“人”有关，还与“场”“货”有关。对于零售店铺来说大部分时候是希望顾客的停留时间越长越好。 【投诉率】=投诉的顾客总数÷顾客总数×100% 3.管理指标【定编满足率】=实际员工总数÷标准配置人数×100% 这是考核企业招聘能力强弱的一个指标，同时它也是一个内控指标。定编满足率太低势必会影响效率，太高且超过100%又会造成人效的浪费。定编满足率还可以细分为部门定编满足率、普通员工定编满足率、管理层员工定编满足率等。 【员工流失率】=某段周期内流失员工数÷（（期初员工总数+期末员工总数）÷2）×100% 员工流失率分月流失率、季度流失率、年流失率等。处在不同周期的流失率是不能直接对比的。人事部经常用的是员工离职率，员工流失率和员工离职率有一点点区别，员工离职指正常人才转移，而员工流失包含不正常人才流失。 【工资占比】=企业支付的员工工资总额÷销售额×100% 4.顾客指标【客单价】=销售总金额÷有交易的顾客总数 一般用成交总笔数来代替顾客总数，理论上这两个数字是一致的，但是顾客经常会出现逛一次商场多次开单交易的情况，所以成交笔数实际上是大于等于有交易顾客数的。客单价既可以反映顾客的质量，也可以反映店铺员工的销售能力，还可以反映店铺的商品组合等。 【件单价】=销售总金额÷销售总数量 【连带率】=销售总数量÷成交总单数 连带率有不同的称谓，例如附加值、效益比、平均客件数、购物篮系数等。连带率反映的是顾客每次购物的深度。对于超市来说，除了分析常规连带率之外，还可以分析单品连带率、品类连带率，连带率越大说明该单品或品类越重要，需要在陈列、促销、库存管理等方面特别关注。百货行业还可以统计叫品牌连带率的指标，即计算顾客每次购物时平均消费几个品牌的产品。 5.会员指标【新增会员数】=期末会员数—期初会员总数 如果将会员看成是企业的财富，新增会员就是在不断地积累财富。大部分零售企业会把这一项作为店铺员工KPI考核指标之一。新增会员数的一个附加指标是未办卡率，统计那些达到会员办卡条件却没有开新卡的顾客占比情况，这个指标可以反映店铺开新卡的能力以及顾客对品牌的喜好程度，这是一个分析指标，不建议作为考核治疗。 【会员增长率】=某段时间内新增会员数÷期初有效会员数×100% 会员增长率是体现企业会员增长速度的一个指标。 【会员贡献率】=会员销售总金额÷销售总金额×100% 会员贡献率不是越高越好，在每个企业会有一个合理的区间，太高就显得新增顾客太少，增长被局限了，太低则没有稳定的销售来源。行业不一样这个区间段也会不一样，店铺间也会不一样，例如商业区的店铺和写字楼、社区店铺的会员贡献率都是不一样的。 【有效会员数】 【有效会员占比】=有效会员数÷累积会员数×100% 会员总数多不一定强，有效会员数多才是硬道理。有效会员就是满足一定贸易条件的会员。随着企业的发展，必然会存在很在一段时间内没有交易过的会员，这些会员实际上已经没有任何的价值了，需要在分析中剔除出去，否则会员分析也没有意义。有效会员的贸易条件一般根据时间和交易量来设定，例如在12个月内必须有至少1次消费，6个月内必须有不少于3次消费记录等，这两个设定标准需要结合顾客的消费频率来定，行业不同标准也会有差异。 【会员回购率】=某段时间内有交易的老会员数÷期初有效会员总数×100% 会员回购率一般用在月、季和年度的分析上，是衡量顾客忠诚度的一个指标，严格地说这是一个老会员的回购率公式，因为期间新增会员的回购不包含在其中。 回购率和回头率常被误解为一回事，其实会员回购率和会员回头率是有区别的，回头率公式中的分子应该是某段时间内到达过店铺的会员，他们不一定实施了购物。对于店铺来说，先得让顾客回头，其次才是回购，所以这个两个指标是有先后顺序的。没有高的回头率，哪来的高回购率，所以零售商们都在想尽办法促使会员顾客高频次地回头。 【会员流失率】=某段时间内流失掉的会员数÷期初有效会员总数×100% 这个指标反映了会员顾客的流失速度，也反应了企业营运现状，它和会员增长率是一对相向指标，建议每月都追踪这两个指标。会员流失有它合理的一面，例如对定位在20~30岁的服装品牌来说，顾客年龄变大自然就会流失，再如对超市来说，如果顾客搬家了，流失也是合理的。 会员流失率反应了顾客总量的流失情况，却没有办法反映出流失顾客的质量，流失掉一个客单价为300元和流失掉客单价为3000元的顾客显然不能划等号。这就衍生出一个新的指标，相对会员流失率，公式如下： 【相对会员流失率】=某段时间流失的会员数量÷期初有效会员数×流失率权重值×100% 【流失率权重值】=流失会员的平均客单价÷有效会员的平均客单价 【会员回购频率】 【会员回购频率1】=某段时间内所有会员消费次数÷（期初有效会员总数+期中新增会员数） 【会员回购频率2】=某段时间内所有老会员消费次数÷期初有效会员总数 该指标反映会员顾客在某个时间段内的消费频次，分析这个指标选取合适的时间周期很重要，时间周期太短，这个值基本上就接近为1.0，没有丝毫意义。服装专卖店、手机专卖、电器专卖等可按6或12个月为一个滚动周期，百货商场一般用3或6个月为一个滚动周期，超市可以按1或者3个月来滚动分析。3个月为一个滚动周期并不是数一个季度才分析一次，而是每个月都可以分析。 【会员回购频率3】=某段时间内所有会员消费次数÷期间有交易的会员总数 【会员回购频率4】=某段时间内所有老会员消费次数÷期间有交易的老会员总数 这4个公式各有侧重，公式1或2侧重于研究回购频率的趋势，公司3和4侧重短期会员购物行为分析，零售企业在实践使用时应该以老会员的分析为主。 【平均年龄】=某个事件点会员年龄总和÷有效会员总数 平均年龄是衡量品牌定位的一个标准，不过这个指标收数据源的影响非常大。有很多顾客不愿意提供自己的私人信息，还有就是终端店员不负责任地录入数据，所以在系统中很可能看到上有古稀老人，下有婴儿的年龄数据。分析平均年龄时需要剔除这些异常数据，否则那些90岁以上的顾客就足以把平均年龄拉大好几岁。对年龄的扩展分析是将顾客年龄分段分析，就是年龄分析。平均年龄属于对顾客基础信息分析的范畴，这个范畴还包括性别、职业、地域、收入等。 二、“货”的部分正如“人”“货”“场”是零售分析的基本思维模式一样，商品分析也有它的基本模式，这就是“进”“销”“存”，“进”即为采购环节，“销”自然是销售环节，狭义的“存”指商品库存管理环节，广义的“存”指整个商品的供应链管理。人货场是一个平行关系，而进销存却是一个又先后顺序的三角关系，前者是基于业务的分析管理，后者是基于商品的流程管理。大部分零售业的POS系统都是基于进销存的一种软件系统。 某种商品的库存太大、占用资金，我们常常理所当然地认为是采购进货不合理，进得太多，所以采购部经常背黑锅。其实销售环节和供应链环节都会影响库存，例如商品在卖场陈列不合理，仓库发货不及时，盘点错误造成系统显示有库存而实际库存为0等。所以分析商品的问题务必从进销存三个维度进行思考，不能一遇到问题就武断地认为是进销存某个环节的问题。 商品的分析指标很多，常用的如商品的折扣率、动销率、周转率等，还有商品的三度（广度、宽度、深度）等。一般来说大店看重商品的周转，小店看重商品的单词利润，线上看重商品的折扣，线下侧重商品的库存。大家的侧重点不同，不过总体来说商品的分析如图所示。 1.采购环节（1）采购三度【广度】 广度=采购的商品品类 广度比=采购的商品品类数÷可采购的商品总品类数×100% 广度关系到商品品类多样化，很多追求消费者一站式购买的卖场就是追求大广度。例如一个服装专卖店，公司当季商品有20个品类，买手实际采购了16个品类，则广度为16，广度比未80%。再比如一个中型超市有200个品类的商品在销售，可供销售的总品类数是300个，则广度为200，广度比为67%。商品的广度体现了商品的丰富程度。广度也不是越大越好，这和零售店铺的消费群体有关，也和营运成本有关，所以最佳的广度是指用最经济的成本且最能满足目标消费群体绝大部分需求的值。 【宽度】 宽度=采购的SKU总数 宽度比=采购的SKU总数÷可采购的商品SKU总数×100% 商品的宽度代表了商品的丰富且可供选择的程度，宽度越大的店铺消费者挑选的余地就越大。而宽度比则是反应和竞争对手宽度、自己目标宽度或上游供应商宽度的对比程度。例如对于一个化妆品专卖店来说，店铺共有1000个SKU商品在销售，而最大的竞争对手同期销售的商品是1500个SKU，则该专卖店商品的宽度为1000，相对于竞争对手的宽度比67%。由于资源局限性，大型超市等一般会限定商品的宽度值，所以就会出现每新增一个商品必须要剔除一个旧品的规定。电子商务网网站则相对宽松一些，他们的陈列没有实体零售店铺的空间限制，所以理想状态下宽度是可以做大无限大。 【深度】 深度=采购的商品总数量÷采购的SKU总数 深度比=深度÷采购目标深度×100% 深度是指平均每个SKU的商品数量，它的意义代表了商品可销售的数量的多少，比如某个服装专卖店某次采购了400个SKU的商品，一共1000件，则深度为2.5。深度越大越不容易缺货，但是也可能会造成高库存。 （2）覆盖度（也叫铺货率）覆盖度=有某款或品类产品销售的店铺数÷适合销售该产品的总店铺数×100%商品的覆盖度指标适合连锁性质的公司使用，它是衡量商品铺货率的一个指标，需要注意覆盖度公式的分母不是总店铺数，而是适合销售该产品的总店铺数，二者差距较大。一般来讲，覆盖度越大商品的销售就会越好。 （3）采销匹配度采销匹配度不是一个具体的指标，它实际上是一种分析方法。通过对比品类、型号、价格等方面在某段销售周期内采购和销售的比重来判断商品销售进度的一种方式。 2.供应链环节（1）服务指标【订单满足率】=订单中能够供应的商品数量总和÷订单商品数量总和×100% 例如物流部收到5张订单供1000件商品，由于缺货等原因实际可以发出的商品只有920件，则订单满足率就是92%。这是一个反应仓库缺货状态的指标，对于连锁企业来讲，100%的订单满足率是一个理想状态，一般都达不到。如果真能够做到100%满足率，意味着不但需要预测非常准，还需要增加更多库存来满足突发订单，这样的代价就是仓储成本增加，资金成本增加，这也是一种资源的浪费。 【订单执行率】=能够执行的订单数量÷总订单数量×100% 某天物流部收到100张订单，但是其中10张订单由于缺货或其他原因不能执行，则订单执行率90%。仓库缺货，物流配送（有货但是送不出去）等都会影响这个指标。 订单满足率和订单执行率的区别是，前者计算的是商品数量的满足情况，后者计算的是订单数量的执行情况。后者常常被很多企业作为订单满足率，这其实是不严谨的。订单满足率侧重用来衡量商品库存状况，订单执行率侧重用来衡量储运状况。 【准时交货率】=准时交货的订单数÷能够执行的订单总数×100% 准时交货率是一个反应供应链效率的指标，需要注意的是分母并不是订单总数，而是能够执行的订单总数，对于那些不能执行的订单去计算他们的准时交货率是非常滑稽的一件事。计算准时交货率的前提是先要明确什么是“准时交货”，24小时？48小时？还是根据距离远近区别对待？ 【订单响应周期】=系统中收货时确认的时间-系统中下订单的时间 一张订单的处理是从客户在系统中下订单（对于非系统下单的情况，就应该以收到订单的时间来准）开始到确认收货这样的一个完整的流程，这是一个反应供货效率的指标，一般计算平均订单响应周期。需要注意的是，随着新客户的不断增加、客户类型的变化等，平均订单响应周期自然会发生变化。所以平均订单响应周期变长和供应链效率降低并不能划等号，要进一步分析数据突变的原因。 在实际分析过程中还需要结合订单区域、产品类型、客户类型等进行详细分析。 （2）管理指标【库存周转率】 库存周转率1=出库数量÷（（期初库存数量+期末库存数量）÷2） 库存周转率2=销售数量÷（（期初库存数量+期末库存数量）÷2） 公式1是从供应链管理角度的指标，公司2是对公司销售周转率的衡量，二者是有区别的。一件商品一般只会被销售一次，但是因为退货回仓库的原因而会有大于1次的出库情况。“（（期初库存数量+期末库存数量）÷2）”这部分也可以用评价库存来代替，就是每月的平均库存。用平均库存的好处是营运人员投机取巧拉高周转率的难度加大，有的营运人员会在期初和期末这两个时间节点故意压低库存，甚至是牺牲销售的前提下压低节点库存，如果计算12个月的平均库存则投机难度就非常大了。 【物流成本占比】=物流成本÷（（期末库存金额+期中库存金额）÷2）×100% 广义的物流成本包括仓储成本、运输成本、管理成本等。狭义的物流成本仅仅指运输成本，狭义的物流成本占比就是运输成本和所运输的商品总值的比。 【客户投诉率】=客户投诉率=客户投诉订单批次÷订单总数×100% 这个公式很理解，但是在实际操作中缺失错误百出。问题出在公式的分子和分母的不对等上面。 （3）库存指标【期初库存、期末库存、平均库存】 平均库存=（期初库存+期末库存）÷2 年平均库存还可以直接取每月末库存的平均值，一般财务部习惯用期初加期末除以2的计算方法，销售营运部喜欢用平均库存的算法。 【库存天数】=期末库存金额÷（某个销售期的销售金额÷销售期天数） 库存天数是一个极为重要的库存管理指标，是有效衡量库存滚动变化的量化标准，也是用来衡量库存可持续销售时间的追踪指标。 我们可以用库存天数来判断店铺是否有缺货的风险，某个店铺的安全库存天数是45天，如果实际库存低于这个值则有缺货风险，反之则表示库存过大。这个指标既可以计算整体企业的库存天数，也可以计算每个品类或单品的库存天数，在分析具体问题的时候，常常需要结合起来看。另外，有些企业喜欢用库存周数的概念，实质是一样的，将库存天数除以7即为库存周数。一般来讲快速消费品行业使用库存天数，耐用消费品使用库存周数。 【库销比】=期末库存金额÷某个销售期的销售金额×100% 库销比的销售周期一般取月，也就是月库销比，当然也可以取周，如果是周库销比实际上就是和库存周数一个概念。月库销比在年度同比的时候是有参考价值的，但是在环比时就有问题了，因为每个月的天数是不一致的，有28天、29天、30天和31天4种情况，销售期不同销售金额就会不同，这样的月库销比实际上是没有可比性的。而库存周数和库存天数就不存在这个问题，所以我一般很少用这个指标。 【有效库存比】=有效库存金额÷总库存金额×100% 要计算有效库存比首先需要定义有效库存的标准，有效库存是指能给门店带来销售价值的商品库存，也就是能产生销售贡献的商品库存。从定义上看残次商品、过季商品和没有销售的商品都不属于有效库存商品。不过在实际上的分析过程中有效库存的确会复杂很多，首先需要剔除残次商品、过季商品、一段时间内没有销售的商品，然后再确定一个标准值将有销售的商品分成有效库存和无效库存，这个标准一般以周销售量或月销售量来衡量，并且渠道不同标准是不一样的。 确定有效库存的标准可以利用二八法则来辅助计算，占总销售20%的商品的平均销量值即为有无效库存的分界线。当然也可以人为确定这个分界线的值。 3.销售环节（1）商品指标【货龄】=商品的年龄 对于有保质期的商品，例如食品、饮料等，货龄是从生产日期开始计算的，对于没有严格保质期或有效期的商品，例如服装、手机等，货龄应该是从开始上架销售的日期开始计算的。分析货龄目的一是防止商品过期，二是作为制定商品价格调整的依据。货龄越大，库存越高的商品就是价格调整的首选。 【售罄率】=某段时间内的销售数量÷（期初库存数量+期中进货数量）×100% 售罄率是检验商品库存消化速度的一个指标。一般采取期货制订货的企业，如鞋服行业用得比较多，可以随时补货的快速消费品一般不同这个指标。特殊时期的囤货制也可以使用售罄率这个指标，例如包销或买断销售都属于囤货制。根据销售期的不同，一般有周售罄率、月售罄率、季售罄率、季末售罄率等。季末售罄率指整个商品消化期的销售数量和商品的总到货数量的比值。 【折扣率】=商品实收金额÷商品标准零售价金额×100% 商品的折扣率直接影响到企业的利润水平，是企业的生命线，但遗憾的是很多企业只是在财务报表中才有这个数据。财务报表只是一个结果，折扣率更应该是一个营运指标，需要定期追踪它是否正常、分析趋势是否向坏等。 【动销率】=某段周期内销售过的商品SKU数÷（期初有库存的商品SKU数+期中新进商品SKU数）×100% 动销率的统计周期一般是周、月、季度，分析的对象可以是品类、类别、SKU等。动销率属于一个追踪和管理指标，一般传统零售比较重视这个指标，动销率都比较高。但是电子商务由于追求长尾效应，动销率都比较低，不过最近有些电子商务也开始重视这个指标了。 【缺货率】=某个周期内卖场有缺货记录的商品数÷（期初有库存的商品数+期中新进商品数）×100% 对于供应链的缺货分析建议使用【订单满足率】，这里的缺货率主要是针对销售端的缺货，适用于采购部和销售部。注意这个缺货率是分析缺货的商品比率，不是缺货的数量或金额多少（缺货数量和缺货金额很难量化）。缺货率比较难以统计的是缺货记录，POS系统弱的门店只能靠人工统计，软件系统好的客户可以通过设置商品零库存状态用来自动判断是否缺货。库存为0一般是缺货，但是库存大于0的商品也可能是“缺货”状态，因为这里的库存很可能是残次或虚假库存，实际可供销售的库存为0，这种情况比较难以统计，需要人工加系统的方法来识别。缺货率中的销售周期最短可以是1天，最长不建议超过1个月。在计算年平均缺货率的时候可以计算月缺货率的平均值。 （2）结构指标【品类结构占比】=某品类销售额÷总销售额×100% 【价位段占比】=某价格段销售额÷总销售额×100% 【正价销售占比】=正价商品销售额÷总销售额×100% 正价商品为标准零售价的商品，与之对应的是折扣商品或特价商品。正价商品销售占比越高，企业利润越高。对于促销频率高的行业，以及有议价空间的行业（如手机专卖店）等该指标显得尤为重要，它是员工销售能力和企业管理水平的综合体现。但遗憾的是很多企业只重视折扣率，而忽视了这个指标。 （3）价格体系指标【商品现值】 商品现值就是商品当前被消费者认可的价值。一台手机刚出来时售价是4000元，一年后消费者可以接受的零售价只有2800元，这个2800元就是这台手机目前的现值。随着时间的流逝，新机型的推出，手机现值还会不断变化着。商品价格会随着时间流逝而变化的商品适合用商品现值的概念来管理，例如服装、手机、食品等。 【价格弹性指数】 价格弹性指数是商品价格变化1%时，商品销量变化的百分比。例如某款商品价格下降1%时，销量就上升5%，则价格弹性指数就是5.0%。价格变动时不光会影响到自身的销量变化，还会影响到竞争对手的销售变化。所以还有一个品牌间的价格弹性指数，品牌A相对于品牌B的价格弹性指数为4.2，这表示品牌A的价格每下降1%便能够从品牌B那里抢到相当于品牌B4.2%的销量，也就是品牌B销售会下降4.2%。确定商品的价格弹性指数最好的方法是最随机测试。 （4）畅滞销分析【前十大销售及占比】 前十大销售就是在所有商品中销售额或销售量最好的十个商品的总销量，前十大商品占比也就是他们的销售额或销售量占总销售量的比重。这是一个常规分析指标和追踪指标，除了对总销售进行前十大排名分析外，还可以对具体的类别进行同样的分析。 前十大商品销售占比越大，商品销售就越集中，销售管理更容易，但是销售风险也会加大。很多电子商务的卖家非常追求爆款，恨不得前三个商品就能占到公司总销售的80%以上。爆款一般综合毛利都偏低，且一旦生产或物流环节出现状况，对企业的销售影响可能是致命的。 【前十大库存及占比】 和前十大销售及占比概念一样，只是前者是基于销售，后者是基于库存。这是一个库存管理指标，同样是看趋势，看数据是否异常。 【滞销品销售占比】 滞销商品销售占比指的是滞销商品占总销售的比重，同理还可以演化出一个滞销商品库存占比。 4.售后环节【退货率】 退货率1=某个周期内退货数÷总销售数×100% 退货率2=某个周期内退货单数÷总销售单数×100% 退货率公式非常简单，不过它和【客户投诉率】有一个同样的问题，就是本周期内的退货数并不一定来源于本期内的销售即不含在分母中。处理方法同客户投诉率一样有三种方法：综合处理法（不考虑退货单的来源问题），追踪来源法（将退货单还原到发货期进行分析），剔除法（将非当日退单剔除再计算退货率）。 【特殊服务率】=特殊服务的顾客÷总销售顾客数×100% 有些零售店铺为了提高顾客的体验感，会搞一些特殊的服务活动，例如有的服装专卖店有免费熨洗服务，有些电器商场有以旧换新的服务等，这个指标就是用啦检验这种服务效果的。 【残损率】=残损商品数÷商品总数×100% 残损商品会影响企业和门店的销售和利润，残损率不仅仅是一个分析指标，它更应该是一个追踪指标，并且还应该根据残损商品的来源进行分析，找到残损的主要原因，是仓储残损率高，还是销售渠道残损率高等。 三、“场”的部分1.销售额【时段、日、周、月、季度、年】 月销售额指标、季度销售额指标、年销售额指标这是最常用且和绩效挂钩的硬指标。日和时段指标往往不受管理层重视，其实这是不合理的。零售行业的销售是靠一个个时段、一天天追出来的，没有基础指标的完成，谈何月、年指标的完成？ 【预测额】 一般分为【日销售预测额】、【月销售预测额】和【年销售预测额】，日销售预测在大型百货商场、超市、电子商务的销售中经常使用，对日销售进行预测，只需要根据历史数据中每日各个时段的销售百分比就可以计算出来。月和年的预测，前面已经讲解过了。 2.追踪指标【进店率】=进店人数÷路过人数×100% 进店率公式并不难，难的是如何提高进店率，此时各位又可以搬出人货场的思维模式来操练一下。进店率有个系统误差，就是店铺工作人员的进出会影响精度，可以统计工作人员每天大致的重复进店次数然后在进店人数中扣除。 【上楼率】=本层向上的顾客数÷进入本层的顾客数×100% 有5000名顾客进入首层，总共有3000名顾客上到二层及以上楼层，则一层的上楼率为60%。上楼率对多层经营的卖场来说是一个非常重要的指标。 【接触率】 随着科技的发展，管理更多精细化，接触率越来越受零售商重视，通过它可以深层次地了解顾客的购买行为。接触率就是消费者和商品的接触比率。又可以分为试穿率、试用率、触摸率等。 （1）【试穿率】=试穿顾客数÷进店人数×100% 这个指标常用语鞋服行业，目前还没有发现有仪器能监控此指标，大多靠人工统计，需要注意的是同一个顾客无论试穿多少次都只能统计一次。 （2）【试用率】=试用顾客数÷进店人数×100% 这个指标常用于化妆品、食品等行业，如果是封闭销售（例如专卖店）则用进店人数作为分母，不过这些行业大多在超市和百货商场开放式销售，所以进店人数可以转换为有接触的顾客数（例如和促销人员有语言交流的或者是驻足一段时间的顾客），绝对不能轻易用路过人数。 （3）【触摸率】=触摸某商品的顾客数÷路过某商品的人数×100% 触摸率反应商品外观被关注的程度，目前借助一些视频设备可以自动采集这个数据。一般来说某商品的触摸率和成交数量成正比，但是有时候触摸率很高，但是交易很低，作为管理者可能需要分析这种现象产生的原因，为什么消费者有冲动而无行动，出现这种情况很大可能是价格原因。 【成交率】=成交顾客数÷进店人数×100% 【完成率】=完成数÷目标数×100% 完成率根据统计时间段的不同又可以分为实时完成率、滚动完成率、累积完成率、预测完成率。 【大宗交易占比】=大宗购物金额÷总销售额×100% 大宗交易需要企业自己定义何为大宗交易，例如超市可定义单笔成交额大于1万为大宗交易，化妆品和服务专卖店可以定义每次购物数量大于10件为大宗交易等。之所以要监控大宗交易，是因为大宗交易中藏着很多见不得人的交易，而这些交易对渠道和品牌都是伤害。现在很多百货公司的团购部俨然变成了网购批发入口。 很多服装品牌为了维护价格的统一性，会严格控制向非直接客户的发货，而很多网络销售的店主没办法直接从品牌商进货，于是他们选择在店铺做大型促销的时候从零售店铺大量采购，这里面大多会有里应外合的配合，甚至很多零售百货公司会有专人来促进这种交易，大家各取所需。对于很多大型超市，为了冲业绩，采购人员会伙同供应商做虚假交易，首先由超市向供应商下一张大订单，供应商也会发货，不过这批货不会进入超市仓库（采购人员会协调仓库人员做虚拟入仓），直接会以较低的价格卖给如批发市场等渠道，最后采购人员再用这批货款从超市将这批已经不存在的货买出来，这样所有流程走完，采购和供应商都收获了销售额。 3.分析指标【增长率】=增长数÷基础数×100%=（报告期数-基础数）÷基础数×100% 基础数的选择有三种情况，基础数为同期的数据则是同比，基础数为上一个周期的数据则为环比，和2013年9月的销售额对比就是环比，和2013年1月对比为定基比。这三种情况分别对应同比增长率、环比增长率、相对增长率，前两者是用得最多的。 同比增长率中经常使用同店同比增长率（以下简称同店同比）的概念，即本期和同期在对等条件下（相同的店铺）进行对比。同比增长率体现了企业总体的增长情况，同店同比则可以看出企业绝对增长情况。很多企业的增长率非常高，但是大部分增长都来源于新开门店的增长，靠新开店铺的增长是不可能长期持续的。 4.效率指标【坪效】 【销售坪效】=销售额÷店铺面积 【利润坪效】=利润额÷店铺面积 坪效是反映店铺单位面积产出的指标，常常纳入KPI考核项目。坪效的使用需要注意已下几点： （1）计算坪效的最小周期是月，完全没有必须要去计算周、日坪效 （2）如果店铺面积、位置等状态没有发生变化，销售坪效一定和销售成正比，没有必要再去分析坪效趋势。 （3）坪效的对比具有强弱对比性，同一个商场同一楼层的同品类商品具有强对比性，不同品类的对比性会稍微弱一些，不同楼层的不同品类对比又更加弱。同一个商圈的同样业态对比性强，不同的商圈同样业态对比稍弱，不同的商圈不同的业态有可能根本就没有可对比性。同一品牌专卖店在一线城市和三线城市的坪效对比性也不强。所以不要轻易以坪效论营销。 （4）坪效另一个意义在于店铺面积、位置发生变化后进行前后差异的对比分析。 （5）有的企业将坪效用在新开门店销售预估的使用上，这是可以的，但是一定要注意可比性。 【人效】 【销售人效】=销售额÷店铺面积 【利润人效】=利润额÷店铺面积 人效反应的是单人产出，它常常用来管理店铺的人力资源配置、人力成本核算等。 【每平米租金】=租金÷面积 这是用来判断店铺租金相对高低的一个指标。包括每平米日租金、每平米月租金、每平米年租金等 【租金倍率】=销售额÷租金 租金倍率是衡量投入1元租金能产生多少销售额的一个指标。每平米租金由于城市、商圈等差异，没办法直接对比，而租金倍率由于考虑到租金产生的效益则可以直接对比。 5.竞争状况【市场占有率】 也称市场份额，是指一个企业的销售量或销售额在同类市场产品中所占的比重，它直接反应了消费者对商品的喜好程度，同类市场是一个变化的值，既可以是广义的总体市场，也可以是企业的目标市场，甚至可以是某个商圈或商场。例如含氟牙膏可以和牙膏对比，也可以和含氟牙膏对比，甚至计算它在家乐福或沃尔玛超市中的市场占有率。正因为标准的多样性，市场中才充斥着各种号称自己市场占有率第一的品牌。这个指标一般通过市场调查获得。 【竞品指数】=本公司销售额/量÷竞争对手销售额/量 竞品指数是对市场占有率的一种简化，因为我们大部分时间没有办法统计出同类市场的销售数据，所以只能锚定其中一个或几个对手的数据对比。通过分析竞品指标我们也能大致了解自己品牌的市场占有率走势。 【平均排名】 竞争对手的销售数据也不是很容易拿到的，但是每个商场自己品牌的排名值却比较容易到手，这时就可以计算品牌间的平均排名值，通过分析平均排名的变化也可以侧面了解自己的市场占有率情况。平均排名常常被鞋服、化妆品等行业用来作为对店长、销售主管、区域经理等的考核指标。 6.促销指标【费销比】=促销费用金额÷促销期间产生的销售额×100% 【目标完成率】=促销期间销售完成数÷促销目标×100% 【同比增长率】=同比增长数÷同期销售额×100% 【促销爆发度】=（促销期间的平均权重销售额-促销后的平均权重销售额）÷促销前的平均权重销售额×100% 【品牌参活度】=参与促销活动的品牌数÷卖场总品牌数×100% 这个指标常常用在百货和超市的促销活动准备期，用来衡量营运经理促销活动时的执行力。对于品牌商可以将此指标修改为单品参活度，例如公司一共有200个SKU产品，五一期间有40个SKU做促销，单品参活度即为20%。十一促销有50个SKU参与，但是总SKU为300个，单品参活度反而降低为16.7% 【会员参与率】=参与促销活动的会员数÷有效会员总数×100% 促销活动前我们一般会通过邮件、短信、微信、电话等手段通知会员顾客，而会员参与度就是用来评估这些手段效果的一个指标。 7.渠道扩展【净开店率】=（开店数-关店数）÷期初店铺数×100% 【渠道结构占比】=该渠道销售额÷总销售×100% 渠道结构分析是销售分析中最常见的一种分析方式，也是著名的营销4P理论中的一个P（place）。 【重要客户占比】=重要客户销售额÷总销售额×100% 重要客户如何定义是这个指标的关键，有如下几种确定重要客户的方法供参考： ①以销售额的前N名客户作为重要客户，例如前十大客户等 ②根据二八法则，以总销售额80%的客户作为重要客户 ③根据ABC分析法以A类客户作为重点客户 ④根据企业未来战略制定重点客户 单看每个月的重要客户占比没有太大的意义，需要连续观察该数据的走势才有判断的依据，同时需要注意不能经常更改重要客户名单。 四、财务-部分1.销售利润率【毛利率】=（销售收入-营业成本）÷销售收入×100% 【纯毛利】=（销售收入-营业成本-费用）÷销售收入×100% 【交叉比率】=商品毛利率×商品周转率 商品周转率=销售收入÷（（期初库存值+期末库存值）÷2） 毛利率大，周转次数高的商品是优质产品，但是这种商品是比较少的。很多商家采取薄利多销的策略实际上就是牺牲部分商品的毛利率，从而换取较高的周转率。交叉比率一般以季度、半年、年为计算周期。 2.回款指标【回款（金额）达标率】=回款金额÷欠款金额×100% 【回款（客户）达标率】=回款客户÷欠款客户×100% 回款考核中的金额达标率和客户达标率两个指标是孪生兄弟，谁也离不开谁。前者确保回款金额的重要性，后者确保回款客户的普遍性。有的企业只考核回款金额达标率，这就有可能造成一些小额欠款客户的款不被收款人员关心，因为对金额回款率的影响极小。 3.贸易条件【联营扣率】 联营扣率是百货公司为了确保自己的经营利润而和商家合同约定在销售收入中扣除的比率，例如商场某品牌的联营扣率是23%，意味着在商场结款时只能结到销售收入的77% 【租售比】=租金÷销售额×100% 对品牌商来说租售比可以和联营扣率进行对比分析，都是为了取得经营权所需要付出的代价。前面谈到的租金倍率指标实际上是租售比的倒数。 这是个竞争不断加剧的时代，我们必须更加专业的利用数据。数据并不是人们最终需要的东西，他们需要的是信息，是对未来发展的洞察力。 作为数据分析师，最怕你的分析报告没有产生价值，本文的指标可以帮助你在分析零售数据的时候，提高对数据的认识，并真正帮助企业提高运营管理深度。 除此之外，如何从数据中发现商业规则、洞察消费者行为、量化商业价值，都需要数据分析师们拥有能融合商业理解、数据分析并具备从海量数据中发现知识的能力。希望本文章能作为大家学习零售数据分析指标的小手册，随取随用。]]></content>
      <categories>
        <category>零售业剖析</category>
      </categories>
      <tags>
        <tag>零售</tag>
        <tag>零售业</tag>
        <tag>数据指标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4小时java入门]]></title>
    <url>%2F2019%2F05%2F07%2F4%E5%B0%8F%E6%97%B6java%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[译自：https://learnxinyminutes.com/docs/java/ ps：好多类都写到一起了，自己要运行的话记得写到不同的java文件中哦 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854// 导入java.util包中的ArrayList类import java.io.BufferedReader;import java.io.FileReader;import java.math.BigDecimal;import java.math.BigInteger;import java.util.*;// 导入java.util包中的Scanner类// 导入java.security包中的所有类import java.security.*;import java.util.function.Supplier;public class LearnJava &#123; // 要运行一个java程序，必须要有一个main方法作为入口 public static void main(String[] args) &#123; /////////////////////////////////////// // 输入/输出 /////////////////////////////////////// /* * 输出 */ //通过 System.out.println() 来输出一行数据 System.out.println("Hello World!"); System.out.println( "Integer: " + 10 + " Double: " + 3.14 + " Boolean: " + true ); //如果输出之后不想换行，可以使用System.out.print() System.out.print("Hello "); System.out.print("World");// /*// * 输入// *///// //通过Scanner读取输入// //必须import java.util.Scanner;// Scanner scanner = new Scanner(System.in);//// //读取string输入// String name = scanner.next();//// //读取byte输入// byte numByte = scanner.nextByte();//// //读取int输入// int numInt = scanner.nextInt();//// //读取long输入// float numFloat = scanner.nextFloat();//// //读取oduble输入// double numDouble = scanner.nextDouble();//// //读取boolean输入// boolean bool = scanner.nextBoolean(); /////////////////////////////////////// // 变量 /////////////////////////////////////// /* * 变量声明 */ //通过&lt;type&gt; &lt;name&gt;声明变量 int fooInt; //声明多个变量： // &lt;type&gt; &lt;name1&gt;, &lt;name2&gt;, &lt;name3&gt; int fooInt1, fooInt2, fooInt3; /* * 变量初始化 */ // 通过&lt;type&gt; &lt;name&gt; = &lt;val&gt;来初始变量 int barInt = 1; // 初始化多个变量： // &lt;type&gt; &lt;name1&gt;, &lt;name2&gt;, &lt;name3&gt; // &lt;name1&gt; = &lt;name2&gt; = &lt;name3&gt; = &lt;val&gt; int barInt1, barInt2, barInt3; barInt1 = barInt2 = barInt3 = 1; /* * 变量类型 */ // Byte - 8位有符号二进制补码整数 // (-128 &lt;= byte &lt;= 127) byte fooByte = -100; // 如果您想将一个字节解释为无符号整数 // 只需要下边这句 int unsignedIntLessThan256 = 0xff &amp; fooByte; // 下边这句 int signedInt = (int) fooByte; // Short - 16位有符号二进制补码整数 // (-32,768 &lt;= short &lt;= 32,767) short fooShort = 10000; // Integer - 32位有符号二进制补码整数 // (-2,147,483,648 &lt;= int &lt;= 2,147,483,647) int bazInt = 1; // Long - 64位有符号二进制补码整数 // (-9,223,372,036,854,775,808 &lt;= long &lt;= 9,223,372,036,854,775,807) long fooLong = 100000L; // 数值后边的'L'指示这个变量是long类型 // 没有L的话依然会默认用int存储 // 注意: byte, short, int 和 long 都是有符号的. 也就是说可以为正数或负数 // 没有无符号变量 // 然而，char就是16位无符号的 // Float - 单精度32位IEEE 754浮点数 // 2^-149 &lt;= float &lt;= (2-2^-23) * 2^127 float fooFloat = 234.5f; // 数字末尾的f 或者 F 是用来标识这个变量通过float进行存储 // 否则就会默认按照double存储 // Double - 双精度64位IEEE 754浮点数 // 2^-1074 &lt;= x &lt;= (2-2^-52) * 2^1023 double fooDouble = 123.4; // Boolean - true &amp; false boolean fooBoolean = true; boolean barBoolean = false; // Char - 一个16位的unicode字符 char fooChar = 'A'; // final 变量不能被重新赋值 final int HOURS_I_WORK_PER_WEEK = 9001; // 但是可以稍后初始化 final double E; E = 2.71828; // BigInteger - 不可变的任意精度整数 // // BigInteger是一类数据类型，允许程序员操作超过64位长度的整数 // 这样生成的整数存储为字节组成的数组，并通过内建在BigInteger中的函数进行操作 // // BigInteger 可以通过一个字节组成的数组或者字符串初始化 String fooByteArray = "1000000000000000000000000000000000000000000"; BigInteger fooBigInteger = new BigInteger(fooByteArray); // BigDecimal - 不可变的，任意精度的带符号十进制数 // // BigDecimal包含两个部分:一个任意精度的整数无标度值和一个32位整数标度 // // BigDecimal允许程序员完全控制十进制舍入 // 建议将BigDecimal与精度值一起使用，并在需要精确小数精度的地方使用BigDecimal // // BigDecimal 可以使用int、long、double或String初始化 // 也可以初始化未缩放值(BigInteger)和scale (int) fooInt = 1; BigDecimal fooBigDecimal = new BigDecimal(fooBigInteger, fooInt); //警惕采用float或double的构造函数 //float/double的不准确性也会被拷贝到BigDecimal中 //当您需要精确值时，首选String构造函数 BigDecimal tenCents = new BigDecimal("0.1"); // String：字符串 String fooString = "My String Is Here!"; // \n 是一个转义字符，开始一个新行 String barString = "Printing on a new line?\nNo Problem!"; // \t 是一个转义字符，用于添加制表符 String bazString = "Do you want to add a tab?\tNo Problem!"; System.out.println(fooString); System.out.println(barString); System.out.println(bazString); // 字符串构建 // #1 - 通过加号"+"运算符 // 这是实现它的基本方法（在通过引擎优化） String plusConcatenated = "Strings can " + "be concatenated " + "via + operator."; System.out.println(plusConcatenated); // 输出: 字符串可以通过+运算符连接 // #2 - 通过StringBuilder //这种方式不会创建任何中间字符串。 它只存储字符串片段，并在调用toString（）时将它们连接在一起 //提示：此类不是线程安全的。 StringBuffer是一种线程安全的替代方案（对性能有一些影响）。 StringBuilder builderConcatenated = new StringBuilder(); builderConcatenated.append("You "); builderConcatenated.append("can use "); builderConcatenated.append("the StringBuilder class."); System.out.println(builderConcatenated.toString()); //字符串只在现在构建 // 输出: You can use the StringBuilder class. // 在完成某些处理结束之前不需要完全构造的String时，StringBuilder非常有效。 StringBuilder stringBuilder = new StringBuilder(); String inefficientString = ""; for (int i = 0 ; i &lt; 10; i++) &#123; stringBuilder.append(i).append(" "); inefficientString += i + " "; &#125; System.out.println(inefficientString); System.out.println(stringBuilder.toString()); // inefficientString需要更多的工作来生成，因为它在每次循环迭代时都会生成一个String。 // 使用+进行简单字符串连接，编译后相当于同时调用StringBuilder和toString（） // 使用StringBuilder可以避免循环中的字符串连接。 // #3 - 使用String格式化器 // 另一种创建字符串的替代方法，快速且可读。 String.format("%s may prefer %s.", "Or you", "String.format()"); // 输出: Or you may prefer String.format(). // Arrays：数组 // 必须在实例化时确定数组大小 // 以下格式用于声明数组 // &lt;datatype&gt;[] &lt;var name&gt; = new &lt;datatype&gt;[&lt;array size&gt;]; // &lt;datatype&gt; &lt;var name&gt;[] = new &lt;datatype&gt;[&lt;array size&gt;]; int[] intArray = new int[10]; String[] stringArray = new String[1]; boolean boolArray[] = new boolean[100]; // 声明和初始化数组的另一种方法 int[] y = &#123;9000, 1000, 1337&#125;; String names[] = &#123;"Bob", "John", "Fred", "Juan Pedro"&#125;; boolean bools[] = &#123;true, false, false&#125;; // 索引数组 - 访问元素 System.out.println("intArray @ 0: " + intArray[0]); // 数组是零索引且可变的 intArray[1] = 1; System.out.println("intArray @ 1: " + intArray[1]); // 其他值得一试的数据类型 // ArrayLists - 除了提供更多功能之外的类似数组，且数组长度是可变的 // LinkedLists - 双向链表的实现，全部操作按照双向链表执行。 // Maps - 键对象到值对象的映射。 Map是一个接口，因此无法实例化。 必须在实现类的实例化时指定Map中包含的键和值的类型。 每个键可以仅映射到一个对应的值，并且每个键可以仅出现一次（没有重复）。 // HashMaps - 此类使用哈希表来实现Map接口。 这允许基本操作的执行时间（例如get和insert元素）即使对于大型集合也保持不变。 // TreeMap - 按键排序的映射。 每个修改都维护由实例化时提供的Comparator定义的排序，或者如果它们实现Comparable接口则对每个Object进行比较。 密钥实现Comparable失败以及无法提供Comparator将导致ClassCastExceptions。 插入和删除操作需要O(log(n))时间，因此除非您正在利用排序，否则请避免使用此数据结构。 /////////////////////////////////////// // Operators：运算符 /////////////////////////////////////// System.out.println("\n-&gt;Operators"); int i1 = 1, i2 = 2; // 多个声明的简写 // 算数很直接 System.out.println("1+2 = " + (i1 + i2)); // =&gt; 3 System.out.println("2-1 = " + (i2 - i1)); // =&gt; 1 System.out.println("2*1 = " + (i2 * i1)); // =&gt; 2 System.out.println("1/2 = " + (i1 / i2)); // =&gt; 0 (int/int 返回 int) System.out.println("1/2.0 = " + (i1 / (double)i2)); // =&gt; 0.5 // Modulo：模运算 System.out.println("11%3 = "+(11 % 3)); // =&gt; 2 // 比较运算符 System.out.println("3 == 2? " + (3 == 2)); // =&gt; false System.out.println("3 != 2? " + (3 != 2)); // =&gt; true System.out.println("3 &gt; 2? " + (3 &gt; 2)); // =&gt; true System.out.println("3 &lt; 2? " + (3 &lt; 2)); // =&gt; false System.out.println("2 &lt;= 2? " + (2 &lt;= 2)); // =&gt; true System.out.println("2 &gt;= 2? " + (2 &gt;= 2)); // =&gt; true // 布尔运算符 System.out.println("3 &gt; 2 &amp;&amp; 2 &gt; 3? " + ((3 &gt; 2) &amp;&amp; (2 &gt; 3))); // =&gt; false System.out.println("3 &gt; 2 || 2 &gt; 3? " + ((3 &gt; 2) || (2 &gt; 3))); // =&gt; true System.out.println("!(3 == 2)? " + (!(3 == 2))); // =&gt; true // 位运算符! /* ~ 一元位补 &lt;&lt; 带符号左移 &gt;&gt; 带符号/算术右移 &gt;&gt;&gt; 无符号/逻辑右移 &amp; 按位与运算 ^ 按位异或运算 | 按位或运算 */ // 增量运算符 int i = 0; System.out.println("\n-&gt;Inc/Dec-rementation"); // ++ 和 -- 运算符分别表示递增和递减1 // 如果它们放在变量之前，它们会先递增后返回 // 放在变量之后表示先返回后递增 System.out.println(i++); // i = 1, prints 0 (后递增) System.out.println(++i); // i = 2, prints 2 (先递增) System.out.println(i--); // i = 1, prints 2 (后递减) System.out.println(--i); // i = 0, prints 0 (先递减) /////////////////////////////////////// // Control Structures：控制结构 /////////////////////////////////////// System.out.println("\n-&gt;Control Structures"); // if语句和c语言里边差不多 int j = 10; if (j == 10) &#123; System.out.println("I get printed"); &#125; else if (j &gt; 10) &#123; System.out.println("I don't"); &#125; else &#123; System.out.println("I also don't"); &#125; // While循环 int fooWhile = 0; while(fooWhile &lt; 100) &#123; System.out.println(fooWhile); fooWhile++; &#125; System.out.println("fooWhile Value: " + fooWhile); // Do While 循环 int fooDoWhile = 0; do &#123; System.out.println(fooDoWhile); fooDoWhile++; &#125; while(fooDoWhile &lt; 100); System.out.println("fooDoWhile Value: " + fooDoWhile); // For 循环 // for 循环声明的结构 =&gt; for(&lt;start_statement&gt;; &lt;conditional&gt;; &lt;step&gt;) for (int fooFor = 0; fooFor &lt; 10; fooFor++) &#123; System.out.println(fooFor); // 迭代10次, fooFor 0-&gt;9 &#125; // System.out.println("fooFor Value: " + fooFor); 这句会报错，因为fooFor在for循环内部声明，无法在循环外部调用 // 嵌套的for循环，通过标签退出 outer: for (int ii = 0; ii &lt; 10; ii++) &#123; for (int jj = 0; jj &lt; 10; jj++) &#123; if (ii == 5 &amp;&amp; jj ==5) &#123; break outer; // 跳出外部的outer循环，而不是只有内部的 &#125; &#125; &#125; // For Each 循环 // for循环还能够遍历数组和通过Iterable接口实现的对象 int[] fooList = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; // for each 循环结构 =&gt; for (&lt;object&gt; : &lt;iterable&gt;) // 可以读成: 对于迭代对象中的每个元素 // 注意: 对象类型必须匹配可迭代对象中的元素类型 for (int bar : fooList) &#123; System.out.println(bar); //迭代9次并输出1-9 &#125; // Switch Case // switch使用byte，short，char和int数据类型 // 它也适用于枚举类型（在枚举类型中讨论） // String类，以及一些包装基本类型的特殊类：字符，字节，短整数和整数 // 从Java 7及更高版本开始，我们也可以使用String类型 // 注意：请记住，不在任何特定情况下添加“break”会导致其接着执行下一个case（假设它满足所提供的条件）。 int month = 3; String monthString; switch (month) &#123; case 1: monthString = "January"; break; case 2: monthString = "February"; break; case 3: monthString = "March"; break; default: monthString = "Some other month"; break; &#125; System.out.println("Switch Case Result: " + monthString); // Try-with-resources语句（Java 7+） // Try-catch-finally语句在Java中按预期工作，但在Java 7+中，try-with-resources语句也可用 // Try-with-resources通过自动关闭资源简化了try-catch-finally语句 // 为了使用try-with-resources，先在try语句内包含一个类的实例。 该类必须应用java.lang.AutoCloseable。 try (BufferedReader br = new BufferedReader(new FileReader("foo.txt"))) &#123; // 你可以试着干一些会抛出异常的事情 System.out.println(br.readLine()); // 在Java 7中，即使抛出了异常，资源也会被关闭 &#125; catch (Exception ex) &#123; // 在catch语句生效之前，资源就会关闭 System.out.println("readLine() failed."); &#125; // 在这个例子中，不需要finally声明，BufferReader就已经关闭了 // 这可以被用来避免在一些边缘情况中，有些finally声明不会被调用的情况 // 了解更多请访问: // https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html // 条件语句的简写 // 你可以使用'？'操作符来进行快速分配或逻辑分叉 // 可以解读成 "If (statement) is true, use &lt;first value&gt;, otherwise, use &lt;second value&gt;" int foo = 5; String bar = (foo &lt; 10) ? "A" : "B"; System.out.println("bar : " + bar); // 打印 "bar : A", 因为声明foo&lt;10 为 true. // 或者就简单的这么写 System.out.println("bar : " + (foo &lt; 10 ? "A" : "B")); //////////////////////////////////////// // Converting Data Types：转换数据类型 //////////////////////////////////////// // 转换数据 // 字符串 到 整数 Integer.parseInt("123");//返回一个整数123 // 整数 到 字符串 Integer.toString(123);//返回一个字符串123 // 对于其他转换，可以看一下下面的类 // Double // Long // String /////////////////////////////////////// // Classes And Functions：类和函数 /////////////////////////////////////// System.out.println("\n-&gt;Classes &amp; Functions"); // (Bicycle类的定义在后边) // 通过new来实例化一个类 Bicycle trek = new Bicycle(); // 调用对象的方法 trek.speedUp(3); // You should always use setter and getter methods trek.setCadence(100); // toString 会返回这个对象的字符串表示 System.out.println("trek info: " + trek.toString()); &#125;// main方法的结束&#125;// LearnJava类的结束// 您可以在一个.java文件中包含其他非公共外层类，但这不是一个好习惯// 正确的做法是将不同的类拆分为单独的文件// Class 声明语法：// &lt;public/private/protected&gt; class &lt;class name&gt; &#123;// // 数据字段，构造函数，函数都在里面// // 函数在Java中称为方法// &#125;class Bicycle &#123; // Bicycle类的字段/变量 public int cadence; // Public: 可以从任何地方访问 private int speed; // Private: 只能从类内部访问 protected int gear; // Protected: 可以从类和子类中访问 String name; // 默认只能从这个包中访问 static String className; // 静态的类变量 // Static block：静态块 // Java没有静态构造函数的实现，但有一个静态块可用于初始化类变量（静态变量） // 加载类时将调用此块 static &#123; className = "Bicycle"; &#125; // Double Brace Initialization：双大括号初始化 // Java语言没有关于如何以简单方式创建静态集合的语法。 通常您最终会使用一下方式： private static final Set&lt;String&gt; COUNTRIES = new HashSet&lt;String&gt;(); static &#123; COUNTRIES.add("DENMARK"); COUNTRIES.add("SWEDEN"); COUNTRIES.add("FINLAND"); &#125; // 但是通过使用一种叫做Double Brace Initialization的东西，可以通过一种更简单的方式实现同样的事情。 private static final Set&lt;String&gt; COUNTRIES2 = new HashSet&lt;String&gt;() &#123;&#123; add("DENMARK"); add("SWEDEN"); add("FINLAND"); &#125;&#125;; // 第一个大括号是创建一个新的AnonymousInnerClass，第二个大括号是声明一个实例初始化块 // 创建匿名内部类时调用此块 // 这不仅适用于集合，它适用于所有非最终类 // 构造函数是一种创建类的方法 // 这就是一个构造函数 public Bicycle() &#123; // 你也可以调用另一个构造函数: this(1, 50, 5, "Bontrager"); gear = 1; cadence = 50; speed = 5; name = "Bontrager"; &#125; // 这是一个带参数的构造函数 public Bicycle(int startCadence, int startSpeed, int startGear, String name) &#123; this.gear = startGear; this.cadence = startCadence; this.speed = startSpeed; this.name = name; &#125; // Method 语法: // &lt;public/private/protected&gt; &lt;return type&gt; &lt;function name&gt;(&lt;args&gt;) // Java类通常为其字段实现getter和setter // Method 声明语法: // &lt;access modifier：访问修饰符&gt; &lt;return type&gt; &lt;method name&gt;(&lt;args&gt;) public int getCadence() &#123; return cadence; &#125; // void方法不需要return public void setCadence(int newValue) &#123; cadence = newValue; &#125; public void setGear(int newValue) &#123; gear = newValue; &#125; public void speedUp(int increment) &#123; speed += increment; &#125; public void slowDown(int decrement) &#123; speed -= decrement; &#125; public void setName(String newName) &#123; name = newName; &#125; public String getName() &#123; return name; &#125; //显示此对象的属性值的方法 @Override // 从Object类中继承. public String toString() &#123; return "gear: " + gear + " cadence: " + cadence + " speed: " + speed + " name: " + name; &#125;&#125; // Bicycle类的结束// PennyFarthing 是 Bicycle 的一个子类class PennyFarthing extends Bicycle &#123; // (Penny Farthings是那些带有大前轮的自行车，这种自行车没有齿轮) public PennyFarthing(int startCadence, int startSpeed) &#123; // 通过super调用父类的构造函数 super(startCadence, startSpeed, 0, "PennyFarthing"); &#125; // 如果要覆盖一个父类的方法，您应该用@annotation标记一下（这里是@Override） // 了解更多请访问: http://docs.oracle.com/javase/tutorial/java/annotations/ @Override public void setGear(int gear) &#123; this.gear = 0; &#125;&#125;// Object casting：对象转换// 由于PennyFarthing类扩展自Bicycle类，我们可以说PennyFarthing是一个Bicycle并写道：// Bicycle bicycle = new PennyFarthing();// 这称为对象转换，其中一个对象被用于另一个对象。 这里有许多细节和处理更多中间概念： https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html// Interfaces：接口// Interface 声明语法// &lt;access-level&gt; interface &lt;interface-name&gt; extends &lt;super-interfaces&gt; &#123;// // Constants// // Method declarations// &#125;// 例子 - Food:public interface Edible &#123; public void eat(); // 任何实现此接口的类都必须实现此方法&#125;public interface Digestible &#123; public void digest(); // 从Java 8开始，接口可以有默认方法 public default void defaultMethod() &#123; System.out.println("Hi from default method ..."); &#125;&#125;// 我们现在可以创建一个实现这两个接口的类。public class Fruit implements Edible, Digestible &#123; @Override public void eat() &#123; // ... &#125; @Override public void digest() &#123; // ... &#125;&#125;// 在Java中，你只能extend一个类，但是你可以实现多个接口，如下：public class ExampleClass extends ExampleClassParent implements InterfaceOne, InterfaceTwo &#123; @Override public void InterfaceOneMethod() &#123; &#125; @Override public void InterfaceTwoMethod() &#123; &#125;&#125;// Abstract Classes：抽象类// 抽象类声明语法// &lt;access-level&gt; abstract class &lt;abstract-class-name&gt; extends// &lt;super-abstract-classes&gt; &#123;// // Constants and variables// // Method declarations// &#125;// 抽象类不能被实例化// 抽象类可以定义抽象方法// 抽象方法没有正文并且标记为抽象，非抽象子类必须通过@Override来覆盖来自其超类的所有抽象方法// 在将重复逻辑与自定义行为相结合时，抽象类可能很有用，但由于抽象类需要继承，因此它们违反了“基于继承的组合”，因此需要组合时请考虑使用其他方法// https://en.wikipedia.org/wiki/Composition_over_inheritancepublic abstract class Animal&#123; private int age; public abstract void makeSound(); // 非抽象方法可以有正文 public void eat() &#123; System.out.println("I am an animal and I am Eating."); // 注意，在这里我们可以获取私有变量 age = 30; &#125; public void printAge() &#123; System.out.println(age); &#125; // 抽象类可以有main函数 public static void main(String[] args) &#123; System.out.println("I am abstract"); &#125;&#125;class Dog extends Animal&#123; // 注意，仍需重写抽象类中的抽象方法 @Override public void makeSound() &#123; System.out.println("Bark"); // age = 30; ==&gt; ERROR! 这里会报错，age是Animal的私有变量 &#125; // 注意，如果你在这里使用@Override注解会发生错误，因为java不允许重写静态方法 // 这种情况被成为方法隐藏 // 了解更多请访问: http://stackoverflow.com/questions/16313649/ public static void main(String[] args) &#123; Dog pluto = new Dog(); pluto.makeSound(); pluto.eat(); pluto.printAge(); &#125;&#125;// Final Classes：final类// Final Class 声明语法// &lt;access-level&gt; final &lt;final-class-name&gt; &#123;// // Constants and variables// // Method declarations// &#125;// final类不能被继承，因此最终一定是一个child// 在某种程度上，final类与抽象类相反，因为抽象类必须被扩展才能使用，而final类不能被扩展public final class SaberToothedCat extends Animal&#123; // 注意，仍需重写抽象类中的抽象方法 @Override public void makeSound() &#123; System.out.println("Roar"); &#125;&#125;// Final Methods：final方法public abstract class Mammal&#123; // 如果用final来修饰变量的话，则该变量的值不能被修改，成为常量，如下： protected final int finalFoo = 0; // Final Method 语法: // &lt;access modifier&gt; final &lt;return type&gt; &lt;function name&gt;(&lt;args&gt;) // final方法和final类一样，不能在子类中被重写 // 因此一定是该方法的最终实现 public final boolean isWarmBlooded() &#123; return true; &#125;&#125;// Enum Type：枚举类型//// 枚举类型是一种特殊的数据类型，它使变量成为一组预定义的常量。// 变量必须等于为其预定义的值之一。 因为它们是常量，所以枚举类型字段的名称是大写字母。// 在Java编程语言中，使用enum关键字定义枚举类型。// 例如，您可以将星期几的枚举类型指定为：public enum Day &#123; SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY&#125;// 我们可以像这样使用Daypublic class EnumTest &#123; // enum变量 Day day; public EnumTest(Day day) &#123; this.day = day; &#125; public void tellItLikeItIs() &#123; switch (day) &#123; case MONDAY: System.out.println("Mondays are bad."); break; case FRIDAY: System.out.println("Fridays are better."); break; case SATURDAY: case SUNDAY: System.out.println("Weekends are best."); break; default: System.out.println("Midweek days are so-so."); break; &#125; &#125; public static void main(String[] args) &#123; EnumTest firstDay = new EnumTest(Day.MONDAY); firstDay.tellItLikeItIs(); // =&gt; Mondays are bad. EnumTest thirdDay = new EnumTest(Day.WEDNESDAY); thirdDay.tellItLikeItIs(); // =&gt; Midweek days are so-so. &#125;&#125;// Enum types(枚举类型) 比我们上边展示的要强大的多// enum正文可以包含各种方法和字段// 详细的可以看： https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html// 现在开始学Lambda表达式//// Java8版本的新增功能是lambda表达式。// Lambda在函数式编程语言中更常见，这意味着它们是可以在不属于类的情况下创建的方法，如同它本身就是一个对象一样传递，并按需执行。// 最后要注意，lambdas必须通过一个功能接口实现// 功能接口是仅声明了一个抽象方法的接口// 它可以有任意数量的默认方法// Lambda表达式可以用作该功能接口的实例// 满足要求的任何接口都被视为功能接口// 您可以阅读更多有关上述接口的资料//import java.util.Map;import java.util.HashMap;import java.util.function.*;import java.security.SecureRandom;public class Lambdas &#123; public static void main(String[] args) &#123; // Lambda 声明语句: // &lt;zero or more parameters&gt; -&gt; &lt;expression body or statement block&gt; // 我们将在接下来的例子中使用这个hashmap Map&lt;String, String&gt; planets = new HashMap&lt;&gt;(); planets.put("Mercury", "87.969"); planets.put("Venus", "224.7"); planets.put("Earth", "365.2564"); planets.put("Mars", "687"); planets.put("Jupiter", "4,332.59"); planets.put("Saturn", "10,759"); planets.put("Uranus", "30,688.5"); planets.put("Neptune", "60,182"); // 下边这个例子是一个没有参数，使用了java.util.function.Supplier中的Supplier功能接口的Lambda // 实际的lambda表达式是在numPlanets =之后出现的内容 Supplier&lt;String&gt; numPlanets = () -&gt; Integer.toString(planets.size()); System.out.format("Number of Planets: %s\n\n", numPlanets.get()); // 一下例子是具有一个参数并使用java.util.function.Consumer中的Consumer功能接口的Lambda // 这是因为行星是一个Map，它实现了Collection和Iterable // 此处使用的forEach（可以在Iterable中找到）将lambda表达式应用于Collection的每个成员 // forEach的默认实现表现如下： /* for (T t : this) action.accept(t); */ // 实际上lambda表达式是传给forEach的参数 planets.keySet().forEach((p) -&gt; System.out.format("%s\n", p)); // 如果你只有一个参数，也可以写成 (注意p周围的括号没了): planets.keySet().forEach(p -&gt; System.out.format("%s\n", p)); // 在以上内容中，我们可以看到planets是一个HashMap，keySet()方法返回一个它的键集，forEach将每个元素应用于lambda表达式:(parameter p) -&gt; System.out.format("%s\n", p) // 每次，该元素被称为“消耗”，并且应用lambda体中引用的语句 // lambda体是在-&gt;之后出现的部分 // 上边的语句如果不用lambda写的话会看起来更加传统 for (String planet : planets.keySet()) &#123; System.out.format("%s\n", planet); &#125; // 这个例子与上面的不同之处在于使用了不同的forEach实现：在实现Map接口的HashMap类中找到的forEach // 这个forEach接受一个BiConsumer，一般来说这是一种奇特的方式，也就是说它处理的是每个Key -&gt; Value对的Set // 此默认实现表现如下： /* for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) action.accept(entry.getKey(), entry.getValue()); */ // 实际的lambda表达式是传给forEach的参数 String orbits = "%s orbits the Sun in %s Earth days.\n"; planets.forEach((K, V) -&gt; System.out.format(orbits, K, V)); // 上边的语句如果不用lambda写的话会看起来更加传统 for (String planet : planets.keySet()) &#123; System.out.format(orbits, planet, planets.get(planet)); &#125; // 或者，如果更严格地遵循默认实现提供的规范 for (Map.Entry&lt;String, String&gt; planet : planets.entrySet()) &#123; System.out.format(orbits, planet.getKey(), planet.getValue()); &#125; // 这些例子仅涵盖了lambda的基本用法 // 它可能看起来不是非常有用，但请记住，lambda可以创建为一个对象，以后可以作为参数传递给其他方法 &#125;&#125;]]></content>
      <categories>
        <category>Learn X in Y minutes</category>
        <category>Learn Java in Y minutes</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda演算精简教程]]></title>
    <url>%2F2019%2F04%2F24%2FLambda%E6%BC%94%E7%AE%97%E7%B2%BE%E7%AE%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言这篇文章译自：https://learnxinyminutes.com/docs/lambda-calculus/，写的精简了点，理解起来可能有些困难 建议配合让我们谈谈 $\lambda$ 演算.pdf一起食用（出自https://github.com/txyyss/Lambda-Calculus/releases）。这篇不算长，深入浅出，写的也极好。 整体介绍Lambda演算( $\lambda$ 演算)由Alonzo Church提出，是世界上最简洁的编程语言。尽管没有数字、字符串、布尔值等非函数数据类型，lambda演算还是可以表达任何图灵机。 Lambda演算由三种元素组成：变量（variables），函数（functions），以及应用（applications）。 名称 语法 例子 解释 Variable &lt;name&gt; x 一个名为“x”的变量 Function $\lambda$ &lt;parameters&gt;.&lt;body&gt; $\lambda$ x.x 一个拥有参数“x”以及函数体x的函数 Application &lt;function&gt;&lt;variable or function&gt; ( $\lambda$ x.x).a 调用函数“ $\lambda$ x.x”且参数值为“a” 最基础的函数就是恒等函数： $\lambda$ x.x（即f(x)=x）。第一个“x”代表函数的参数，第二个“x”代表函数体。 自由变量vs约束变量 在 $\lambda$ x.x函数中，x被称为约束变量，因为它同时位于函数体和参数中。 在 $\lambda$ x.y函数中，y被称为自由变量，因为它从未被事先声明过。 计算通过 $\beta$ 规约进行计算，其基本上是词法范围的替代。 在计算表达式( $\lambda$ x.x)a时，我们用“a”替换函数体中出现的所有“x”。 ( $\lambda$ x.x)a 计算结果为：a ( $\lambda$ x.y)a 计算结果为：y 也可以创建高阶函数： ( $\lambda$ x.( $\lambda$ y.x))a 计算结果为： $\lambda$ y.a 虽然lambda演算传统上只支持单参数函数，但是我们可以使用一种称为currying的技术创建多参数函数。 ( $\lambda$ x. $\lambda$ y. $\lambda$ z.xyz) 即 f(x, y, z) = ((x y) z) 有时 $\lambda$ xy.&lt;body&gt;可与 $\lambda$ x. $\lambda$ y.&lt;body&gt;交替使用。 重要的是要认识到传统的lambda演算没有数字，字符或任何非函数数据类型！ 布尔逻辑在lambda演算中没有“True”或“False”。甚至没有1或0。 取而代之的是： T表示为： $\lambda$ x. $\lambda$ y.x F表示为： $\lambda$ x. $\lambda$ y.y 首先，我们可以定义一个“if”函数 $\lambda$ btf，如果b为True则返回t，如果b为False则返回f IF 也等同于 $\lambda$ b. $\lambda$ t. $\lambda$ f.b t f 通过使用IF，我们可以定义基础的布尔逻辑运算： a AND b 等同于: $\lambda$ ab.IF a b F a OR b 等同于: $\lambda$ ab.IF a T b NOT a 等同于: $\lambda$ a.IF a F T 注意: IF a b c 本质上是: IF((a b) c) 数字尽管lambda演算中没有数字，我们可以通过邱奇数编码数字。 任意数字n都可以编码为： $n = \lambda f.f^n$ 。因此： 0 = $\lambda$ f. $\lambda$ x.x 1 = $\lambda$ f. $\lambda$ x.f x 2 = $\lambda$ f. $\lambda$ x.f(f x) 3 = $\lambda$ f. $\lambda$ x.f(f(f x)) 为了增加邱奇数，我们使用继承函数s(n)=n+1，即 S = $\lambda$ n. $\lambda$ f. $\lambda$ x.f((n f) x) 通过继承，我们可以定义add： ADD = $\lambda$ ab.(a S)b 挑战：试着定义你自己的乘法函数！ 变得更精致：SKI，SK以及IotaSKI组合子演算使S, K, I，分别为以下函数： I x = x K x y = x S x y z = x z (y z) 我们可以将lambda演算中的表达式转换为SKI组合子演算中的表达式： $\lambda$ x.x = I $\lambda$ x.c = Kc $\lambda$ x.(y z) = S ( $\lambda$ x.y) ( $\lambda$ x.z) 以邱奇数2为例子： 2 = $\lambda$ f. $\lambda$ x.f(f x) 对于内部部分 $\lambda$ x.f(f x): $$\begin{split}\lambda x.f(f x) &amp;=&amp; S ( \lambda x.f) ( \lambda x.(f x)) (case 3) \\&amp;=&amp; S (K f) (S ( \lambda x.f) ( \lambda x.x)) (case 2, 3) \\&amp;=&amp; S (K f) (S (K f) I) (case 2, 1)\end{split}$$ 因此： $$\begin{split}2&amp;=&amp; \lambda f. \lambda x.f(f x) \\&amp;=&amp; \lambda f.(S (K f) (S (K f) I)) \\&amp;=&amp; \lambda f.((S (K f)) (S (K f) I)) \\&amp;=&amp; S ( \lambda f.(S (K f))) ( \lambda f.(S (K f) I)) (case 3)\end{split}$$ 对于第一个参数 \lambda f.(S (K f))： $$\begin{split}\lambda f.(S (K f))&amp;=&amp; S ( \lambda f.S) ( \lambda f.(K f)) (case 3)\\&amp;=&amp; S (K S) (S ( \lambda f.K) ( \lambda f.f)) (case 2, 3)\\&amp;=&amp; S (K S) (S (K K) I) (case 2, 3)\end{split}$$ 对于第二个参数 \lambda f.(S (K f) I)： $$\begin{split} \lambda f.(S (K f) I)&amp;=&amp; \lambda f.((S (K f)) I)\\&amp;=&amp; S ( \lambda f.(S (K f))) ( \lambda f.I) (case 3)\\&amp;=&amp; S (S ( \lambda f.S) ( \lambda f.(K f))) (K I) (case 2, 3)\\&amp;=&amp; S (S (K S) (S ( \lambda f.K) ( \lambda f.f))) (K I) (case 1, 3)\\&amp;=&amp; S (S (K S) (S (K K) I)) (K I) (case 1, 2)\end{split}$$ 合到一起： $$\begin{split} 2&amp;=&amp; S ( \lambda f.(S (K f))) ( \lambda f.(S (K f) I))\\&amp;=&amp; S (S (K S) (S (K K) I)) (S (S (K S) (S (K K) I)) (K I))\end{split}$$ SK 组合子运算SKI组合子运算仍可进一步简化。我们可以通过注意I = SKK来移除I组合子。我们可以用SKK替换所有I。 Iota组合子SK组合子运算依然不是最简洁的。定义： $$\begin{split}ι = \lambda f.((f S) K)\end{split}$$ 我们就有： $$\begin{split}I &amp;=&amp; ιι\\K &amp;=&amp; ι(ιI) = ι(ι(ιι))\\S &amp;=&amp; ι(K) = ι(ι(ι(ιι)))\end{split}$$]]></content>
      <tags>
        <tag>lambda</tag>
        <tag>lambda演算</tag>
        <tag>lambda calculus</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Reading Notes] Business process management (BPM) standards: a survey]]></title>
    <url>%2F2019%2F04%2F22%2FReading-Notes-Business-process-management-BPM-standards-a-survey%2F</url>
    <content type="text"><![CDATA[AbstractpurposeThis paper seeks to make sense of the myriad BPM standards, organizing them in a classification framework, and to identify key industry trends. Design/methodology/approachProposed BPM Standards Classification Framework to list each standard’s distinct features, strengths and weaknesses. FindingsAn attempt is made to classify BPM languages, standards and notations into four main groups: execution, interchange, graphical, and diagnosis(lack) standards. Practical implicationsResearchers and practitioners may wish to position their work around this review. Originality/valueNo body did before. KeywordsProcess management, Standards, Work flow Paper typeLiterature review IntroductionThe growth of business process managementSome factors: the rise in frequency of goods ordered; the need for fast information transfer; quick decision making; the need to adapt to change in demand; more international competitors; and demands for shorter cycle times Software tools supporting the management of such operational processes became known as business process management systems (BPMS). The proliferation of BPM languages, standards and software systemsNaturally, interest in BPM from practitioners and researchers grew rapidly. Many new BPM terminologies and technologies are often not well defined and understood by many practitioners and researchers using them.New languages and notations proposed often contain duplicating features for similar concepts, and loosely claim to be based on theoretical formalisms such as Pi-calculus and Petri nets. Most of them have also not been validated, especially in a real business and office environment. Motivation of this paperThis paper’s goal is to leave the reader with some semblance of order out of a disparate collection of specifications, white papers, journal publications, conference publications and workshop notes to be consolidated as a single paper. discuss and rationalize the terminologies associated with BPM and its standards; systematically categorize/classify BPM standards; discuss the current strengths and limitations of each standard; clarify, the differences of theoretical underpinnings of prominent BPM standards; and explore the gaps of knowledge of current BPM standards and how these may be bridged. BPM basicsThe BPM life cycle Term Explanation Process design In this stage, fax- or paper-based as-is business processes are electronically modeled into BPMS. Graphical standards are dominant in this stage. System configuration This stage configures the BPMS and the underlying system infrastructure. This stage is hard to standardize due to the differing IT architectures of different enterprises. Process enactment Electronically modeled business processes are deployed in BPMS engines. Execution standards dominate this stage. Diagnosis Given appropriate analysis and monitoring tools, the BPM analyst can identify and improve on bottlenecks and potential fraudulent loopholes in the business processes. The tools to do this are embodied in diagnosis standards. BPM vs BPR vs WfM BPM: Business Process Management BPR: Business Process Reengineering WfM: Workflow Management BPM vs BPRBPR calls for a radical obliteration of existing business processes, its descendant BPM is more practical, iterative and incremental in fine-tuning business processes. BPM vs WfM One viewpoint by Gartner research views BPM as a management discipline with WfM supporting it as a technology. Another viewpoint from academics is that the features stated in WfM according to Georgakopoulos et al. is a subset of BPM defined by van der Aalst et al., with the diagnosis stage of the BPM life cycle as the main difference. BPM theory vs BPM standards and languages vs BPMSBPMS/BPMSs: Business Process Management Suites BPM vs service oriented architectureSOA: Service Oriented Architecture BPM is a process-oriented management discipline aided by IT while SOA is an IT architectural paradigm. According to Gartner (Hill et al., 2006), BPM “organizes people for greater agility” while SOA “organizes technology for greater agility”. Categorising the BPM standardsB2B: business-to-business Graphical standards. This allows users to express business processes and their possible flows and transitions in a diagrammatic way. Execution standards. It computerizes the deployment and automation of business processes. Interchange standards. It facilitates portability of data, e.g. the portability of business process designs in different graphical standards across BPMS; different execution standards across disparate BPMS, and the context-less translation of graphical standards to execution standards and vice versa. Diagnosis standards. It provides administrative and monitoring (such as runtime and post-modeling) capabilities. These standards can identify bottlenecks, audit and query real-time the business processes in a company.]]></content>
      <tags>
        <tag>Reading Notes</tag>
        <tag>BPM</tag>
        <tag>survey</tag>
        <tag>business process management</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python快速入门：6小时精通python(六-完结)]]></title>
    <url>%2F2019%2F04%2F19%2F6%E5%B0%8F%E6%97%B6%E7%B2%BE%E9%80%9Apython-%E5%85%AD-%E5%AE%8C%E7%BB%93%2F</url>
    <content type="text"><![CDATA[译自：https://learnxinyminutes.com/docs/python3/ 阅前须知： “#”后边的是注释 带行号的是python代码 不带行号的是代码的输出 把下边的语句对着敲一边自然就会了，博主用的是jupyter notebook 123###################################################### 6. Classes#################################################### 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 通过class声明，来创建一个类# 类内方法中，self为一个保留字，代表类实例化后instance自身# 类内方法中，cls也是一个保留字，代表类class自身# 通过self.***可以给类内属性赋值，或调用类内方法class Human: # 直接定义的变量，是这个类的共享属性，所有实例都可以访问 species = "H. sapiens" # __init__是一个保留方法，用于类的实例化（生成实例时自动调用） # 注意：名称前后有双下划线__，代表这个对象或者属性是python调用、用户定义的 # 这类方法（对象、属性）包括: __init__, __str__, __repr__ etc. # 这类特殊方法，也被称作（dunder method） # 不要自己创造这类方法 def __init__(self, name): # 将参数分配给实例的name属性 self.name = name # 初始化私有属性，前方带下划线_的属性无法在外部直接访问 self._age = 0 # 这是类的一个内建方法，所有内建的方法都需要把self作为其第一个形式参数 def say(self, msg): print("&#123;name&#125;: &#123;message&#125;".format(name=self.name, message=msg)) # 另一个方法 def sing(self): return 'yo... yo... microphone check... one two... one two...' # @classmethod是一个声明，声明接下来定义的方法是该类所有实例的共享方法 # 这种方法被调用时，必须有cls作为第一个参数 # 类方法的特点在于，可以被类自身调用，如Human.get_species() @classmethod def get_species(cls): return cls.species # @staticmethod声明接下来定义的是一个静态方法 # 静态方法可以被类单独调用 @staticmethod def grunt(): return "*grunt*" # @property就是一个getter，声明该方法用于访问内部属性 # @property这个声明，将age()方法转换为同名的只读属性。 # 但是，不需要在Python中编写琐碎的getter和setter。 @property def age(self): return self._age # 如果还想要让该属性可更改，可以这么写 @age.setter def age(self, age): self._age = age # deleter可以让该属性可删除 @age.deleter def age(self): del self._age 123456789101112131415161718192021222324252627282930313233# __name__代表的是运行进程的名称# __name__ == '__main__'，判断用户是否是将该python文件当作主要脚本运行# 简单来说，if __name__ == '__main__':代码块中的内容# 只有在运行该python文件时才会生效，如果该python文件是以import形式被调用，则不会运行# 而写在if __name__ == '__main__':代码块外的内容，被import时，也会运行if __name__ == '__main__': # 生成Human类的实例 # 类名加括号，直接调用__init__方法 i = Human(name="Ian") i.say("hi") # "Ian: hi" j = Human("Joel") j.say("hello") # "Joel: hello" # i and j 是Human类的两个实例 # 调用类方法 i.say(Human.get_species()) # "Ian: H. sapiens" # 共享属性改了之后，大家都改了 Human.species = "H. neanderthalensis" i.say(i.get_species()) # =&gt; "Ian: H. neanderthalensis" j.say(j.get_species()) # =&gt; "Joel: H. neanderthalensis" # 类可以调用静态函数 print(Human.grunt()) # =&gt; "*grunt*" # 有些版本中实例是不能调用静态函数的 print(i.grunt()) # 更新实例的属性 i.age = 42 # 获取property i.say(i.age) # =&gt; "Ian: 42" j.say(j.age) # =&gt; "Joel: 0" # 删除i的age属性 del i.age Ian: hi Joel: hello Ian: H. sapiens Ian: H. neanderthalensis Joel: H. neanderthalensis *grunt* *grunt* Ian: 42 Joel: 012# 再访问i的年龄就会报错i.age --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-207-993258cc61d3&gt; in &lt;module&gt;() 1 # 再访问i的年龄就会报错 ----&gt; 2 i.age &lt;ipython-input-186-b3205f030117&gt; in age(self) 44 @property 45 def age(self): ---&gt; 46 return self._age 47 48 # 如果还想要让该属性可更改，可以这么写 AttributeError: &apos;Human&apos; object has no attribute &apos;_age&apos;12# 不仅仅是age()没了，_age这个属性是真的没了i._age --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-208-4ea879b64970&gt; in &lt;module&gt;() 1 # 不仅仅是age()没了，_age这个属性是真的没了 ----&gt; 2 i._age AttributeError: &apos;Human&apos; object has no attribute &apos;_age&apos;123###################################################### 6.1 继承#################################################### 1# 继承允许定义新的子类，这些子类从父类继承方法和变量 12345678910# 使用上面定义的Human类作为基类或父类，我们可以定义一个子类Superhero# 它继承了类的变量如“species”，“name”和“age”，# 以及“sing”和“grunt”等方法# 但superhero也可以拥有自己的属性# 如果要将文件模块化，您可以将上面的类放在自己的文件中，命名为human.py# 要从其他文件导入功能，请使用以下格式# from “filename（不加扩展名.py）” import “函数名或类名”from human import Human 123456789101112131415161718192021222324252627282930313233343536373839# 将父类当作参数写进子类定义作为声明# 如：class child(parent):class Superhero(Human): # 如果您想让子类继承父类的所有定义且没有任何修改 # 您可以只使用“pass”关键字（而不使用其他关键字） # 如 # class Human2(Human): # pass # 子类可以重写其父类的属性 species = 'Superhuman' # 子类自动继承其父类的构造函数（__init__），包括它的参数 # 但也可以定义其他参数或定义并重写其方法 # 此构造函数从“human”类继承“name”参数 # 并且添加“superpower”和“movie”参数： def __init__(self, name, movie=False, superpowers=["super strength", "bulletproofing"]): # 增加新的属性 self.fictional = True self.movie = movie # 注意可变的默认值，因为默认值是共享的 self.superpowers = superpowers # “super”是一个保留函数，该函数允许您访问父类的方法 # 下面的语句将调用父类构造函数： super().__init__(name) # 覆盖sing方法 def sing(self): return 'Dun, dun, DUN!' # 增加实例方法 def boast(self): for power in self.superpowers: print("I wield the power of &#123;pwr&#125;!".format(pwr=power)) 1234567891011121314151617181920212223242526272829303132if __name__ == '__main__': sup = Superhero(name="Tick") # 通过isinstance方法，可以判断，实例和类的关系 if isinstance(sup, Human): print('I am human') # 通过type(instance)可以得到实例的class对象 if type(sup) is Superhero: print('I am a superhero') # 通过__mro__方法，可以获取类的继承链（super方法或者getattr方法） print(Superhero.__mro__) # =&gt; (&lt;class '__main__.Superhero'&gt;, &lt;class '__main__.Human'&gt;, &lt;class 'object'&gt;) # 使用父类方法，访问子类属性 print(sup.get_species()) # =&gt; Superhuman # 调用覆盖了的方法 print(sup.sing()) # =&gt; Dun, dun, DUN! # 调用父类的方法 sup.say('Spoon') # =&gt; Tick: Spoon # 调用子类独有的方法 sup.boast() # =&gt; I wield the power of super strength! # =&gt; I wield the power of bulletproofing! # 继承了的类属性 sup.age = 31 print(sup.age) # =&gt; 31 # 子类独有的属性 print('Am I Oscar eligible? ' + str(sup.movie)) I am human I am a superhero (&lt;class &apos;__main__.Superhero&apos;&gt;, &lt;class &apos;__main__.Human&apos;&gt;, &lt;class &apos;object&apos;&gt;) Superhuman Dun, dun, DUN! Tick: Spoon I wield the power of super strength! I wield the power of bulletproofing! 31 Am I Oscar eligible? False123###################################################### 6.2 多重继承#################################################### 12345678910111213141516# 定义一个蝙蝠类class Bat: species = 'Baty' def __init__(self, can_fly=True): self.fly = can_fly # 这个类页游say的方法 def say(self, msg): msg = '... ... ...' return msg # 还有独有的方法 def sonar(self): return '))) ... (((' 1234if __name__ == '__main__': b = Bat() print(b.say('hello')) print(b.fly) ... ... ... True123# 如果您写了多个文件，就需要导入一下from superhero import Superherofrom bat import Bat 123456789101112131415161718# 定义蝙蝠侠，继承自超级英雄和蝙蝠两个类class Batman(Superhero, Bat): def __init__(self, *args, **kwargs): # 通常，要继承属性，必须调用super # 然而，我们在这里处理多个继承 # 而super（）只适用于MRO列表中的下一个基类。 # 因此，我们明确地为所有祖先(父类)调用__init__ # 使用“*args”和“*kwargs”可以以一种干净的方式传递参数 # 每个父类“剥一层洋葱皮” Superhero.__init__(self, 'anonymous', movie=True, superpowers=['Wealthy'], *args, **kwargs) Bat.__init__(self, *args, can_fly=False, **kwargs) # override the value for the name attribute self.name = 'Sad Affleck' def sing(self): return 'nan nan nan nan nan batman!' 12345678910111213141516171819202122232425262728if __name__ == '__main__': sup = Batman() # 通过__mro__方法，可以获取类的继承链（super方法或者getattr方法） print(Batman.__mro__) # =&gt; (&lt;class '__main__.Batman'&gt;, # =&gt; &lt;class 'superhero.Superhero'&gt;, # =&gt; &lt;class 'human.Human'&gt;, # =&gt; &lt;class 'bat.Bat'&gt;, &lt;class 'object'&gt;) # 调用父类方法获取子类属性 print(sup.get_species()) # =&gt; Superhuman # 调用覆盖后的方法 print(sup.sing()) # =&gt; nan nan nan nan nan batman! # 两个父类有重名方法时，顺序在前的优先级更高 sup.say('I agree') # =&gt; Sad Affleck: I agree # 调用第二父类方法 print(sup.sonar()) # =&gt; ))) ... ((( # 继承类属性 sup.age = 100 print(sup.age) # =&gt; 100 # 输出从第二父类继承的属性，该属性已被覆盖 print('Can I fly? ' + str(sup.fly)) # =&gt; Can I fly? False (&lt;class &apos;__main__.Batman&apos;&gt;, &lt;class &apos;__main__.Superhero&apos;&gt;, &lt;class &apos;__main__.Human&apos;&gt;, &lt;class &apos;__main__.Bat&apos;&gt;, &lt;class &apos;object&apos;&gt;) Superhuman nan nan nan nan nan batman! Sad Affleck: I agree ))) ... ((( 100 Can I fly? False123###################################################### 7. Advanced#################################################### 1234# 生成器可以帮你偷很多懒def double_numbers(iterable): for i in iterable: yield i + i 123456789# 生成器可以节省很多内存# 因为它们只加载所需处理iterable中的下一个值的数据(边生成边处理)# 普通方法需要 先生成后处理# 这使其可以进行大范围的数据操作（其他方法可能不行）# 注意：python 3中，“range”替换了“xrange”for i in double_numbers(range(1, 900000000)): # `range` is a generator. print(i) if i &gt;= 30: break 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30123456# 正如可以创建列表理解一样，也可以创建生成器理解# 这里，圆括号是关键，你以为是tuples，实际上是生成器values = (-x for x in [1,2,3,4,5])print(values)for x in values: print(x) # prints -1 -2 -3 -4 -5 to console/terminal &lt;generator object &lt;genexpr&gt; at 0x102e9c990&gt; -1 -2 -3 -4 -51234# 也可以直接把一个生成器理解投射到list上values = (-x for x in [1,2,3,4,5])gen_to_list = list(values)print(gen_to_list) # =&gt; [-1, -2, -3, -4, -5] [-1, -2, -3, -4, -5]123456789101112131415161718192021# 修饰器from functools import wrapsdef beg(target_function): @wraps(target_function) def wrapper(*args, **kwargs): msg, say_please = target_function(*args, **kwargs) if say_please: return "&#123;&#125; &#123;&#125;".format(msg, "Please! I am poor :(") return msg return wrapper# 这里通过beg修饰say# 可以改变say的输出@begdef say(say_please=False): msg = "Can you buy me a beer?" return msg, say_please 12print(say()) # Can you buy me a beer?print(say(say_please=True)) # Can you buy me a beer? Please! I am poor :( Can you buy me a beer? Can you buy me a beer? Please! I am poor :(]]></content>
      <categories>
        <category>Learn X in Y minutes</category>
        <category>Learn Python in Y minutes</category>
      </categories>
      <tags>
        <tag>6小时精通python</tag>
        <tag>python</tag>
        <tag>python3</tag>
        <tag>python精通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python快速入门：6小时精通python(五)]]></title>
    <url>%2F2019%2F04%2F19%2F6%E5%B0%8F%E6%97%B6%E7%B2%BE%E9%80%9Apython-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[译自：https://learnxinyminutes.com/docs/python3/ 阅前须知： “#”后边的是注释 带行号的是python代码 不带行号的是代码的输出 把下边的语句对着敲一边自然就会了，博主用的是jupyter notebook 123###################################################### 5. 模块#################################################### 123# 可以通过import语句导入模块（包）import mathprint(math.sqrt(16)) # =&gt; 4.0 4.01234# 也可以通过from import语句，从包中调用特定函数from math import ceil, floorprint(ceil(3.7)) # =&gt; 4.0print(floor(3.7)) # =&gt; 3.0 4 3123# 也可以通过*，导入包中所有函数# 不建议这样做，命名空间容易冲突（重名）from math import * 123# 也可以通过import as语句来对包名进行缩写import math as mmath.sqrt(16) == m.sqrt(16) # =&gt; True True12345# Python包都是提前写好普通的python文件# 也可以自己写，import名称为文件名# 通过dir方法，可以看包中所有方法的directoryimport mathdir(math) [&apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;acos&apos;, &apos;acosh&apos;, &apos;asin&apos;, &apos;asinh&apos;, &apos;atan&apos;, &apos;atan2&apos;, &apos;atanh&apos;, &apos;ceil&apos;, &apos;copysign&apos;, &apos;cos&apos;, &apos;cosh&apos;, &apos;degrees&apos;, &apos;e&apos;, &apos;erf&apos;, &apos;erfc&apos;, &apos;exp&apos;, &apos;expm1&apos;, &apos;fabs&apos;, &apos;factorial&apos;, &apos;floor&apos;, &apos;fmod&apos;, &apos;frexp&apos;, &apos;fsum&apos;, &apos;gamma&apos;, &apos;gcd&apos;, &apos;hypot&apos;, &apos;inf&apos;, &apos;isclose&apos;, &apos;isfinite&apos;, &apos;isinf&apos;, &apos;isnan&apos;, &apos;ldexp&apos;, &apos;lgamma&apos;, &apos;log&apos;, &apos;log10&apos;, &apos;log1p&apos;, &apos;log2&apos;, &apos;modf&apos;, &apos;nan&apos;, &apos;pi&apos;, &apos;pow&apos;, &apos;radians&apos;, &apos;sin&apos;, &apos;sinh&apos;, &apos;sqrt&apos;, &apos;tan&apos;, &apos;tanh&apos;, &apos;tau&apos;, &apos;trunc&apos;]123# 如果你调用了一个自己写的包# 其名称和内建包重复# 则默认调用自己写的]]></content>
      <categories>
        <category>Learn X in Y minutes</category>
        <category>Learn Python in Y minutes</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python快速入门：6小时精通python(四)]]></title>
    <url>%2F2019%2F04%2F19%2F6%E5%B0%8F%E6%97%B6%E7%B2%BE%E9%80%9Apython-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[译自：https://learnxinyminutes.com/docs/python3/ 阅前须知： “#”后边的是注释 带行号的是python代码 不带行号的是代码的输出 把下边的语句对着敲一边自然就会了，博主用的是jupyter notebook 123###################################################### 4. Functions#################################################### 12345# 通过def保留字来定义函数def add(x, y): print("x is &#123;&#125; and y is &#123;&#125;".format(x, y)) # return语句用来返回处理结果 return x + y 123# 定义之后可以带参调用c = add(5, 6)print(c) x is 5 and y is 6 11123# 如果不按照顺序输入参数，需要添加形式参数名称c = add(y=6, x=5)print(c) x is 5 and y is 6 111234# 也可以传入参数列表（positional arguments）def varargs(*args): print(type(args)) return args 12c = varargs(1, 2, 3)print(c) &lt;class &apos;tuple&apos;&gt; (1, 2, 3)1234# 可以通过keyword arguments来传入多个变量def keyword_args(**kwargs): print(type(kwargs)) return kwargs 12c = keyword_args(one='1', two='2')print(c) &lt;class &apos;dict&apos;&gt; {&apos;one&apos;: &apos;1&apos;, &apos;two&apos;: &apos;2&apos;}12345678910# 也可以混合使用def all_the_args(*args, **kwargs): print(args) print(kwargs)"""all_the_args(1, 2, a=3, b=4) prints: (1, 2) &#123;"a": 3, "b": 4&#125;""" 123456# 调用函数的时候，*和**也可以反过来使用args_call = (1, 2, 3, 4)kwargs_call = &#123;"a": 3, "b": 4&#125;all_the_args(*args_call) # equivalent to all_the_args(1, 2, 3, 4)all_the_args(**kwargs_call) # equivalent to all_the_args(a=3, b=4)all_the_args(*args_call, **kwargs_call) # equivalent to all_the_args(1, 2, 3, 4, a=3, b=4) (1, 2, 3, 4) {} () {&apos;a&apos;: 3, &apos;b&apos;: 4} (1, 2, 3, 4) {&apos;a&apos;: 3, &apos;b&apos;: 4}12345# 一个函数可以同时返回多个值# 多个值是以不带括号的tuple的形式返回的# 但是加了括号也没关系def swap(x, y): return y, x 1234x = 1y = 2x, y = swap(x, y) # =&gt; x = 2, y = 1(x, y) = swap(x, y) # 这一句和上一句一样 123456789101112131415161718192021# 函数范围 # 这里x是一个全局变量（global）x = 5def get_x(num): # 函数内部可以访问外部全局变量 print(num) print(x) # =&gt; 5def set_x(num): # 但是不能在函数内部改变全局变量 # 这里的x是一个新生成的，只在函数内生效的局部变量 x = num # =&gt; 43 print(x) # =&gt; 43def set_global_x(num): # 如果想要在函数内部改变全局变量，需要通过global声明 global x print(x) # =&gt; 5 x = num # global var x is now set to num print(x) # =&gt; num 1get_x(6) 6 512set_x(6)print(x) 6 512set_global_x(6)print(x) 5 6 61234567891011# python支持头等函数# 简单来讲，return的函数就是上层函数的头等函数def create_adder(x): # suber就是简单的嵌套定义了一个函数 def suber(z): return x - z n = suber(5) # adder参与返回值，是头等函数 def adder(y): return n + y return adder 1add_10_minus_5 = create_adder(10) 1add_10_minus_5(3) 8123# python也支持匿名函数# (lambda &lt;形式参数（列表）&gt;: &lt;return语句&gt;)(&lt;实参&gt;)(lambda x: x &gt; 2)(3) # =&gt; True True1(lambda x, y: x ** 2 + y ** 2)(2, 1) # =&gt; 5 512# 匿名函数，实际上也是可以命名的check_greater_than_2 = lambda x: x &gt; 2 1check_greater_than_2(4) True1234# 还有内建的高阶函数# 通过map将[1, 2, 3]分别装入add_10_minus_5进行运算# 返回结果包装成listlist(map(add_10_minus_5, [1, 2, 3])) [6, 7, 8]12# max是python的内建方法，求参数中的最大值max(1,2,3) 3123# 下面的写法就是就是对位结合，进行计算# 相当于list(max(1,4), max(2,2), max(3,1))list(map(max, [1, 2, 3], [4, 2, 1])) [4, 2, 3]12# filter 可以把返回值为true的参数，返回出来list(filter(lambda x: x &gt; 5, [3, 4, 5, 6, 7])) # =&gt; [6, 7] [6, 7]12# 也可以根据对列表的理解，写出漂亮的map和filter[add_10_minus_5(i) for i in [1, 2, 3]] [6, 7, 8]1[x for x in [3, 4, 5, 6, 7] if x &gt; 5] # =&gt; [6, 7] [6, 7]12# 也可以写出漂亮的字典或者集合&#123;x for x in 'abcddeef' if x not in 'abc'&#125; # =&gt; &#123;'d', 'e', 'f'&#125; {&apos;d&apos;, &apos;e&apos;, &apos;f&apos;}1&#123;x: x**2 for x in range(5)&#125; # =&gt; &#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16&#125; {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}]]></content>
      <categories>
        <category>Learn X in Y minutes</category>
        <category>Learn Python in Y minutes</category>
      </categories>
      <tags>
        <tag>6小时精通python</tag>
        <tag>python</tag>
        <tag>python3</tag>
        <tag>python精通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python快速入门：6小时精通python(三)]]></title>
    <url>%2F2019%2F04%2F19%2F6%E5%B0%8F%E6%97%B6%E7%B2%BE%E9%80%9Apython-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[译自：https://learnxinyminutes.com/docs/python3/ 阅前须知： “#”后边的是注释 带行号的是python代码 不带行号的是代码的输出 把下边的语句对着敲一边自然就会了，博主用的是jupyter notebook 123###################################################### 3. 控制流和迭代器#################################################### 123456789some_var = 5# python通过缩进来对代码进行分段（连续同缩进量的代码可以看作在一个大括号里，空行、注释行自动忽略）# 一个缩进应该是4个空格，不是制表符if some_var &gt; 10: print("some_var is totally bigger than 10.")elif some_var &lt; 10: # 可选 print("some_var is smaller than 10.")else: # 可选 print("some_var is indeed 10.") some_var is smaller than 10.12345# for item in list# 迭代取出list中的所有item进行计算for animal in ["dog", "cat", "mouse"]: # You can use format() to interpolate formatted strings print("&#123;&#125; is a mammal".format(animal)) dog is a mammal cat is a mammal mouse is a mammal123# range(n)方法返回一个list,[0,1,2,...,n-1]for i in range(4): print(i) 0 1 2 3123# range(start,end)返回一个list，[start, start+1, ..., end-1]for i in range(4, 8): print(i) 4 5 6 7123# range(start,end,step)返回一个list，[start, start+step, ..., (直到&gt;=end)]for i in range(4, 8, 2): print(i) 4 612345# while循环，持续迭代知道不满足判断条件x = 0while x &lt; 4: print(x) x += 1 # Shorthand for x = x + 1 0 1 2 312345678910111213141516# 可以通过try except来处理异常（避免报错直接退出）try: # raise方法，可以手动报错 raise IndexError("This is an index error")except IndexError as e: # pass保留字代表这一行啥不也干 passexcept (TypeError, NameError): # 如果有多个except，可以同时执行 pass# 可选，如果try的代码块没有问题，则执行else: print("All good!")# 可选，不管有没有问题，都会执行finally中的代码块finally: print("We can clean up resources here") We can clean up resources here12345678910# 通常open(fileName)之后，需要调用close方法来释放内存# 为了避免代码出错，产生内存垃圾，需要# try:# open# finally:# close# 也可以通过with open() as name:来进行声明，该声明块结束后会自动closewith open("myfile.txt") as f: for line in f: print(line) 123456# Python提供一种基础抽象方法叫做Iterable（可迭代的）# 一个iterable对象，可以被当作sequence对待# range函数返回的对象其实就是iterablefilled_dict = &#123;"one": 1, "two": 2, "three": 3&#125;our_iterable = filled_dict.keys()print(our_iterable) # =&gt; dict_keys(['one', 'two', 'three']). This is an object that implements our Iterable interface. dict_keys([&apos;one&apos;, &apos;two&apos;, &apos;three&apos;])123# iterable 可迭代，比如放到for循环中for i in our_iterable: print(i) one two three123# 但是无法通过index取出其中的数值# 会报错our_iterable[0] --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-114-138f56ebc699&gt; in &lt;module&gt;() 1 # 但是无法通过index取出其中的数值 2 # 会报错 ----&gt; 3 our_iterable[0] TypeError: &apos;dict_keys&apos; object does not support indexing12# iterable对象可以通过iter方法生成迭代器our_iterator = iter(our_iterable) 1our_iterator &lt;dict_keyiterator at 0x102e49db8&gt;123# 迭代器可以在遍历过程中记录当前状态（位置）# 我们可以通过next函数取出迭代器中的下一个itemnext(our_iterator) # =&gt; "one" &apos;one&apos;123# 当前迭代的位置会被存储下来next(our_iterator) # =&gt; "two"next(our_iterator) # =&gt; "three" &apos;three&apos;12# 超出迭代范围，就报错next(our_iterator) --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) &lt;ipython-input-119-228a51d4a8ec&gt; in &lt;module&gt;() ----&gt; 1 next(our_iterator) StopIteration: 12# 通过list方法把iterable转化为list，就可以访问所有对象了list(filled_dict.keys()) # =&gt; Returns ["one", "two", "three"] [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]]]></content>
      <categories>
        <category>Learn X in Y minutes</category>
        <category>Learn Python in Y minutes</category>
      </categories>
      <tags>
        <tag>6小时精通python</tag>
        <tag>python</tag>
        <tag>python3</tag>
        <tag>python精通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python快速入门：6小时精通python(二)]]></title>
    <url>%2F2019%2F04%2F19%2F6%E5%B0%8F%E6%97%B6%E7%B2%BE%E9%80%9Apython-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[译自：https://learnxinyminutes.com/docs/python3/ 阅前须知： “#”后边的是注释 带行号的是python代码 不带行号的是代码的输出 把下边的语句对着敲一边自然就会了，博主用的是jupyter notebook 123###################################################### 2. 变量和集合#################################################### 123# 输出用print()print("I'm Python. Nice to meet you!")print("I'm Python. Nice to meet you!") I&apos;m Python. Nice to meet you! I&apos;m Python. Nice to meet you!1234# print函数默认在结束时插入换行符# 可以通过end参数改变print("Hello, World", end="!")print("Hello, World", end="!") Hello, World!Hello, World!123# 在console命令行中获得输入，可以使用input，参数会作为提示进行输出# Note: 在python早期版本中，input函数名称为raw_inputinput_string_var = input("Enter some data: ") Enter some data: 1231input_string_var &apos;123&apos;1234# python中没有变量声明，只有赋值# 变量的命名惯例为小写字母，多个单词通过_连接： lower_case_with_underscoressome_var = 5some_var # =&gt; 5 5123# 访问一个没有赋值过的变量名，会抛出异常# 直接看console中的输出来了解异常原因some_unknown_var --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-48-17aa7cb5f29d&gt; in &lt;module&gt;() 1 # 访问一个没有赋值过的变量名，会抛出异常 2 # 直接看console中的输出来了解异常原因 ----&gt; 3 some_unknown_var NameError: name &apos;some_unknown_var&apos; is not defined1234# if 可以用来作为一种表达式 # a if b else c 意为 b为True取a，b为False取choo = "yahoo!" if 3 &gt; 2 else 2 # =&gt; "yahoo!"hoo &apos;yahoo!&apos;1234# 生成一个空的listli = []# 也可以跳过声明直接赋值other_li = [4, 5, 6] 123456789# list有append函数，可以在末尾添加itemli.append(1) # li is now [1]li.append(2) # li is now [1, 2]li.append(4) # li is now [1, 2, 4]li.append(3) # li is now [1, 2, 4, 3]# pop函数可以删除list中的最后一个元素li.pop() # =&gt; 3 and li is now [1, 2, 4]# 还是把3放回去吧li.append(3) # li is now [1, 2, 4, 3] again. 1234# 通过item的index可以访问对应位置item的值li[0] # =&gt; 1# 可以通过负数来倒着数，-1代表最后一个li[-1] # =&gt; 3 312# 如果index访问的item超出list长度，会抛出异常li[4] # IndexError --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-53-9bf3eba2f737&gt; in &lt;module&gt;() 1 # 如果index访问的item超出list长度，会抛出异常 ----&gt; 2 li[4] # Raises an IndexError IndexError: list index out of range12345678910# li[start:end:step]，你可以通过分片来对list进行部分访问# li[a:b]，意为取出li中index为a的item至index为b-1的item（含头不含尾）li[1:3] # =&gt; [2, 4]# 省略头/尾的参数，则代表 从头开始/到尾结束li[:3] # =&gt; [1, 2, 4]li[2:] # =&gt; [4, 3]# li[a:b:c]意为从li中index为a开始，index每次+c取item，直至所取item的index&gt;=bli[::2] # =&gt;[1, 4]# li[a:b:c]c为负值的时候则倒着取li[::-1] # =&gt; [3, 4, 2, 1] [3, 4, 2, 1]12345# 如果要对list进行deep copy（复制object所有内容但不是同一对象）# 使用如下语句li2 = li[:]li2 == li # =&gt; Trueli2 is li # =&gt; False False12# del[index]方法可以删除list中index位置的元素del li[2] # li is now [1, 2, 3] 12# remove(value)方法会删除list中第一个值等于value的itemli.remove(2) 12# remove方法调用时，如果没有对应value的item，则会报错li.remove(100) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-58-0f5f01941ba3&gt; in &lt;module&gt;() 1 # remove方法调用时，如果没有对应value的item，则会报错 ----&gt; 2 li.remove(100) ValueError: list.remove(x): x not in list123# insert(index, value)可以在list中的index处插入值为value的itemli.insert(1, 2) # li is now [1, 2, 3] againli [1, 2, 3]1234# index(value)方法可以在list中进行查询,返回值为value的item的indexli.index(2) # =&gt; 1# 没有的话就报错li.index(4) # Raises a ValueError as 4 is not in the list --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-60-4520a794cb71&gt; in &lt;module&gt;() 2 li.index(2) # =&gt; 1 3 # 没有的话就报错 ----&gt; 4 li.index(4) # Raises a ValueError as 4 is not in the list ValueError: 4 is not in list123# 可以用+直接连接两个list# 这里没有进行赋值，所以li和other_li都没变li + other_li # =&gt; [1, 2, 3, 4, 5, 6] [1, 2, 3, 4, 5, 6]123# 如果调用list内部方法，extend进行连接，则调用方法的list会默认被赋值li.extend(other_li)li [1, 2, 3, 4, 5, 6]12# 通过in关键字，判断value是否存在在list中1 in li # =&gt; True True12# len方法可以返回list长度len(li) # =&gt; 6 61234# Tuple和list相似，但是不可变tup = (1, 2, 3)tup[0] # =&gt; 1tup[0] = 3 # 赋值就报错 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-65-4b7af0c6f896&gt; in &lt;module&gt;() 2 tup = (1, 2, 3) 3 tup[0] # =&gt; 1 ----&gt; 4 tup[0] = 3 # 赋值就报错 TypeError: &apos;tuple&apos; object does not support item assignment12345# 如果长度为1的tuple，需要在唯一的item后添加逗号','来声明自己是tuple# 否则python会把它的类型解析成唯一item的类型type((1)) # =&gt; &lt;class 'int'&gt;type((1,)) # =&gt; &lt;class 'tuple'&gt;type(()) # =&gt; &lt;class 'tuple'&gt; tuple12345# 大部分list操作都可以应用到tuple上len(tup) # =&gt; 3tup + (4, 5, 6) # =&gt; (1, 2, 3, 4, 5, 6)tup[:2] # =&gt; (1, 2)2 in tup # =&gt; True True12345678# 可以对tuple进行解压，分别赋值给变量a, b, c = (1, 2, 3) # a = 1, b = 2 and c = 3# 还可以进行扩展拆包a, *b, c = (1, 2, 3, 4) # a = 1, b = [2, 3] and c = 4# 如果你不写括号，tuple也会自动生成d, e, f = 4, 5, 6# 交换两个变量的值e, d = d, e # d is now 5 and e is now 4 12345# Dictionary存储的是key到value的映射# 生成空的dictempty_dict = &#123;&#125;# 也可以直接赋值filled_dict = &#123;"one": 1, "two": 2, "three": 3&#125; 12# 可以通过方括号dict[key] = value 查询对应key的值filled_dict['one'] 11234# dictionary中的key必须是不可变类型量（immutable type）# Immutable types 包括 ints, floats, strings, tuples.# value是啥都行invalid_dict = &#123;[1,2,3]: "123"&#125; # =&gt; TypeError: unhashable type: 'list' --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-71-b260036dbc7a&gt; in &lt;module&gt;() 2 # Immutable types 包括 ints, floats, strings, tuples. 3 # value是啥都行 ----&gt; 4 invalid_dict = {[1,2,3]: &quot;123&quot;} # =&gt; TypeError: unhashable type: &apos;list&apos; TypeError: unhashable type: &apos;list&apos;123456# 通过dictionary中的keys()方法，可以迭代取出字典中的key# 通过list()可以将该方法的结果转化为list# python3.7之前的版本，不保证key的取出顺序# python3.7之后，key会按照在字典中的顺序取出list(filled_dict.keys()) # =&gt; ["three", "two", "one"] in Python &lt;3.7list(filled_dict.keys()) # =&gt; ["one", "two", "three"] in Python 3.7+ [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]123# 同理，通过values方法可以取出valueslist(filled_dict.values()) # =&gt; [3, 2, 1] in Python &lt;3.7list(filled_dict.values()) # =&gt; [1, 2, 3] in Python 3.7+ [1, 2, 3, 5]123# 通过in保留字，来检查dictionary中是否包含该key（而非value）"one" in filled_dict # =&gt; True1 in filled_dict # =&gt; False False12# 取一个字典中不存在的key的value会报错filled_dict["four"] # KeyError --------------------------------------------------------------------------- KeyError Traceback (most recent call last) &lt;ipython-input-75-6e19dabe2a92&gt; in &lt;module&gt;() 1 # 取一个字典中不存在的key的value会报错 ----&gt; 2 filled_dict[&quot;four&quot;] # KeyError KeyError: &apos;four&apos;123456# 通过get方法，可以避免报错，如果没有，返回Nonefilled_dict.get("one") # =&gt; 1filled_dict.get("four") # =&gt; None# 也可以在get方法中增加第二个参数，来代替查询不到时，默认返回的Nonefilled_dict.get("one", 4) # =&gt; 1filled_dict.get("four", 4) # =&gt; 4 41234# setdefault方法可以给不存在的key赋值# 如果该键值对（key:value）已存在，则不生效filled_dict.setdefault("five", 5) # filled_dict["five"] is set to 5filled_dict.setdefault("five", 6) # filled_dict["five"] is still 5 51234# 在dictionary中增加键值对，可以使用update方法filled_dict.update(&#123;"four":4&#125;) # =&gt; &#123;"one": 1, "two": 2, "three": 3, "four": 4&#125;# 直接对不存在的key 进行赋值，也可以实现键值对的增加filled_dict["four"] = 4 # another way to add to dict 12# 通过del方法可以删除对应key的键值对del filled_dict["one"] # Removes the key "one" from filled dict 123# 在python3.5之后，也可以通过**&#123;&#125;来完成补充扩展操作&#123;'a': 1, **&#123;'b': 2&#125;&#125; # =&gt; &#123;'a': 1, 'b': 2&#125;&#123;'a': 1, **&#123;'a': 2&#125;&#125; # =&gt; &#123;'a': 2&#125; {&apos;a&apos;: 2}1234# set也是通过&#123;&#125;进行包装的，定义空set时，需要调用set方法empty_set = set()# set中的值不能重复（重复值会自动合并）some_set = &#123;1, 1, 2, 2, 3, 4&#125; # some_set is now &#123;1, 2, 3, 4&#125; 123# 和dictionary中的key相似，set的item必须是不可变类型量（也就是list不行）# set可以看作是一个只有key的dictionaryinvalid_set = &#123;[1], 1&#125; # =&gt; Raises a TypeError: unhashable type: 'list' --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-85-c6f31d84eee9&gt; in &lt;module&gt;() 1 # 和dictionary中的key相似，set的item必须是不可变类型量（也就是list不行） 2 # set可以看作是一个只有key的dictionary ----&gt; 3 invalid_set = {[1], 1} # =&gt; Raises a TypeError: unhashable type: &apos;list&apos; 4 # tuple就可以 5 valid_set = {(1,), 1} TypeError: unhashable type: &apos;list&apos;12345# 通过add方法向set中添加itemfilled_set = some_setfilled_set.add(5) # filled_set is now &#123;1, 2, 3, 4, 5&#125;# 重复添加无效filled_set.add(5) # it remains as before &#123;1, 2, 3, 4, 5&#125; 123# 可以通过&amp;运算，来取交集other_set = &#123;3, 4, 5, 6&#125;filled_set &amp; other_set # =&gt; &#123;3, 4, 5&#125; {3, 4, 5}12# 可以通过|取并集filled_set | other_set # =&gt; &#123;1, 2, 3, 4, 5, 6&#125; {1, 2, 3, 4, 5, 6}12# 也可以通过-做集合减法（第一个有第二个没有的）&#123;1, 2, 3, 4&#125; - &#123;2, 3, 5&#125; # =&gt; &#123;1, 4&#125; {1, 4}12# 可以通过^做对称减法（相当于并集减交集）&#123;1, 2, 3, 4&#125; ^ &#123;2, 3, 5&#125; # =&gt; &#123;1, 4, 5&#125; {1, 4, 5}123# 通过大于小于号检查包含关系&#123;1, 2&#125; &gt;= &#123;1, 2, 3&#125; # =&gt; False&#123;1, 2&#125; &lt;= &#123;1, 2, 3&#125; # =&gt; True True123# 通过in检查set中是否存在该item2 in filled_set # =&gt; True10 in filled_set # =&gt; False False]]></content>
      <categories>
        <category>Learn X in Y minutes</category>
        <category>Learn Python in Y minutes</category>
      </categories>
      <tags>
        <tag>6小时精通python</tag>
        <tag>python</tag>
        <tag>python3</tag>
        <tag>python精通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python快速入门：6小时精通python(一)]]></title>
    <url>%2F2019%2F04%2F19%2F6%E5%B0%8F%E6%97%B6%E7%B2%BE%E9%80%9Apython-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[译自：https://learnxinyminutes.com/docs/python3/ 阅前须知： “#”后边的是注释 带行号的是python代码 不带行号的是代码的输出 把下边的语句对着敲一边自然就会了，博主用的是jupyter notebook 123###################################################### 1. 简单数据类型和运算#################################################### 12# 数学运算1 + 1 212# 除法默认会返回float（与python2不同）10 / 2 5.012# 除法取整(乡下取整)5 // 3 11-5 // 3 -212# 如果需要返回float，至少需要有一个参与运算的数字是float5 // 3.0 1.012# 余数运算7 % 3 112# 幂运算2 ** 3 8123456789101112131415# # &amp; | ^ ~是按位运算符，这里不讲了# # &lt;&lt; &gt;&gt; 是移位运算符，这里就不展示了# a = 0011 1100# b = 0000 1101# -----------------# a&amp;b = 0000 1100# a|b = 0011 1101# a^b = 0011 0001# ~a = 1100 0011 12# 使用括号强制优先(1 + 3) * 2 8123# Boolean值有保留字TrueFalse 123# 取反用关键字notnot Truenot False 12# 逻辑运算 and orTrue and False False1True or False True1234# 参与数字运算的时候 True默认为1 False为0True + True # =&gt; 2True * 8 # =&gt; 8False - 5 # =&gt; -5 12345# 与数字进行比较运算时，也按照1 0 来进行比较0 == False # =&gt; True1 == True # =&gt; True2 == True # =&gt; False-5 != False # =&gt; True 12345# 可以通过bool()，将int数值投射到bool值上# 出了0是False，其他都是Truebool(0) # =&gt; Falsebool(4) # =&gt; Truebool(-6) # =&gt; True 123# 用boolean运算符直接对int数值进行计算，计算过程按照bool，返回的值依然是int0 and 2 # =&gt; 0-5 or 0 # =&gt; -5 123# 赋值是单等号 =，相等判断是双等号 ==1 == 1 # =&gt; True2 == 1 # =&gt; False 123# 不相等判断 !=1 != 1 # =&gt; False2 != 1 # =&gt; True 12345# 数学比较1 &lt; 10 # =&gt; True1 &gt; 10 # =&gt; False2 &lt;= 2 # =&gt; True2 &gt;= 2 # =&gt; True 123456# 判断2是否在一个范围内1 &lt; 2 and 2 &lt; 3 # =&gt; True4 &lt; 2 and 2 &lt; 5 # =&gt; False# 也可以通过链式写法1 &lt; 2 &lt; 3 # =&gt; True4 &lt; 2 &lt; 5 # =&gt; False 1234567891011# 赋值是单等号 =，相等判断是双等号 ==# 还有一个相等判断保留字 is# is 判断前后两者是否指向同一个对象（如果是两个对象，就算值相同，也会返回False）# == 只判断值是否相同a = [1, 2, 3, 4] # Point a at a new list, [1, 2, 3, 4]b = a # Point b at what a is pointing tob is a # =&gt; True, a and b refer to the same objectb == a # =&gt; True, a's and b's objects are equalb = [1, 2, 3, 4] # Point b at a new list, [1, 2, 3, 4]b is a # =&gt; False, a and b do not refer to the same objectb == a # =&gt; True, a's and b's objects are equal 123# 通过‘或者“可以创建string"This is a string."'This is also a string.' 1234# String也可以通过+连接，但是尽量不要"Hello " + "world!" # =&gt; "Hello world!"# 中间不写，也会自动连接"Hello " "world!" # =&gt; "Hello world!" &apos;Hello world!&apos;12# 一个string可以看作是一个char的list"This is a string"[0] # =&gt; 'T' &apos;T&apos;12# len()是一个保留函数，可以计算list的长度len("This is a string") # =&gt; 16 1612# python中的string对象，有.format方法，可以用来对该string进行格式化操作"&#123;&#125; can be &#123;&#125;".format("Strings", "interpolated") # =&gt; "Strings can be interpolated" &apos;Strings can be interpolated&apos;12# 可以通过在大括号&#123;&#125;中添加format参数的index来进行填充指定"&#123;0&#125; be nimble, &#123;0&#125; be quick, &#123;0&#125; jump over the &#123;1&#125;".format("Jack", "candle stick") &apos;Jack be nimble, Jack be quick, Jack jump over the candle stick&apos;12# 也可以给format中的参数命名，来代替index."&#123;name&#125; wants to eat &#123;food&#125;".format(name="Bob", food="lasagna") &apos;Bob wants to eat lasagna&apos;12# 如果需要兼容python2，老版的format写法如下"%s can be %s the %s way" % ("Strings", "interpolated", "old") &apos;Strings can be interpolated the old way&apos;12345# 在python3.6之后的版本中，可以在string前加f来进行format操作name = "Reiko"f"She said her name is &#123;name&#125;." # =&gt; "She said her name is Reiko"# 在大括号中，也可以调用python的方法f"&#123;name&#125; is &#123;len(name)&#125; characters long." &apos;Reiko is 5 characters long.&apos;12345# None也是一个对象，不是一个值Nonea1 = Falseb1 = Nonea1 is b1 False1234# 不要用==来和None进行比较# 要通过is来判断变量是不是None"etc" is None # =&gt; FalseNone is None # =&gt; True True1234567# None, 0, 以及空的 strings/lists/dicts/tuples 都等于 False.# All other values are Truebool(0) # =&gt; Falsebool("") # =&gt; Falsebool([]) # =&gt; Falsebool(&#123;&#125;) # =&gt; Falsebool(()) # =&gt; False False]]></content>
      <categories>
        <category>Learn X in Y minutes</category>
        <category>Learn Python in Y minutes</category>
      </categories>
      <tags>
        <tag>6小时精通python</tag>
        <tag>python</tag>
        <tag>python3</tag>
        <tag>python精通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过python进行数据分析(二)]]></title>
    <url>%2F2019%2F04%2F15%2F%E9%80%9A%E8%BF%87python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Counting time zones with pandas1234# %matplotlib主要是在使用jupyter notebook 或者 jupyter qtconsole的时候才会用到# 具体作用是当你调用matplotlib.pyplot的绘图函数plot()进行绘图的时候，可以直接在你的python console里面生成图像# 默认是弹出一个绘图窗口%matplotlib inline 123456789101112131415161718# python有多个版本，Python 2.7到Python 3.x，Python提供了__future__模块，把3.x新版本的特性导入到当前版本# 这一句的意思是除法按照python3来：# 区别就是python2里边10/3=3，python3里边10/3=3.3333333333333335from __future__ import division# 导入numpy中的随机函数randnfrom numpy.random import randn# 到处numpy包，并命名为npimport numpy as np# 导入os包import os# 导入matplotlib.pyplot，并命名为plt，主要用于绘图import matplotlib.pyplot as plt# 导入pandas包，并命名为pdimport pandas as pd# 利用rc方法，plt.rc('figure',figsize=(10,6))全局默认图像大小为10X6plt.rc('figure', figsize=(10, 6))# numpy set print options 小数点后4位np.set_printoptions(precision=4) 1234567# 导入json包import json# 赋值path = 'ch02/usagov_bitly_data2012-03-16-1331923249.txt'# 逐行遍历path文件中的数据，通过按照json格式读取，然后每一行的作为一个item组成listlines = open(path).readlines()records = [json.loads(line) for line in lines] 123456789# 导入pandas的两个方法from pandas import DataFrame, Series# 导入pandas包，并命名为pdimport pandas as pd# 建立DataFrame对象，把key作为列名，value作为值填到一张表中，没有的键值对会用NaN（空值）填充# 并自动生成索引，就是左边的0 1 2 3...frame = DataFrame(records)# 打印出来看一下（这是一个pandas对象）print(frame) _heartbeat_ a \ 0 NaN Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... 1 NaN GoogleMaps/RochesterNY 2 NaN Mozilla/4.0 (compatible; MSIE 8.0; Windows NT ... 3 NaN Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8)... 4 NaN Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... 5 NaN Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... 6 NaN Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1... 7 NaN Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/2... 8 NaN Opera/9.80 (X11; Linux zbov; U; en) Presto/2.1... 9 NaN Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... 10 NaN Mozilla/5.0 (Windows NT 6.1; WOW64; rv:10.0.2)... 11 NaN Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.4... 12 NaN Mozilla/5.0 (Windows NT 6.1; WOW64; rv:10.0.2)... 13 1.331923e+09 NaN 14 NaN Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US... 15 NaN Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1... 16 NaN Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1... 17 NaN Mozilla/5.0 (Macintosh; Intel Mac OS X 10.5; r... 18 NaN GoogleMaps/RochesterNY 19 NaN Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... 20 NaN Mozilla/5.0 (compatible; MSIE 9.0; Windows NT ... 21 NaN Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6... 22 NaN Mozilla/4.0 (compatible; MSIE 8.0; Windows NT ... 23 NaN Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3)... 24 NaN Mozilla/5.0 (Windows; U; Windows NT 5.1; es-ES... 25 NaN Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1... 26 NaN Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1... 27 NaN Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8)... 28 NaN Mozilla/5.0 (iPad; CPU OS 5_0_1 like Mac OS X)... 29 NaN Mozilla/5.0 (iPad; U; CPU OS 3_2 like Mac OS X... ... ... ... 3530 NaN Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1... 3531 NaN Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6... 3532 NaN Mozilla/5.0 (Windows NT 6.1; WOW64; rv:10.0.2)... 3533 NaN Mozilla/5.0 (iPad; CPU OS 5_1 like Mac OS X) A... 3534 NaN Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8)... 3535 NaN Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/... 3536 NaN Mozilla/5.0 (BlackBerry; U; BlackBerry 9800; e... 3537 NaN Mozilla/5.0 (Windows NT 6.1; WOW64; rv:10.0.2)... 3538 NaN Mozilla/5.0 (iPhone; CPU iPhone OS 5_1 like Ma... 3539 NaN Mozilla/5.0 (compatible; Fedora Core 3) FC3 KDE 3540 NaN Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... 3541 NaN Mozilla/5.0 (X11; U; OpenVMS AlphaServer_ES40;... 3542 NaN Mozilla/5.0 (compatible; MSIE 9.0; Windows NT ... 3543 1.331927e+09 NaN 3544 NaN Mozilla/5.0 (Windows NT 6.1; WOW64; rv:5.0.1) ... 3545 NaN Mozilla/5.0 (Windows NT 6.1; WOW64; rv:10.0.2)... 3546 NaN Mozilla/5.0 (iPhone; CPU iPhone OS 5_1 like Ma... 3547 NaN Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8)... 3548 NaN Mozilla/5.0 (iPhone; CPU iPhone OS 5_1 like Ma... 3549 NaN Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... 3550 NaN Mozilla/4.0 (compatible; MSIE 8.0; Windows NT ... 3551 NaN Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... 3552 NaN Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US... 3553 NaN Mozilla/4.0 (compatible; MSIE 7.0; Windows NT ... 3554 NaN Mozilla/4.0 (compatible; MSIE 7.0; Windows NT ... 3555 NaN Mozilla/4.0 (compatible; MSIE 9.0; Windows NT ... 3556 NaN Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1... 3557 NaN GoogleMaps/RochesterNY 3558 NaN GoogleProducer 3559 NaN Mozilla/4.0 (compatible; MSIE 8.0; Windows NT ... al c cy g \ 0 en-US,en;q=0.8 US Danvers A6qOVH 1 NaN US Provo mwszkS 2 en-US US Washington xxr3Qb 3 pt-br BR Braz zCaLwp 4 en-US,en;q=0.8 US Shrewsbury 9b6kNl 5 en-US,en;q=0.8 US Shrewsbury axNK8c 6 pl-PL,pl;q=0.8,en-US;q=0.6,en;q=0.4 PL Luban wcndER 7 bg,en-us;q=0.7,en;q=0.3 None NaN wcndER 8 en-US, en None NaN wcndER 9 pt-BR,pt;q=0.8,en-US;q=0.6,en;q=0.4 None NaN zCaLwp 10 en-us,en;q=0.5 US Seattle vNJS4H 11 en-us,en;q=0.5 US Washington wG7OIH 12 en-us,en;q=0.5 US Alexandria vNJS4H 13 NaN NaN NaN NaN 14 en-us,en;q=0.5 US Marietta 2rOUYc 15 zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4 HK Central District nQvgJp 16 zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4 HK Central District XdUNr 17 en-us,en;q=0.5 US Buckfield zH1BFf 18 NaN US Provo mwszkS 19 it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4 IT Venice wcndER 20 es-ES ES Alcal zQ95Hi 21 en-us,en;q=0.5 US Davidsonville wcndER 22 en-us US Hockessin y3ZImz 23 en-us US Lititz wWiOiD 24 es-es,es;q=0.8,en-us;q=0.5,en;q=0.3 ES Bilbao wcndER 25 en-GB,en;q=0.8,en-US;q=0.6,en-AU;q=0.4 MY Kuala Lumpur wcndER 26 ro-RO,ro;q=0.8,en-US;q=0.6,en;q=0.4 CY Nicosia wcndER 27 en-US,en;q=0.8 BR SPaulo zCaLwp 28 en-us None NaN vNJS4H 29 en-us None NaN FPX0IM ... ... ... ... ... 3530 en-US,en;q=0.8 US San Francisco xVZg4P 3531 en-US None NaN wcndER 3532 en-us,en;q=0.5 US Washington Au3aUS 3533 en-us US Jacksonville b2UtUJ 3534 en-us US Frisco vNJS4H 3535 en-us US Houston zIgLx8 3536 en-US,en;q=0.5 None NaN xIcyim 3537 es-es,es;q=0.8,en-us;q=0.5,en;q=0.3 HN Tegucigalpa zCaLwp 3538 en-us US Los Angeles qMac9k 3539 NaN US Bellevue zu2M5o 3540 en-US,en;q=0.8 US Payson wcndER 3541 NaN US Bellevue zu2M5o 3542 en-us US Pittsburg y3reI1 3543 NaN NaN NaN NaN 3544 en-us,en;q=0.5 US Wentzville vNJS4H 3545 en-us,en;q=0.5 US Saint Charles vNJS4H 3546 en-us US Los Angeles qMac9k 3547 en-us US Silver Spring y0jYkg 3548 en-us US Mcgehee y5rMac 3549 sv-SE,sv;q=0.8,en-US;q=0.6,en;q=0.4 SE Sollefte eH8wu 3550 en-us US Conshohocken A00b72 3551 en-US,en;q=0.8 None NaN wcndER 3552 NaN US Decatur rqgJuE 3553 en-us US Shrewsbury 9b6kNl 3554 en-us US Shrewsbury axNK8c 3555 en US Paramus e5SvKE 3556 en-US,en;q=0.8 US Oklahoma City jQLtP4 3557 NaN US Provo mwszkS 3558 NaN US Mountain View zjtI4X 3559 en-US US Mc Lean qxKrTK gr h hc hh kw l \ 0 MA wfLQtf 1.331823e+09 1.usa.gov NaN orofrog 1 UT mwszkS 1.308262e+09 j.mp NaN bitly 2 DC xxr3Qb 1.331920e+09 1.usa.gov NaN bitly 3 27 zUtuOu 1.331923e+09 1.usa.gov NaN alelex88 4 MA 9b6kNl 1.273672e+09 bit.ly NaN bitly 5 MA axNK8c 1.273673e+09 bit.ly NaN bitly 6 77 zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 7 NaN zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 8 NaN zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 9 NaN zUtuOu 1.331923e+09 1.usa.gov NaN alelex88 10 WA u0uD9q 1.319564e+09 1.usa.gov NaN o_4us71ccioa 11 DC A0nRz4 1.331816e+09 1.usa.gov NaN darrellissa 12 VA u0uD9q 1.319564e+09 1.usa.gov NaN o_4us71ccioa 13 NaN NaN NaN NaN NaN NaN 14 GA 2rOUYc 1.255770e+09 1.usa.gov NaN bitly 15 00 rtrrth 1.317318e+09 j.mp NaN walkeryuen 16 00 qWkgbq 1.317318e+09 j.mp NaN walkeryuen 17 ME x3jOIv 1.331840e+09 1.usa.gov NaN andyzieminski 18 UT mwszkS 1.308262e+09 1.usa.gov NaN bitly 19 20 zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 20 51 ytZYWR 1.331671e+09 bitly.com NaN jplnews 21 MD zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 22 DE y3ZImz 1.331064e+09 1.usa.gov NaN bitly 23 PA wWiOiD 1.330218e+09 1.usa.gov NaN bitly 24 59 zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 25 14 zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 26 04 zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 27 27 zUtuOu 1.331923e+09 1.usa.gov NaN alelex88 28 NaN u0uD9q 1.319564e+09 1.usa.gov NaN o_4us71ccioa 29 NaN FPX0IL 1.331923e+09 1.usa.gov NaN twittershare ... ... ... ... ... ... ... 3530 CA wqUkTo 1.331908e+09 go.nasa.gov NaN nasatwitter 3531 NaN zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 3532 DC A9ct6C 1.331926e+09 1.usa.gov NaN ncsha 3533 FL ieCdgH 1.301393e+09 go.nasa.gov NaN nasatwitter 3534 TX u0uD9q 1.319564e+09 1.usa.gov NaN o_4us71ccioa 3535 TX yrPaLt 1.331903e+09 aash.to NaN aashto 3536 NaN yG1TTf 1.331728e+09 go.nasa.gov NaN nasatwitter 3537 08 w63FZW 1.331547e+09 1.usa.gov NaN bufferapp 3538 CA qds1Ge 1.310474e+09 1.usa.gov NaN healthypeople 3539 WA zDhdro 1.331586e+09 bit.ly NaN glimtwin 3540 UT zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 3541 WA zDhdro 1.331586e+09 1.usa.gov NaN glimtwin 3542 CA y3reI1 1.331926e+09 1.usa.gov NaN bitly 3543 NaN NaN NaN NaN NaN NaN 3544 MO u0uD9q 1.319564e+09 1.usa.gov NaN o_4us71ccioa 3545 IL u0uD9q 1.319564e+09 1.usa.gov NaN o_4us71ccioa 3546 CA qds1Ge 1.310474e+09 1.usa.gov NaN healthypeople 3547 MD y0jYkg 1.331852e+09 1.usa.gov NaN bitly 3548 AR xANY6O 1.331916e+09 1.usa.gov NaN twitterfeed 3549 24 7dtjei 1.260316e+09 1.usa.gov NaN tweetdeckapi 3550 PA yGSwzn 1.331918e+09 1.usa.gov NaN addthis 3551 NaN zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 3552 AL xcz8vt 1.331227e+09 1.usa.gov NaN bootsnall 3553 MA 9b6kNl 1.273672e+09 bit.ly NaN bitly 3554 MA axNK8c 1.273673e+09 bit.ly NaN bitly 3555 NJ fqPSr9 1.301298e+09 1.usa.gov NaN tweetdeckapi 3556 OK jQLtP4 1.307530e+09 1.usa.gov NaN bitly 3557 UT mwszkS 1.308262e+09 j.mp NaN bitly 3558 CA zjtI4X 1.327529e+09 1.usa.gov NaN bitly 3559 VA qxKrTK 1.312898e+09 1.usa.gov NaN bitly ll nk \ 0 [42.576698, -70.954903] 1.0 1 [40.218102, -111.613297] 0.0 2 [38.9007, -77.043098] 1.0 3 [-23.549999, -46.616699] 0.0 4 [42.286499, -71.714699] 0.0 5 [42.286499, -71.714699] 0.0 6 [51.116699, 15.2833] 0.0 7 NaN 0.0 8 NaN 0.0 9 NaN 0.0 10 [47.5951, -122.332603] 1.0 11 [38.937599, -77.092796] 0.0 12 [38.790901, -77.094704] 1.0 13 NaN NaN 14 [33.953201, -84.5177] 1.0 15 [22.2833, 114.150002] 1.0 16 [22.2833, 114.150002] 1.0 17 [44.299702, -70.369797] 0.0 18 [40.218102, -111.613297] 0.0 19 [45.438599, 12.3267] 0.0 20 [37.516701, -5.9833] 0.0 21 [38.939201, -76.635002] 0.0 22 [39.785, -75.682297] 0.0 23 [40.174999, -76.3078] 0.0 24 [43.25, -2.9667] 0.0 25 [3.1667, 101.699997] 0.0 26 [35.166698, 33.366699] 0.0 27 [-23.5333, -46.616699] 0.0 28 NaN 0.0 29 NaN 1.0 ... ... ... 3530 [37.7645, -122.429398] 0.0 3531 NaN 0.0 3532 [38.904202, -77.031998] 1.0 3533 [30.279301, -81.585098] 1.0 3534 [33.149899, -96.855499] 1.0 3535 [29.775499, -95.415199] 1.0 3536 NaN 0.0 3537 [14.1, -87.216698] 0.0 3538 [34.041599, -118.298798] 0.0 3539 [47.615398, -122.210297] 0.0 3540 [40.014198, -111.738899] 0.0 3541 [47.615398, -122.210297] 0.0 3542 [38.0051, -121.838699] 0.0 3543 NaN NaN 3544 [38.790001, -90.854897] 1.0 3545 [41.9352, -88.290901] 1.0 3546 [34.041599, -118.298798] 1.0 3547 [39.052101, -77.014999] 1.0 3548 [33.628399, -91.356903] 1.0 3549 [63.166698, 17.266701] 1.0 3550 [40.0798, -75.2855] 0.0 3551 NaN 0.0 3552 [34.572701, -86.940598] 0.0 3553 [42.286499, -71.714699] 0.0 3554 [42.286499, -71.714699] 0.0 3555 [40.9445, -74.07] 1.0 3556 [35.4715, -97.518997] 0.0 3557 [40.218102, -111.613297] 0.0 3558 [37.419201, -122.057404] 0.0 3559 [38.935799, -77.162102] 0.0 r t \ 0 http://www.facebook.com/l/7AQEFzjSi/1.usa.gov/... 1.331923e+09 1 http://www.AwareMap.com/ 1.331923e+09 2 http://t.co/03elZC4Q 1.331923e+09 3 direct 1.331923e+09 4 http://www.shrewsbury-ma.gov/selco/ 1.331923e+09 5 http://www.shrewsbury-ma.gov/selco/ 1.331923e+09 6 http://plus.url.google.com/url?sa=z&amp;n=13319232... 1.331923e+09 7 http://www.facebook.com/ 1.331923e+09 8 http://www.facebook.com/l.php?u=http%3A%2F%2F1... 1.331923e+09 9 http://t.co/o1Pd0WeV 1.331923e+09 10 direct 1.331923e+09 11 http://t.co/ND7SoPyo 1.331923e+09 12 direct 1.331923e+09 13 NaN NaN 14 direct 1.331923e+09 15 http://forum2.hkgolden.com/view.aspx?type=BW&amp;m... 1.331923e+09 16 http://forum2.hkgolden.com/view.aspx?type=BW&amp;m... 1.331923e+09 17 http://t.co/6Cx4ROLs 1.331923e+09 18 http://www.AwareMap.com/ 1.331923e+09 19 http://www.facebook.com/ 1.331923e+09 20 http://www.facebook.com/ 1.331923e+09 21 http://www.facebook.com/ 1.331923e+09 22 direct 1.331923e+09 23 http://www.facebook.com/l.php?u=http%3A%2F%2F1... 1.331923e+09 24 http://www.facebook.com/ 1.331923e+09 25 http://www.facebook.com/ 1.331923e+09 26 http://www.facebook.com/?ref=tn_tnmn 1.331923e+09 27 direct 1.331923e+09 28 direct 1.331923e+09 29 http://t.co/5xlp0B34 1.331923e+09 ... ... ... 3530 http://www.facebook.com/l.php?u=http%3A%2F%2Fg... 1.331927e+09 3531 direct 1.331927e+09 3532 http://www.ncsha.org/ 1.331927e+09 3533 direct 1.331927e+09 3534 direct 1.331927e+09 3535 direct 1.331927e+09 3536 http://t.co/g1VKE8zS 1.331927e+09 3537 http://t.co/A8TJyibE 1.331927e+09 3538 direct 1.331927e+09 3539 direct 1.331927e+09 3540 http://www.facebook.com/l.php?u=http%3A%2F%2F1... 1.331927e+09 3541 direct 1.331927e+09 3542 http://www.facebook.com/l.php?u=http%3A%2F%2F1... 1.331927e+09 3543 NaN NaN 3544 direct 1.331927e+09 3545 direct 1.331927e+09 3546 direct 1.331927e+09 3547 direct 1.331927e+09 3548 https://twitter.com/fdarecalls/status/18069759... 1.331927e+09 3549 direct 1.331927e+09 3550 http://www.linkedin.com/home?trk=hb_tab_home_top 1.331927e+09 3551 http://plus.url.google.com/url?sa=z&amp;n=13319268... 1.331927e+09 3552 direct 1.331927e+09 3553 http://www.shrewsbury-ma.gov/selco/ 1.331927e+09 3554 http://www.shrewsbury-ma.gov/selco/ 1.331927e+09 3555 direct 1.331927e+09 3556 http://www.facebook.com/l.php?u=http%3A%2F%2F1... 1.331927e+09 3557 http://www.AwareMap.com/ 1.331927e+09 3558 direct 1.331927e+09 3559 http://t.co/OEEEvwjU 1.331927e+09 tz u 0 America/New_York http://www.ncbi.nlm.nih.gov/pubmed/22415991 1 America/Denver http://www.monroecounty.gov/etc/911/rss.php 2 America/New_York http://boxer.senate.gov/en/press/releases/0316... 3 America/Sao_Paulo http://apod.nasa.gov/apod/ap120312.html 4 America/New_York http://www.shrewsbury-ma.gov/egov/gallery/1341... 5 America/New_York http://www.shrewsbury-ma.gov/egov/gallery/1341... 6 Europe/Warsaw http://www.nasa.gov/mission_pages/nustar/main/... 7 http://www.nasa.gov/mission_pages/nustar/main/... 8 http://www.nasa.gov/mission_pages/nustar/main/... 9 http://apod.nasa.gov/apod/ap120312.html 10 America/Los_Angeles https://www.nysdot.gov/rexdesign/design/commun... 11 America/New_York http://oversight.house.gov/wp-content/uploads/... 12 America/New_York https://www.nysdot.gov/rexdesign/design/commun... 13 NaN NaN 14 America/New_York http://toxtown.nlm.nih.gov/index.php 15 Asia/Hong_Kong http://www.ssd.noaa.gov/PS/TROP/TCFP/data/curr... 16 Asia/Hong_Kong http://www.usno.navy.mil/NOOC/nmfc-ph/RSS/jtwc... 17 America/New_York http://www.usda.gov/wps/portal/usda/usdahome?c... 18 America/Denver http://www.monroecounty.gov/etc/911/rss.php 19 Europe/Rome http://www.nasa.gov/mission_pages/nustar/main/... 20 Africa/Ceuta http://voyager.jpl.nasa.gov/imagesvideo/uranus... 21 America/New_York http://www.nasa.gov/mission_pages/nustar/main/... 22 America/New_York http://portal.hud.gov/hudportal/documents/hudd... 23 America/New_York http://www.tricare.mil/mybenefit/ProfileFilter... 24 Europe/Madrid http://www.nasa.gov/mission_pages/nustar/main/... 25 Asia/Kuala_Lumpur http://www.nasa.gov/mission_pages/nustar/main/... 26 Asia/Nicosia http://www.nasa.gov/mission_pages/nustar/main/... 27 America/Sao_Paulo http://apod.nasa.gov/apod/ap120312.html 28 https://www.nysdot.gov/rexdesign/design/commun... 29 http://www.ed.gov/news/media-advisories/us-dep... ... ... ... 3530 America/Los_Angeles http://www.nasa.gov/multimedia/imagegallery/im... 3531 http://www.nasa.gov/mission_pages/nustar/main/... 3532 America/New_York http://portal.hud.gov/hudportal/HUD?src=/press... 3533 America/New_York http://apod.nasa.gov/apod/ 3534 America/Chicago https://www.nysdot.gov/rexdesign/design/commun... 3535 America/Chicago http://ntl.bts.gov/lib/44000/44300/44374/FHWA-... 3536 http://www.nasa.gov/mission_pages/hurricanes/a... 3537 America/Tegucigalpa http://apod.nasa.gov/apod/ap120312.html 3538 America/Los_Angeles http://healthypeople.gov/2020/connect/webinars... 3539 America/Los_Angeles http://www.federalreserve.gov/newsevents/press... 3540 America/Denver http://www.nasa.gov/mission_pages/nustar/main/... 3541 America/Los_Angeles http://www.federalreserve.gov/newsevents/press... 3542 America/Los_Angeles http://www.sba.gov/community/blogs/community-b... 3543 NaN NaN 3544 America/Chicago https://www.nysdot.gov/rexdesign/design/commun... 3545 America/Chicago https://www.nysdot.gov/rexdesign/design/commun... 3546 America/Los_Angeles http://healthypeople.gov/2020/connect/webinars... 3547 America/New_York http://www.epa.gov/otaq/regs/fuels/additive/e1... 3548 America/Chicago http://www.fda.gov/Safety/Recalls/ucm296326.htm 3549 Europe/Stockholm http://www.nasa.gov/mission_pages/WISE/main/in... 3550 America/New_York http://www.nlm.nih.gov/medlineplus/news/fullst... 3551 http://www.nasa.gov/mission_pages/nustar/main/... 3552 America/Chicago http://travel.state.gov/passport/passport_5535... 3553 America/New_York http://www.shrewsbury-ma.gov/egov/gallery/1341... 3554 America/New_York http://www.shrewsbury-ma.gov/egov/gallery/1341... 3555 America/New_York http://www.fda.gov/AdvisoryCommittees/Committe... 3556 America/Chicago http://www.okc.gov/PublicNotificationSystem/Fo... 3557 America/Denver http://www.monroecounty.gov/etc/911/rss.php 3558 America/Los_Angeles http://www.ahrq.gov/qual/qitoolkit/ 3559 America/New_York http://herndon-va.gov/Content/public_safety/Pu... [3560 rows x 18 columns]123# 打印frame这个表中的‘tz’列的前10行# 注意，这还是一个pandas对象，出了索引，还有Name：tz，dtype（数据类型）：objectprint(frame['tz'][:10]) 0 America/New_York 1 America/Denver 2 America/New_York 3 America/Sao_Paulo 4 America/New_York 5 America/New_York 6 Europe/Warsaw 7 8 9 Name: tz, dtype: object12345# 统计frame表格中‘tz’列的值的出现次数tz_counts = frame['tz'].value_counts()# 输出前10个看看# 空值出现了521次print(tz_counts[:10]) America/New_York 1251 521 America/Chicago 400 America/Los_Angeles 382 America/Denver 191 Europe/London 74 Asia/Tokyo 37 Pacific/Honolulu 36 Europe/Madrid 35 America/Sao_Paulo 33 Name: tz, dtype: int64123456789# 空值处理起来会比较麻烦（直接进行操作容易报错）# fillna（str）方法可以直接用str替代所有的空值clean_tz = frame['tz'].fillna('Missing')# 上边替代的不存在key的空值，但是还有另一种空值，key是存在的，但是value是空的（可以看作长度是0的字符串）# 这里把所有value是‘’的替代成'Unknown'clean_tz[clean_tz == ''] = 'Unknown'# 我们再重新统计一遍看看tz_counts = clean_tz.value_counts()print(tz_counts[:10]) America/New_York 1251 Unknown 521 America/Chicago 400 America/Los_Angeles 382 America/Denver 191 Missing 120 Europe/London 74 Asia/Tokyo 37 Pacific/Honolulu 36 Europe/Madrid 35 Name: tz, dtype: int6412# 定义画布尺寸为10*4 单位是英寸plt.figure(figsize=(10, 4)) &lt;matplotlib.figure.Figure at 0x10d7ae940&gt; &lt;matplotlib.figure.Figure at 0x10d7ae940&gt;123456789101112131415# 把tz_counts的统计结果绘制成图，类型为柱状图bar，横向h（horizontal）# kind : str# ‘line’ : line plot (default)# ‘bar’ : vertical bar plot# ‘barh’ : horizontal bar plot# ‘hist’ : histogram# ‘box’ : boxplot# ‘kde’ : Kernel Density Estimation plot# ‘density’ : same as ‘kde’# ‘area’ : area plot# ‘pie’ : pie plot# ‘scatter’ : scatter plot# ‘hexbin’ : hexbin plot# rot : int, default None. Rotation for ticks (xticks for vertical, yticks for horizontal plots)tz_counts[:10].plot(kind='barh', rot=0) &lt;matplotlib.axes._subplots.AxesSubplot at 0x10d784eb8&gt; 12# 看看frame这个表格里‘a’列的第二行（index是1）是什么print(frame['a'][1]) GoogleMaps/RochesterNY12# 在jupyter里边直接写变量名会自动print出来，是一种不标准的简化写法frame['a'][50] &apos;Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2&apos;12# 在jupyter里边直接写变量名会自动print出来，是一种不标准的简化写法frame['a'][51] &apos;Mozilla/5.0 (Linux; U; Android 2.2.2; en-us; LG-P925/V10e Build/FRG83G) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&apos;12345678# dropna()函数可以去掉包含有NaN值得item# frame.a.drapna()就是提取frame表格里列表为a的那一列，去除掉NA值得那些行的值# x.split(str) 通过指定分隔符str对字符串x进行切片，默认分隔符为空格，x.split(str)[0]意在取切完片的第一个值# [x.split()[0] for x in frame.a.dropna()]就是提取frame表格里列表为a的那一列，去除掉NA值得那些行的值，并用split进行分割，并且最后保存分割后的第一个值，构成一个list# Series是Pandas包中的方法，构建Series对象，添加索引results = Series([x.split()[0] for x in frame.a.dropna()])# 打印出来看看，后边的乱七八糟的信息已经没有了results[:5] 0 Mozilla/5.0 1 GoogleMaps/RochesterNY 2 Mozilla/4.0 3 Mozilla/5.0 4 Mozilla/5.0 dtype: object12# Pandas对象又可以直接通过value_counts方法做统计了，取出前8个看看results.value_counts()[:8] Mozilla/5.0 2594 Mozilla/4.0 601 GoogleMaps/RochesterNY 121 Opera/9.80 34 TEST_INTERNET_AGENT 24 GoogleProducer 21 Mozilla/6.0 5 BlackBerry8520/5.0.0.681 4 dtype: int6412345# frame.a.notnull()：frame表格的a列中，不是NaN就是true，是NaN就是False# frame[frame.a.notnull()]：取出frame这个表格中所有a列不为NaN的行cframe = frame[frame.a.notnull()]# 随便打几行看看，a列没有NaN（其他列暂时不管）cframe[:10] （表格太大了，略）1234# cframe['a'].str 意思是将cframe表格中的‘a’列取出来，转化为padas 中string方法组成的列表，可以调用string相关的方法# .contains('Windows') string中包含Windows返回True，不包含返回False# 顺便输出前10行看看cframe['a'].str.contains('Windows')[:10] 0 True 1 False 2 True 3 False 4 True 5 True 6 True 7 True 8 False 9 True Name: a, dtype: bool1234567891011# 要理解np.where()这个函数，先看下边几行# &gt;&gt;&gt; a# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])# &gt;&gt;&gt; np.where(a &lt; 5, 0, 1)# array([ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1])# 也就是说，对于array a，满足&lt;5的项，用0代替，不满足&lt;5的项用1代替# np.where(cframe['a'].str.contains('Windows'), 'Windows', 'Not Windows')，返回True的用Windows替代，返回False的用Not Windows替代operating_system = np.where(cframe['a'].str.contains('Windows'), 'Windows', 'Not Windows')# 打印前五行，因通过numpy方法得到的结果，所以是一个numpy arrayoperating_system[:5] array([&apos;Windows&apos;, &apos;Not Windows&apos;, &apos;Windows&apos;, &apos;Not Windows&apos;, &apos;Windows&apos;], dtype=&apos;&lt;U11&apos;)123456789101112# cframe.groupby([key1, key2, ...])为将cframe表格中的数据按照key进行分组# key可以是2种：1. cframe表格中的列名，2.长度和cframe表格相同的数组# cframe.groupby(['tz', operating_system])的意思就是：# 第一个分组维度为‘tz’列，改列值相同的为一组# 第二个分组维度为operating_system数组，也就是Windows的一组，Not Windows的一组# .size()为统计每个小组的数据量# .unstack()为把堆叠的分组表格展开（把这个函数去掉试一下就知道区别了）# .fillna(0)之前说了，把不存在值的格子填充上0agg_counts = cframe.groupby(['tz', operating_system]).size().unstack().fillna(0)# 打出前10行看看# 第一行不是总数，tz的值为空字符串‘’而已agg_counts[:10] .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; }Not WindowsWindowstz245.0276.0Africa/Cairo0.03.0Africa/Casablanca0.01.0Africa/Ceuta0.02.0Africa/Johannesburg0.01.0Africa/Lusaka0.01.0America/Anchorage4.01.0America/Argentina/Buenos_Aires1.00.0America/Argentina/Cordoba0.01.0America/Argentina/Mendoza0.01.0 1234# agg_counts.sum(1) 意思是按照第二维方向相加，也就是把Windows和Not Windows加到一起# 这里打印10行agg_counts_sum = agg_counts.sum(1)agg_counts_sum[:10] tz 521.0 Africa/Cairo 3.0 Africa/Casablanca 1.0 Africa/Ceuta 2.0 Africa/Johannesburg 1.0 Africa/Lusaka 1.0 America/Anchorage 5.0 America/Argentina/Buenos_Aires 1.0 America/Argentina/Cordoba 1.0 America/Argentina/Mendoza 1.0 dtype: float641234567# .argsort()：按照从小到大的顺序排列，返回排列后item在原数组中对应的indexindexer = agg_counts_sum.argsort()# 打出前10个，这个时候左边的tz和右边的数字已经没有对应关系了# 第一个24表示，按照从小到大排序，排在第一位的应该是原本数组中排在第25个（index为24）的那个item# 第二个20表示，按照从小到大排序，排在第二位的应该是原本数组中排在第21个（index为20）的那个item# 以此类推indexer[:10] tz 24 Africa/Cairo 20 Africa/Casablanca 21 Africa/Ceuta 92 Africa/Johannesburg 87 Africa/Lusaka 53 America/Anchorage 54 America/Argentina/Buenos_Aires 57 America/Argentina/Cordoba 26 America/Argentina/Mendoza 55 dtype: int6412# 让原本的数字按照这个排好的indexer输出，我们就可以得到排序后的数据了agg_counts_sum[indexer] tz America/Mazatlan 1.0 America/La_Paz 1.0 America/Lima 1.0 Europe/Volgograd 1.0 Europe/Sofia 1.0 Asia/Manila 1.0 Asia/Nicosia 1.0 Asia/Riyadh 1.0 America/Monterrey 1.0 Asia/Novosibirsk 1.0 Australia/Queensland 1.0 America/Santo_Domingo 1.0 Asia/Yekaterinburg 1.0 America/St_Kitts 1.0 America/Tegucigalpa 1.0 America/Montevideo 1.0 Europe/Ljubljana 1.0 Asia/Pontianak 1.0 Europe/Uzhgorod 1.0 Africa/Casablanca 1.0 Africa/Johannesburg 1.0 Africa/Lusaka 1.0 America/Argentina/Buenos_Aires 1.0 America/Argentina/Cordoba 1.0 America/Argentina/Mendoza 1.0 Europe/Skopje 1.0 America/Caracas 1.0 America/Costa_Rica 1.0 Asia/Kuching 1.0 Europe/Riga 2.0 ... America/Montreal 9.0 Asia/Calcutta 9.0 America/Puerto_Rico 10.0 Asia/Hong_Kong 10.0 Europe/Helsinki 10.0 Europe/Prague 10.0 Europe/Oslo 10.0 Europe/Moscow 10.0 Pacific/Auckland 11.0 America/Vancouver 12.0 Europe/Stockholm 14.0 Europe/Paris 14.0 America/Mexico_City 15.0 Europe/Warsaw 16.0 America/Phoenix 20.0 America/Indianapolis 20.0 Europe/Amsterdam 22.0 America/Rainy_River 25.0 Europe/Rome 27.0 Europe/Berlin 28.0 America/Sao_Paulo 33.0 Europe/Madrid 35.0 Pacific/Honolulu 36.0 Asia/Tokyo 37.0 Europe/London 74.0 America/Denver 191.0 America/Los_Angeles 382.0 America/Chicago 400.0 521.0 America/New_York 1251.0 Length: 97, dtype: float64123456# agg_counts.take([index1, index2, ...], axis=0)：在axis维度（0为行，1为列）上，按照index顺序取出数据# 这里没有输入axis的值，默认为0，按行取# 顺序为按照indexer# [-10:]：把最后10个取出来count_subset = agg_counts.take(indexer)[-10:]count_subset .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; }Not WindowsWindowstzAmerica/Sao_Paulo13.020.0Europe/Madrid16.019.0Pacific/Honolulu0.036.0Asia/Tokyo2.035.0Europe/London43.031.0America/Denver132.059.0America/Los_Angeles130.0252.0America/Chicago115.0285.0245.0276.0America/New_York339.0912.0 12# 设置一块自定义大小的画布，生成画布对象（这里没写残书就是默认）plt.figure() &lt;matplotlib.figure.Figure at 0x112f87e10&gt; &lt;matplotlib.figure.Figure at 0x112f87e10&gt;123# 把count_subset这个表格中的数据绘制成图，类型为柱状图bar，横向h（horizontal）# stacked=True表示多个维度的数据堆叠显示（不明白的话改成False看看就知道了）count_subset.plot(kind='barh', stacked=True) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1134d2630&gt; 12# 设置一块自定义大小的画布，生成画布对象（这里没写残书就是默认）plt.figure() &lt;matplotlib.figure.Figure at 0x1136fd2e8&gt; &lt;matplotlib.figure.Figure at 0x1136fd2e8&gt;123456# count_subset.sum(1)：把count_subset按照第一维的方向相加# count_subset.div(count_subset.sum(1),axis=0)：按行除以相加的结果# 相当于把每一行所有数值变成了在当前行占的百分比normed_subset = count_subset.div(count_subset.sum(1), axis=0)# stacked=True表示多个维度的数据堆叠显示（不明白的话改成False看看就知道了）normed_subset.plot(kind='barh', stacked=True) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1138b6fd0&gt;]]></content>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过python进行数据分析(一)]]></title>
    <url>%2F2019%2F04%2F14%2F%E9%80%9A%E8%BF%87python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Introductory examples1.usa.gov data from bit.ly12# 显示当前路径%pwd &apos;/Users/imonce/OneDrive/learning/dataAnalyze/pydata-book-master&apos;12# 回到上一层（..）又回到当前文件夹（pydata-book-master）%cd ../pydata-book-master /Users/imonce/OneDrive/learning/dataAnalyze/pydata-book-master12# 创建变量并赋值，这里path是数据所在路径path = 'ch02/usagov_bitly_data2012-03-16-1331923249.txt' 123# open：打开path路径代表的文件# open().readline()：读取文件的第一行，并把指针下移一行（再执行一次读取的就是文件的第二行了，以此类推）open(path).readline() &apos;{ &quot;a&quot;: &quot;Mozilla\\/5.0 (Windows NT 6.1; WOW64) AppleWebKit\\/535.11 (KHTML, like Gecko) Chrome\\/17.0.963.78 Safari\\/535.11&quot;, &quot;c&quot;: &quot;US&quot;, &quot;nk&quot;: 1, &quot;tz&quot;: &quot;America\\/New_York&quot;, &quot;gr&quot;: &quot;MA&quot;, &quot;g&quot;: &quot;A6qOVH&quot;, &quot;h&quot;: &quot;wfLQtf&quot;, &quot;l&quot;: &quot;orofrog&quot;, &quot;al&quot;: &quot;en-US,en;q=0.8&quot;, &quot;hh&quot;: &quot;1.usa.gov&quot;, &quot;r&quot;: &quot;http:\\/\\/www.facebook.com\\/l\\/7AQEFzjSi\\/1.usa.gov\\/wfLQtf&quot;, &quot;u&quot;: &quot;http:\\/\\/www.ncbi.nlm.nih.gov\\/pubmed\\/22415991&quot;, &quot;t&quot;: 1331923247, &quot;hc&quot;: 1331822918, &quot;cy&quot;: &quot;Danvers&quot;, &quot;ll&quot;: [ 42.576698, -70.954903 ] }\n&apos;12345678# 导入json包import json# 创建变量并赋值，这里path是数据所在路径path = 'ch02/usagov_bitly_data2012-03-16-1331923249.txt'# json.loads()：以json格式读取数据，读取出来是key：value对，可以像字典一样查询# for line in open(path)：逐行遍历path文件中的数据# [json.loads(line) for line in open(path)]：逐行遍历path文件中的数据，通过按照json格式读取，然后每一行的作为一个item组成list（就是外边那个方括号的作用）records = [json.loads(line) for line in open(path)] 1234# 取出第一个item（第一行读取的内容）看一下# 这个语句本身没有打印作用，但是在jupyter里边直接放变量会给你打印出来# 标准写法应该为print(records[0])records[0] {&apos;a&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.78 Safari/535.11&apos;, &apos;al&apos;: &apos;en-US,en;q=0.8&apos;, &apos;c&apos;: &apos;US&apos;, &apos;cy&apos;: &apos;Danvers&apos;, &apos;g&apos;: &apos;A6qOVH&apos;, &apos;gr&apos;: &apos;MA&apos;, &apos;h&apos;: &apos;wfLQtf&apos;, &apos;hc&apos;: 1331822918, &apos;hh&apos;: &apos;1.usa.gov&apos;, &apos;l&apos;: &apos;orofrog&apos;, &apos;ll&apos;: [42.576698, -70.954903], &apos;nk&apos;: 1, &apos;r&apos;: &apos;http://www.facebook.com/l/7AQEFzjSi/1.usa.gov/wfLQtf&apos;, &apos;t&apos;: 1331923247, &apos;tz&apos;: &apos;America/New_York&apos;, &apos;u&apos;: &apos;http://www.ncbi.nlm.nih.gov/pubmed/22415991&apos;}12# 查询第一个item中，key为'a'的valuerecords[0]['a'] &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.78 Safari/535.11&apos;Counting time zones in pure Python12# 如果查询不存在的key的话会报错records[0]['cc'] --------------------------------------------------------------------------- KeyError Traceback (most recent call last) &lt;ipython-input-8-992e1ec28c8d&gt; in &lt;module&gt;() 1 # 如果查询不存在的key的话会报错 ----&gt; 2 records[0][&apos;cc&apos;] KeyError: &apos;cc&apos;1234# for rec in records：吧records这个list里边的item逐个取出，每次取出都用rec命名# [rec['tz'] for rec in records]：把rec中key为‘tz’的value取出来，作为item构建list# 直接运行会报错，因为有的行里边是没有‘tz’这个key的time_zones = [rec['tz'] for rec in records] --------------------------------------------------------------------------- KeyError Traceback (most recent call last) &lt;ipython-input-9-abb6a4fa53e3&gt; in &lt;module&gt;() 2 # [rec[&apos;tz&apos;] for rec in records]：把rec中key为‘tz’的value取出来，作为item构建list 3 # 直接运行会报错，因为有的行里边是没有‘tz’这个key的 ----&gt; 4 time_zones = [rec[&apos;tz&apos;] for rec in records] &lt;ipython-input-9-abb6a4fa53e3&gt; in &lt;listcomp&gt;(.0) 2 # [rec[&apos;tz&apos;] for rec in records]：把rec中key为‘tz’的value取出来，作为item构建list 3 # 直接运行会报错，因为有的行里边是没有‘tz’这个key的 ----&gt; 4 time_zones = [rec[&apos;tz&apos;] for rec in records] KeyError: &apos;tz&apos;123# 因此这一句在上一句的基础上，增加if 'tz' in rec，意为只把tz的rec中的value构成list# 因此time_zones的长度小于recordstime_zones = [rec['tz'] for rec in records if 'tz' in rec] 123# 输出两个list的长度看一下# records中有120个item是没有‘tz’这个key的print(len(records),len(time_zones)) 3560 34401234567891011121314151617# 这个函数的参数sequence应该是一个list# 这个函数的输出是一个dict，其中key是sequence中的item，value是item出现的次数def get_counts(sequence): # 创建空字典counts counts = &#123;&#125; # 遍历sequence中的item，命名为x for x in sequence: # 如果x在counts中作为key出现过 if x in counts: # 将当前x对应的value的值+1 counts[x] += 1 # counts的key中没有x else: # 创建x这个key，并将其对应的value设置为1 counts[x] = 1 # 返回counts这个字典 return counts 12345678910111213141516# 从collections这个包里导入defaultdict这个函数from collections import defaultdict# 这个函数的参数sequence应该是一个list# 这个函数的输出是一个dict，其中key是sequence中的item，value是item出现的次数def get_counts2(sequence): # 创建空字典，字典中的value默认为int类型的变量 # 意义在于，每次插入一个新的key时，对应的value会自动设置为0，不需要先赋值一次 counts = defaultdict(int) # values will initialize to 0 # 遍历sequence中的item，命名为x for x in sequence: # counts的key中有x就直接+1 # 没有就插入x这个key，（自动初始化value为0），然后+1 counts[x] += 1 # 返回counts这个字典 return counts 12# 调用刚刚定义的函数，统计一下time_zones这个list中每个时区出现的次数counts = get_counts(time_zones) 123# counts是一个dict，因此可以直接通过key查询value的值# 看看'America/New_York'这个key对应的value时多少counts['America/New_York'] 1251123# counts.items()：把counts这个字典中的key和value成对取出# [(count, tz) for tz, count in counts.items()]：把键值对以二元组的形式构成list[(count, tz) for tz, count in counts.items()] [(1251, &apos;America/New_York&apos;), (191, &apos;America/Denver&apos;), (33, &apos;America/Sao_Paulo&apos;), (16, &apos;Europe/Warsaw&apos;), (521, &apos;&apos;), (382, &apos;America/Los_Angeles&apos;), (10, &apos;Asia/Hong_Kong&apos;), (27, &apos;Europe/Rome&apos;), (2, &apos;Africa/Ceuta&apos;), (35, &apos;Europe/Madrid&apos;), (3, &apos;Asia/Kuala_Lumpur&apos;), (1, &apos;Asia/Nicosia&apos;), (74, &apos;Europe/London&apos;), (36, &apos;Pacific/Honolulu&apos;), (400, &apos;America/Chicago&apos;), (2, &apos;Europe/Malta&apos;), (8, &apos;Europe/Lisbon&apos;), (14, &apos;Europe/Paris&apos;), (5, &apos;Europe/Copenhagen&apos;), (1, &apos;America/Mazatlan&apos;), (3, &apos;Europe/Dublin&apos;), (4, &apos;Europe/Brussels&apos;), (12, &apos;America/Vancouver&apos;), (22, &apos;Europe/Amsterdam&apos;), (10, &apos;Europe/Prague&apos;), (14, &apos;Europe/Stockholm&apos;), (5, &apos;America/Anchorage&apos;), (6, &apos;Asia/Bangkok&apos;), (28, &apos;Europe/Berlin&apos;), (25, &apos;America/Rainy_River&apos;), (5, &apos;Europe/Budapest&apos;), (37, &apos;Asia/Tokyo&apos;), (6, &apos;Europe/Vienna&apos;), (20, &apos;America/Phoenix&apos;), (3, &apos;Asia/Jerusalem&apos;), (3, &apos;Asia/Karachi&apos;), (3, &apos;America/Bogota&apos;), (20, &apos;America/Indianapolis&apos;), (9, &apos;America/Montreal&apos;), (9, &apos;Asia/Calcutta&apos;), (1, &apos;Europe/Skopje&apos;), (4, &apos;Asia/Beirut&apos;), (6, &apos;Australia/NSW&apos;), (6, &apos;Chile/Continental&apos;), (4, &apos;America/Halifax&apos;), (6, &apos;America/Edmonton&apos;), (3, &apos;Europe/Bratislava&apos;), (2, &apos;America/Recife&apos;), (3, &apos;Africa/Cairo&apos;), (9, &apos;Asia/Istanbul&apos;), (1, &apos;Asia/Novosibirsk&apos;), (10, &apos;Europe/Moscow&apos;), (1, &apos;Europe/Sofia&apos;), (1, &apos;Europe/Ljubljana&apos;), (15, &apos;America/Mexico_City&apos;), (10, &apos;Europe/Helsinki&apos;), (4, &apos;Europe/Bucharest&apos;), (4, &apos;Europe/Zurich&apos;), (10, &apos;America/Puerto_Rico&apos;), (1, &apos;America/Monterrey&apos;), (6, &apos;Europe/Athens&apos;), (4, &apos;America/Winnipeg&apos;), (2, &apos;Europe/Riga&apos;), (1, &apos;America/Argentina/Buenos_Aires&apos;), (4, &apos;Asia/Dubai&apos;), (10, &apos;Europe/Oslo&apos;), (1, &apos;Asia/Yekaterinburg&apos;), (1, &apos;Asia/Manila&apos;), (1, &apos;America/Caracas&apos;), (1, &apos;Asia/Riyadh&apos;), (1, &apos;America/Montevideo&apos;), (1, &apos;America/Argentina/Mendoza&apos;), (5, &apos;Asia/Seoul&apos;), (1, &apos;Europe/Uzhgorod&apos;), (1, &apos;Australia/Queensland&apos;), (2, &apos;Europe/Belgrade&apos;), (1, &apos;America/Costa_Rica&apos;), (1, &apos;America/Lima&apos;), (1, &apos;Asia/Pontianak&apos;), (2, &apos;America/Chihuahua&apos;), (2, &apos;Europe/Vilnius&apos;), (3, &apos;America/Managua&apos;), (1, &apos;Africa/Lusaka&apos;), (2, &apos;America/Guayaquil&apos;), (3, &apos;Asia/Harbin&apos;), (2, &apos;Asia/Amman&apos;), (1, &apos;Africa/Johannesburg&apos;), (1, &apos;America/St_Kitts&apos;), (11, &apos;Pacific/Auckland&apos;), (1, &apos;America/Santo_Domingo&apos;), (1, &apos;America/Argentina/Cordoba&apos;), (1, &apos;Asia/Kuching&apos;), (1, &apos;Europe/Volgograd&apos;), (1, &apos;America/La_Paz&apos;), (1, &apos;Africa/Casablanca&apos;), (3, &apos;Asia/Jakarta&apos;), (1, &apos;America/Tegucigalpa&apos;)]123456789# count_dict是待统计的字典，n是要取出n项，默认为10def top_counts(count_dict, n=10): # counts.items()：把counts这个字典中的key和value成对取出 # [(count, tz) for tz, count in counts.items()]：把键值对以二元组的形式构成list value_key_pairs = [(count, tz) for tz, count in count_dict.items()] # 调用python中的list自带的sort()方法，默认按照第一维从小到达排序 value_key_pairs.sort() # [-n:]意思为从倒数第n项一直取到最后一项，也就是说返回的是最大的n个 return value_key_pairs[-n:] 12# 看看counts中出现最多的时区top_counts(counts) [(33, &apos;America/Sao_Paulo&apos;), (35, &apos;Europe/Madrid&apos;), (36, &apos;Pacific/Honolulu&apos;), (37, &apos;Asia/Tokyo&apos;), (74, &apos;Europe/London&apos;), (191, &apos;America/Denver&apos;), (382, &apos;America/Los_Angeles&apos;), (400, &apos;America/Chicago&apos;), (521, &apos;&apos;), (1251, &apos;America/New_York&apos;)]123# 其实有现成的包可以用# 导入collections包中的Counter函数from collections import Counter 12# 通过Counter对time_zones这个list进行统计counts = Counter(time_zones) 12# 调用Counter对象的方法most_common(n)可以直接调出最多的n项counts.most_common(10) [(&apos;America/New_York&apos;, 1251), (&apos;&apos;, 521), (&apos;America/Chicago&apos;, 400), (&apos;America/Los_Angeles&apos;, 382), (&apos;America/Denver&apos;, 191), (&apos;Europe/London&apos;, 74), (&apos;Asia/Tokyo&apos;, 37), (&apos;Pacific/Honolulu&apos;, 36), (&apos;Europe/Madrid&apos;, 35), (&apos;America/Sao_Paulo&apos;, 33)]]]></content>
      <tags>
        <tag>python</tag>
        <tag>学习笔记</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[latex数学符号表]]></title>
    <url>%2F2019%2F04%2F02%2Flatex%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[reference:一份不太简短的 LATEX 2ε 介绍]]></content>
      <tags>
        <tag>latex</tag>
        <tag>数学符号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MECE分析法学习(Mutually Exclusive Collectively Exhaustive)]]></title>
    <url>%2F2019%2F04%2F02%2FMECE%E5%88%86%E6%9E%90%E6%B3%95%E5%AD%A6%E4%B9%A0-Mutually-Exclusive-Collectively-Exhaustive%2F</url>
    <content type="text"><![CDATA[本文摘自：MECE分析法 MECE分析法MECE，是Mutually Exclusive Collectively Exhaustive，中文意思是“相互独立，完全穷尽”。 也就是对于一个重大的议题，能够做到不重叠、不遗漏的分类，而且能够藉此有效把握问题的核心，并解决问题的方法。 所谓的不遗漏、不重叠指在将某个整体（不论是客观存在的还是概念性的整体）划分为不同的部分时，必须保证划分后的各部门符合以下要求： 各部分之间相互独立 （Mutually Exclusive） 所有部分完全穷尽 （Collectively Exhaustive） 通常的做法分两种： 一是在确立问题的时候，通过类似鱼刺图的方法，在确立主要问题的基础上，再逐个往下层层分解，直至所有的疑问都找到，通过问题的层层分解，可以分析出关键问题和初步的解决问题的思路； 另一种方法是结合头脑风暴法找到主要问题，然后在不考虑现有资源的限制基础上，考虑解决该问题的所有可能方法，在这个过程中，要特别注意多种方法的结合有可能是个新的解决方法，然后再往下分析，每种解决方法所需要的各种资源，并通过分析比较，从上述多种方案中找到目前状况下最现实最令人满意的答案。 分析步骤对于分析问题的标准程序: 收集信息=&gt;描述发现=&gt;得出结论=&gt;提出方案 MECE分析法主要有两个步骤 步骤一、确认问题是什么？步骤二、寻找MECE的切入点。 栗子]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>MECE</tag>
        <tag>分类方法</tag>
        <tag>分析法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WS-BPEL 2.0 xml schema 详解(1+2+3全，方便检索)]]></title>
    <url>%2F2019%2F03%2F22%2FWS-BPEL-2-0-xml-schema-%E8%AF%A6%E8%A7%A3-%E5%85%A8%2F</url>
    <content type="text"><![CDATA[这篇文章将一行一行的解读wsbpel2.0的源码。 相关xsd语法问题，请参见XSD学习笔记完整版 wsbpel2.0源码：ws-bpel_executable.xsd schema声明1234&lt;xsd:schema xmlns=&quot;http://docs.oasis-open.org/wsbpel/2.0/process/executable&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://docs.oasis-open.org/wsbpel/2.0/process/executable&quot; elementFormDefault=&quot;qualified&quot; blockDefault=&quot;#all&quot;&gt; ...&lt;\xsd&gt; 声明命名空间http://docs.oasis-open.org/wsbpel/2.0/process/executable，没有前缀。 引入http://www.w3.org/2001/XMLSchema的语素并以xsd为前缀。 elementFormDefault=&quot;qualified&quot;表示所有元素都必须加上前缀以表明其命名空间。 blockDefault=&quot;#all&quot;表示默认情况下不能通过派生类代替原类型。 annotation12345&lt;xsd:annotation&gt; &lt;xsd:documentation&gt;Schema for Executable Process for WS-BPEL 2.0 OASIS Standard 11th April, 2007 &lt;/xsd:documentation&gt;&lt;/xsd:annotation&gt; 赠送了一个简单的文档说明。 import1&lt;xsd:import namespace=&quot;http://www.w3.org/XML/1998/namespace&quot; schemaLocation=&quot;http://www.w3.org/2001/xml.xsd&quot;/&gt; 引入http://www.w3.org/2001/xml.xsd的xml语素，前缀默认为xml。 element：process1234567&lt;xsd:element name=&quot;process&quot; type=&quot;tProcess&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This is the root element for a WS-BPEL 2.0 process. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt; BPEL的根元素，此处没有定义任何内容，内部元素属性通过type=”tProcess”引入。 complexType：tProcess1234567891011121314151617181920212223&lt;xsd:complexType name=&quot;tProcess&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;extensions&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;import&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;partnerLinks&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;messageExchanges&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;variables&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;correlationSets&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;faultHandlers&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;eventHandlers&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;targetNamespace&quot; type=&quot;xsd:anyURI&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;queryLanguage&quot; type=&quot;xsd:anyURI&quot; default=&quot;urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0&quot;/&gt; &lt;xsd:attribute name=&quot;expressionLanguage&quot; type=&quot;xsd:anyURI&quot; default=&quot;urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0&quot;/&gt; &lt;xsd:attribute name=&quot;suppressJoinFailure&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;xsd:attribute name=&quot;exitOnStandardFault&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 首先是一个名为tExtensibleElements的扩展，先放一下往后看。 一个sequence，包括extensions，import，partnerLinks，messageExchanges，variables，correlationSets，faultHandlers，eventHandlers，还有一个activity的group，这里全部是ref，我们知道大概有些啥就行了，后边肯定会有详细的定义，先往后看吧。 接着是一堆attribute，包括process的 名称name 目标命名空间targetNamespace 查询语言queryLanguage，默认是urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0 表达语言expressionLanguage，默认是：urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0 抑制链接失败suppressJoinFailure，默认是否 标准错误退出exitOnStandardFault，默认是否 complexType：tExtensibleElement123456789101112&lt;xsd:complexType name=&quot;tExtensibleElements&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This type is extended by other component types to allow elements and attributes from other namespaces to be added at the modeled places. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;documentation&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; tExtensibleElements这个扩展马上就来了，可以看到，扩展除了0至多个documentation（后边再讲），还有 element：来自该元素的父元素的目标命名空间之外的任何命名空间的元素，且即使不能获取该命名空间架构，也不会发生任何错误。 attribute：同上 element：documentation123456789&lt;xsd:element name=&quot;documentation&quot; type=&quot;tDocumentation&quot;/&gt;&lt;xsd:complexType name=&quot;tDocumentation&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;source&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:attribute ref=&quot;xml:lang&quot;/&gt;&lt;/xsd:complexType&gt; documentation中： element：一个字符元素可混合出现的，元素可随意引入，不在此命名空间也没关系 attribute： source：通过URI表明来源 xml:lang: 文档语言，如en、CN等 group：activity123456789101112131415161718192021222324252627282930&lt;xsd:group name=&quot;activity&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;All standard WS-BPEL 2.0 activities in alphabetical order. Basic activities and structured activities. Addtional constraints: - rethrow activity can be used ONLY within a fault handler (i.e. &quot;catch&quot; and &quot;catchAll&quot; element) - compensate or compensateScope activity can be used ONLY within a fault handler, a compensation handler or a termination handler &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:choice&gt; &lt;xsd:element ref=&quot;assign&quot;/&gt; &lt;xsd:element ref=&quot;compensate&quot;/&gt; &lt;xsd:element ref=&quot;compensateScope&quot;/&gt; &lt;xsd:element ref=&quot;empty&quot;/&gt; &lt;xsd:element ref=&quot;exit&quot;/&gt; &lt;xsd:element ref=&quot;extensionActivity&quot;/&gt; &lt;xsd:element ref=&quot;flow&quot;/&gt; &lt;xsd:element ref=&quot;forEach&quot;/&gt; &lt;xsd:element ref=&quot;if&quot;/&gt; &lt;xsd:element ref=&quot;invoke&quot;/&gt; &lt;xsd:element ref=&quot;pick&quot;/&gt; &lt;xsd:element ref=&quot;receive&quot;/&gt; &lt;xsd:element ref=&quot;repeatUntil&quot;/&gt; &lt;xsd:element ref=&quot;reply&quot;/&gt; &lt;xsd:element ref=&quot;rethrow&quot;/&gt; &lt;xsd:element ref=&quot;scope&quot;/&gt; &lt;xsd:element ref=&quot;sequence&quot;/&gt; &lt;xsd:element ref=&quot;throw&quot;/&gt; &lt;xsd:element ref=&quot;validate&quot;/&gt; &lt;xsd:element ref=&quot;wait&quot;/&gt; &lt;xsd:element ref=&quot;while&quot;/&gt; &lt;/xsd:choice&gt;&lt;/xsd:group&gt; 定义了一个activity的group，用于在其他地方引用，比如说通过tProcess引用到process里边。 一个activity可以是以下元素中的一个，没写到的看后边源码解读好了： 活动名称 释义 assign 活动的作用是用新的数据来更新变量的值。Assign活动可以包括任意数量的基本复制操作。 compensate 通过该活动做一些补偿动作，通常需要和scope联合使用。只能从故障处理程序或另一个补偿处理活动中调用这个活动。补偿处理程序只能被调用一次。 compensateScope empty 无所事事，比如在一个错误发生后可以不做反应来消除这个错误 exit 该活动用于立刻终止业务流程实例。所有当前运行的活动必须被立刻终止。不用引用任何终点处理、错误处理或者补偿行为。 extensionActivity flow 可以描述更为复杂的活动执行顺序。我们可以利用flow指定一个或多个并行执行的活动。为了定义任意的控制结构，可以在并行的活动中使用链接。 forEach if invoke 活动允许业务流程同步或异步调用由合作伙伴提供的服务，服务实现可以是单向或请求-响应操作。Invoke活动使用“partnerLink”来引用伙伴服务。同过“portType”和“operation”指定相应的WSDL接口和操作。 pick 活动会等待一组相互排斥事件中的一个事件的发生，然后执行与发生的事件相关联的活动。它会阻塞业务流程执行，以等待某一特定的事件发生，比如接收到一个合适的消息或超时警报响起。当其中任何一个事件被触发后，业务流程就会继续执行，pick也随即完成了，不会再等待其他事件的发生。 receive 活动从流程的外部伙伴那获取数据，并将其保存到流程变量。通常一个Receive是一个流程的初始点，它会阻塞执行直到匹配的消息的到达。 repeatUntil reply 活动发送消息给伙伴来应答通过receive活动所接收到的消息。receive和reply的组合对应着WSDL portType上定义的一个请求-响应操作。如果receive活动对应着一个单向(one-way)操作，则不能在流程中定义对应的reply活动。 rethrow scope 使用这个结构可以将一组活动组织在一起作为一个处理单位。通过这个组织方法多个活动可以使用同一个故障处理、事故处理和补偿处理。通过补偿处理BPEL可以处理长时间的处理。 sequence 定义一组按顺序先后执行的活动。执行顺序是sequence活动中嵌套活动的先后顺序。当sequence中的最后一个活动完成后，该sequence活动也就完成了。 throw 提示一个错误，一个故障处理可以处理这样的错误。假如一个错误不被处理的话它最终到达最高层后导致过程的终止 validate wait 活动会暂停流程执行，等待一段给定的时间或等到某一时刻才继续运行。在WebSphere Process Server 6.0中，开发者可以非常灵活地指定wait中的到期条件，比如等待多少秒，等到特定的一个日期，或是使用内置的日期表现法。也可以使用Java代码来动态指定等待时间。 while 继承于传统的结构化编程思想，提供了while-do循环结构的支持。它可以包含一个或多个活动。它指定反复执行其内部活动，直到成功条件不被满足为止。在WPS中允许其使用Java代码来描述条件表达式。 element：extensions12345678910111213141516171819202122&lt;xsd:element name=&quot;extensions&quot; type=&quot;tExtensions&quot;/&gt;&lt;xsd:complexType name=&quot;tExtensions&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;extension&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;extension&quot; type=&quot;tExtension&quot;/&gt;&lt;xsd:complexType name=&quot;tExtension&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;namespace&quot; type=&quot;xsd:anyURI&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;mustUnderstand&quot; type=&quot;tBoolean&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 一个extensions由1到多个extension组成。 extension扩展自tExtensibleElements，增加了namespace和mustUnderstand两个属性。 element：import1234567891011&lt;xsd:element name=&quot;import&quot; type=&quot;tImport&quot;/&gt;&lt;xsd:complexType name=&quot;tImport&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;namespace&quot; type=&quot;xsd:anyURI&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;location&quot; type=&quot;xsd:anyURI&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;importType&quot; type=&quot;xsd:anyURI&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; BPEL允许import，import元素在tExtensibleElements的基础上，增加namespace、location、importType三个属性，和xsd的import类似。 element：partnerLinks12345678910111213141516171819202122232425&lt;xsd:element name=&quot;partnerLinks&quot; type=&quot;tPartnerLinks&quot;/&gt;&lt;xsd:complexType name=&quot;tPartnerLinks&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;partnerLink&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;partnerLink&quot; type=&quot;tPartnerLink&quot;/&gt;&lt;xsd:complexType name=&quot;tPartnerLink&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;partnerLinkType&quot; type=&quot;xsd:QName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;myRole&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;partnerRole&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;initializePartnerRole&quot; type=&quot;tBoolean&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 和extensions相似，partnerLinks由1到多个partnerLink组成，同时支持tExtensibleElements扩展。 partnerLink在tExtensibleElements的基础上，增加了以下5个属性 name partnerLinkType myRole partnerRole initializaPartnerRole element：messageExchanges123456789101112131415161718192021&lt;xsd:element name=&quot;messageExchanges&quot; type=&quot;tMessageExchanges&quot;/&gt;&lt;xsd:complexType name=&quot;tMessageExchanges&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;messageExchange&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;messageExchange&quot; type=&quot;tMessageExchange&quot;/&gt;&lt;xsd:complexType name=&quot;tMessageExchange&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 和extensions相似，messageExchanges由1到多个messageExchange组成，同时支持tExtensibleElements扩展。 messageExchange在tExtensibleElements的基础上，增加了一个属性 name element：variables123456789101112131415161718192021222324252627&lt;xsd:element name=&quot;variables&quot; type=&quot;tVariables&quot;/&gt;&lt;xsd:complexType name=&quot;tVariables&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;variable&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;variable&quot; type=&quot;tVariable&quot;/&gt;&lt;xsd:complexType name=&quot;tVariable&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;from&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;BPELVariableName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;messageType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;element&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 和extensions相似，variables由1到多个variable组成，同时支持tExtensibleElements扩展。 variable在tExtensibleElements的基础上，增加了一个元素 from 增加了四个属性 name messageType type element simpleType：BPELVariableName12345&lt;xsd:simpleType name=&quot;BPELVariableName&quot;&gt; &lt;xsd:restriction base=&quot;xsd:NCName&quot;&gt; &lt;xsd:pattern value=&quot;[^\.]+&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; bpel变量的一个限制，BPELVariableName需要满足xsd:NCName限制，不能以.开头，且长度大于等于一个字符。 element：correlationSets12345678910111213141516171819202122&lt;xsd:element name=&quot;correlationSets&quot; type=&quot;tCorrelationSets&quot;/&gt;&lt;xsd:complexType name=&quot;tCorrelationSets&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;correlationSet&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;correlationSet&quot; type=&quot;tCorrelationSet&quot;/&gt;&lt;xsd:complexType name=&quot;tCorrelationSet&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;properties&quot; type=&quot;QNames&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 和extensions相似，correlationSets由1到多个correlationSet组成，同时支持tExtensibleElements扩展。 correlationSet在tExtensibleElements的基础上，增加了2个属性 properties name simpleType：QNames12345678&lt;xsd:simpleType name=&quot;QNames&quot;&gt; &lt;xsd:restriction&gt; &lt;xsd:simpleType&gt; &lt;xsd:list itemType=&quot;xsd:QName&quot;/&gt; &lt;/xsd:simpleType&gt; &lt;xsd:minLength value=&quot;1&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; QNames就是一个QName的list，最少1个，默认空格分割。 element：faultHandlers123456789101112&lt;xsd:element name=&quot;faultHandlers&quot; type=&quot;tFaultHandlers&quot;/&gt;&lt;xsd:complexType name=&quot;tFaultHandlers&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;catch&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;catchAll&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; faultHandlers，听名字就知道是干啥的了，同样支持tExtensibleElements扩展，由2种元素的sequence组成： catch catchAll element：catch123456789101112131415161718&lt;xsd:element name=&quot;catch&quot; type=&quot;tCatch&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This element can contain all activities including the activities compensate, compensateScope and rethrow. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt;&lt;xsd:complexType name=&quot;tCatch&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivityContainer&quot;&gt; &lt;xsd:attribute name=&quot;faultName&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;faultVariable&quot; type=&quot;BPELVariableName&quot;/&gt; &lt;xsd:attribute name=&quot;faultMessageType&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;faultElement&quot; type=&quot;xsd:QName&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; catch扩展自tActivityContainer，包含4个属性，对catch做了限定： faultName faultVariable faultMessageType faultElement element：catchAll1234567891011121314151617&lt;xsd:element name=&quot;catchAll&quot; type=&quot;tActivityContainer&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This element can contain all activities including the activities compensate, compensateScope and rethrow. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt;&lt;xsd:complexType name=&quot;tActivityContainer&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 不同于catch，catchAll没有那么多属性（我全都要），就是tActivityContainer本尊，扩展自tExtensibleElements，同时包含一个activity的sequence。 element：eventHandlers1234567891011121314151617&lt;xsd:element name=&quot;eventHandlers&quot; type=&quot;tEventHandlers&quot;/&gt;&lt;xsd:complexType name=&quot;tEventHandlers&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element onAlarm needs to be a Local Element Declaration, because there is another onAlarm element defined for the pick activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;onEvent&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element name=&quot;onAlarm&quot; type=&quot;tOnAlarmEvent&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; eventHandlers基于tExtensibleElements扩展，由2种元素的sequence组成： onEvent：见element：onEvent onAlarm：见complexType：tOnAlarmEvent element：onEvent12345678910111213&lt;xsd:element name=&quot;onEvent&quot; type=&quot;tOnEvent&quot;/&gt;&lt;xsd:complexType name=&quot;tOnEvent&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tOnMsgCommon&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;scope&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;messageType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;element&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; onEvent元素基于tOnMsgCommon进行扩展，包含一个element sequence： scope：用于表明作用范围 2个attribute： messageType element complexType：tOnMsgCommon1234567891011121314151617181920&lt;xsd:complexType name=&quot;tOnMsgCommon&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlations needs to be a Local Element Declaration, because there is another correlations element defined for the invoke activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlations&quot; type=&quot;tCorrelations&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;fromParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;portType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;operation&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;messageExchange&quot; type=&quot;xsd:NCName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; tOnMsgCommon这个complexType同样支持tExtensibleElements扩展，包含由两类element组成的sequence： correlations：type为tCorrelations fromParts 同时还引入了5种属性： partnerLink：必填的链接名 portType：选填的端口类型 operation：必填的操作 messageExchange：选填的操作信息 variable：选填的变量 complexType：tCorrelations12345678910111213141516171819202122232425262728293031&lt;xsd:complexType name=&quot;tCorrelations&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlation needs to be a Local Element Declaration, because there is another correlation element defined for the invoke activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlation&quot; type=&quot;tCorrelation&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:complexType name=&quot;tCorrelation&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;set&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;initiate&quot; type=&quot;tInitiate&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:simpleType name=&quot;tInitiate&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;yes&quot;/&gt; &lt;xsd:enumeration value=&quot;join&quot;/&gt; &lt;xsd:enumeration value=&quot;no&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; tCorrelations基于tExtensibleElements扩展，由1至多个correlation的sequence组成。 tCorrelation同样基于tExtensibleElements扩展，在此之上还定义了两个属性： set initiate：yes | join | no complexType：tOnAlarmEvent12345678910111213141516&lt;xsd:complexType name=&quot;tOnAlarmEvent&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:choice&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;forOrUntilGroup&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;repeatEvery&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:element ref=&quot;repeatEvery&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt; &lt;xsd:element ref=&quot;scope&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; tOnAlarmEvent基于tExtensibleElements扩展，由1个group：forOrUntilGroup 和 0或1个element：repeatEvery组成的sequence，或者1个element：repeatEvery，再加上一个scope组成的sequence组成。 三个元素都通过ref引用，可以继续往后看定义。 group：forOrUntilGroup123456789101112&lt;xsd:group name=&quot;forOrUntilGroup&quot;&gt; &lt;xsd:choice&gt; &lt;xsd:element ref=&quot;for&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;until&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt;&lt;/xsd:group&gt;&lt;xsd:element name=&quot;for&quot; type=&quot;tDuration-expr&quot;/&gt;&lt;xsd:element name=&quot;until&quot; type=&quot;tDeadline-expr&quot;/&gt;&lt;xsd:element name=&quot;repeatEvery&quot; type=&quot;tDuration-expr&quot;/&gt; 可以看到，forOrUntilGroup还真就是for或者until两个元素中选一个。这两个东西又分别通过tDuration-expr，tDeadline-expr来定义。 刚好element：repeatEvery也在这后边，一起讲了吧，同样通过tDuration-expr来定义。 complexType：tActivity123456789101112&lt;xsd:complexType name=&quot;tActivity&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;targets&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;sources&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;suppressJoinFailure&quot; type=&quot;tBoolean&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 一看是activity的type，感觉应该出现过，其实并没有，大概是后边会用到吧。 同样基于tExtensibleElements扩展（啥都要tExtensibleElements扩展一下，这兼容性也太强了吧），包含两个元素组成的sequence targets：出现0或1次 sources：出现0或1次 另外还有俩属性： name suppressJoinFailure：有一种故障叫joinFailure，在连接条件求值为 false 时抛出。通过将流程或活动属性 suppressJoinFailure 设置为 yes，可以禁止此故障。 element：targets123456789101112&lt;xsd:element name=&quot;targets&quot; type=&quot;tTargets&quot;/&gt;&lt;xsd:complexType name=&quot;tTargets&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;joinCondition&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;target&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; targets基于tExtensibleElements进行扩展，包含两个元素组成的sequence： joinCondition：0或1个 target：1到多个 element：joinCondition1&lt;xsd:element name=&quot;joinCondition&quot; type=&quot;tCondition&quot;/&gt; 这玩意儿的定义在tCondition里边，其实装的就是几乎啥都可以写的混合内容。 element：target123456789&lt;xsd:element name=&quot;target&quot; type=&quot;tTarget&quot;/&gt;&lt;xsd:complexType name=&quot;tTarget&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;linkName&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; tTarget这个东西是一个机遇tExtensibleElements扩展的元素，就增加了一个元素 linkName：NCName，必填，写上你的目标 element：sources1234567891011121314151617181920212223242526&lt;xsd:element name=&quot;sources&quot; type=&quot;tSources&quot;/&gt;&lt;xsd:complexType name=&quot;tSources&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;source&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;source&quot; type=&quot;tSource&quot;/&gt;&lt;xsd:complexType name=&quot;tSource&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;transitionCondition&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;linkName&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;transitionCondition&quot; type=&quot;tCondition&quot;/&gt; sources：tExtensibleElements，以及1到多个source source：tExtensibleElements扩展，还有一个元素的sequence transitionCondition：转移条件，可以不出现，也可以出现一次 还有一个属性 linkName：NCName，必填，写上你的来源 element：assign123456789101112131415&lt;xsd:element name=&quot;assign&quot; type=&quot;tAssign&quot;/&gt;&lt;xsd:complexType name=&quot;tAssign&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:choice maxOccurs=&quot;unbounded&quot;&gt; &lt;xsd:element ref=&quot;copy&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;extensionAssignOperation&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;validate&quot; type=&quot;tBoolean&quot; use=&quot;optional&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; Assign，基于tActivity扩展，增加了两个属性，二选一只猴构成sequence copy：出现1至多次 extensionAssignOperation：出现1至多次 还增加了一个属性 validate：bool值，默认是no，可选 element：copy1234567891011121314&lt;xsd:element name=&quot;copy&quot; type=&quot;tCopy&quot;/&gt;&lt;xsd:complexType name=&quot;tCopy&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;from&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;to&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;keepSrcElementName&quot; type=&quot;tBoolean&quot; use=&quot;optional&quot; default=&quot;no&quot;/&gt; &lt;xsd:attribute name=&quot;ignoreMissingFromData&quot; type=&quot;tBoolean&quot; use=&quot;optional&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; copy，基于tExtensibleElements扩展，两个元素比较好理解 from：从哪里copy to：copy到哪里 还有两个属性： keepSrcElementName：bool值，可选，默认no，是否保存源元素的属性名 ignoreMissingFromData：bool值，可选，默认no，是否忽略数据中的遗失部分 element：from12345678910111213141516171819&lt;xsd:element name=&quot;from&quot; type=&quot;tFrom&quot;/&gt;&lt;xsd:complexType name=&quot;tFrom&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;documentation&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:choice minOccurs=&quot;0&quot;&gt; &lt;xsd:element ref=&quot;literal&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;query&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;expressionLanguage&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot;/&gt; &lt;xsd:attribute name=&quot;part&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;property&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;endpointReference&quot; type=&quot;tRoles&quot;/&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; 然而这个from并不简单，我们先看看这个sequence里边装了什么 documentation：element，0至多个，前边定义过了，基本上就是一个mixed的啥都可以写的东西，属性里边指明source和language就可以了 any：0至多个来自其他命名空间的任意元素 literal/query：这俩二选一，具体是啥看后边定义 还有几个属性 expressionLanguage：表达语言 variable：BPELVariableName part：来自哪一部分 property：属性是什么 partnerLink endpointReference：通过tRoles定义 anyAttribute：还可以随便加其他属性 element：literal1234567&lt;xsd:element name=&quot;literal&quot; type=&quot;tLiteral&quot;/&gt;&lt;xsd:complexType name=&quot;tLiteral&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any namespace=&quot;##any&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt;&lt;/xsd:complexType&gt; literal就是一个mixed描述段落，里边可以有一个任意元素。 element：query123456789&lt;xsd:element name=&quot;query&quot; type=&quot;tQuery&quot;/&gt;&lt;xsd:complexType name=&quot;tQuery&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;queryLanguage&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; Query和literal相似，是一个mixed描述段落，里边可以有任意个任意元素。同时它还有属性 queryLanguage：表明查询语言 anyAttribute：看似随便加属性，实际上根据查询语言不通增加其他属性 simpleType：tRoles123456&lt;xsd:simpleType name=&quot;tRoles&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;myRole&quot;/&gt; &lt;xsd:enumeration value=&quot;partnerRole&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; myRole和partnerRole两个值二选一 element：to123456789101112131415&lt;xsd:element name=&quot;to&quot; type=&quot;tTo&quot;/&gt;&lt;xsd:complexType name=&quot;tTo&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;documentation&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;query&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;expressionLanguage&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot;/&gt; &lt;xsd:attribute name=&quot;part&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;property&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; 这个to也不简单，我们看看这个sequence里边装了什么 documentation：element，0至多个，前边定义过了，基本上就是一个mixed的啥都可以写的东西，属性里边指明source和language就可以了 any：0至多个来自其他命名空间的任意元素 query：查询到对应写入的部分 还有几个属性 expressionLanguage：表达语言 variable：BPELVariableName part：去哪一部分 property：属性是什么 partnerLink anyAttribute：还可以根据表达语言随便加其他属性 element：extensionAssignOperation1234567&lt;xsd:element name=&quot;extensionAssignOperation&quot; type=&quot;tExtensionAssignOperation&quot;/&gt;&lt;xsd:complexType name=&quot;tExtensionAssignOperation&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 这个东西是assign中的一个element，怪不得assign没有基于tExtensibleElements扩展，放在里边了。 element：compensate1234567&lt;xsd:element name=&quot;compensate&quot; type=&quot;tCompensate&quot;/&gt;&lt;xsd:complexType name=&quot;tCompensate&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 就是tActivity的一个元素化，可以看作是一个最原始，最纯粹的activity。 element：compensateScope123456789&lt;xsd:element name=&quot;compensateScope&quot; type=&quot;tCompensateScope&quot;/&gt;&lt;xsd:complexType name=&quot;tCompensateScope&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:attribute name=&quot;target&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 在compensate之上增加了一个属性： target：相当于给补偿增加了一个范围 element：empty1234567&lt;xsd:element name=&quot;empty&quot; type=&quot;tEmpty&quot;/&gt;&lt;xsd:complexType name=&quot;tEmpty&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 就是tActivity的一个元素化，可以看作是一个最原始，最纯粹的activity。 和compensate是一样的，在语义上和用法上不一样。 element：exit1234567&lt;xsd:element name=&quot;exit&quot; type=&quot;tExit&quot;/&gt;&lt;xsd:complexType name=&quot;tExit&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 就是tActivity的一个元素化，可以看作是一个最原始，最纯粹的activity。 和compensate、empty定义是一样的，在语义上和用法上不一样。 element：extensionActivity1234567&lt;xsd:element name=&quot;extensionActivity&quot; type=&quot;tExtensionActivity&quot;/&gt;&lt;xsd:complexType name=&quot;tExtensionActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt; &lt;/xsd:sequence&gt;&lt;/xsd:complexType&gt; 允许从其他命名空间增加元素当作activity装进来 element：flow123456789101112&lt;xsd:element name=&quot;flow&quot; type=&quot;tFlow&quot;/&gt;&lt;xsd:complexType name=&quot;tFlow&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;links&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 基于tActivity进行扩展，sequence中包含： element links：可以没有，在后边定义 group activity：1到多个activity的group，算是一个嵌套的定义 element：links123456789101112131415161718192021&lt;xsd:element name=&quot;links&quot; type=&quot;tLinks&quot;/&gt;&lt;xsd:complexType name=&quot;tLinks&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;link&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;link&quot; type=&quot;tLink&quot;/&gt;&lt;xsd:complexType name=&quot;tLink&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; links基于tExtensibleElements进行扩展（辣个男人又回来了），包含1至多个link link同样基于tExtensibleElements进行扩展，增加了一个属性 name：NCName，这就是link的真相了 element：forEach1234567891011121314151617181920&lt;xsd:element name=&quot;forEach&quot; type=&quot;tForEach&quot;/&gt;&lt;xsd:complexType name=&quot;tForEach&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;startCounterValue&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;finalCounterValue&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;completionCondition&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;scope&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;counterName&quot; type=&quot;BPELVariableName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;parallel&quot; type=&quot;tBoolean&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;startCounterValue&quot; type=&quot;tExpression&quot;/&gt;&lt;xsd:element name=&quot;finalCounterValue&quot; type=&quot;tExpression&quot;/&gt; 看名字就知道是一个forEach循环了，element包括 startCounterValue finalCounterValue completionCondition scope 这四个应该不用解释了吧，for循环要素 然后还有两个属性 counterName：计数器的名称 parallel：是否并行 element：completionCondition1234567891011&lt;xsd:element name=&quot;completionCondition&quot; type=&quot;tCompletionCondition&quot;/&gt;&lt;xsd:complexType name=&quot;tCompletionCondition&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;branches&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 这个condition由一组branches构成 element：branches123456789&lt;xsd:element name=&quot;branches&quot; type=&quot;tBranches&quot;/&gt;&lt;xsd:complexType name=&quot;tBranches&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExpression&quot;&gt; &lt;xsd:attribute name=&quot;successfulBranchesOnly&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; branches基于tExpression进行扩展，还有一个属性 successfulBranchesOnly：默认是no element：if1234567891011121314&lt;xsd:element name=&quot;if&quot; type=&quot;tIf&quot;/&gt;&lt;xsd:complexType name=&quot;tIf&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;condition&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;elseif&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;else&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; if也是一类activity，基于tAcitivity进行扩展，sequence中包括 condition：element，至少一个 activity：group，至少一个 elseif：element，0到多个 else：element，可以没有 element：elseif1234567891011121314&lt;xsd:element name=&quot;elseif&quot; type=&quot;tElseif&quot;/&gt;&lt;xsd:complexType name=&quot;tElseif&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;condition&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;else&quot; type=&quot;tActivityContainer&quot;/&gt; elseif基于tExtensibleElements扩展，sequence中包括 condition：element，数量1 activity：group，数量1 Else就直接是tActivityContainer了，condition都不用。 element：invoke1234567891011121314151617181920212223242526&lt;xsd:element name=&quot;invoke&quot; type=&quot;tInvoke&quot;/&gt;&lt;xsd:complexType name=&quot;tInvoke&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlations needs to be a Local Element Declaration, because there is another correlations element defined for the non-invoke activities. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlations&quot; type=&quot;tCorrelationsWithPattern&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;catch&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;catchAll&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;compensationHandler&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;toParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;fromParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;portType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;operation&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;inputVariable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;outputVariable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; annotation说明就不讲了 基于tActivity扩展，用调用其他 Web 服务，element有6个 correlations：本地的元素声明 catch catchAll compensationHandler toParts fromParts attribute有5个 partnerLink portType operation inputVariable outputVariable 感觉看名字就懂了，没啥好讲的 complexType：tCorrelationsWithPattern123456789101112131415161718192021222324252627282930&lt;xsd:complexType name=&quot;tCorrelationsWithPattern&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlation needs to be a Local Element Declaration, because there is another correlation element defined for the non-invoke activities. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlation&quot; type=&quot;tCorrelationWithPattern&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:complexType name=&quot;tCorrelationWithPattern&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tCorrelation&quot;&gt; &lt;xsd:attribute name=&quot;pattern&quot; type=&quot;tPattern&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:simpleType name=&quot;tPattern&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;request&quot;/&gt; &lt;xsd:enumeration value=&quot;response&quot;/&gt; &lt;xsd:enumeration value=&quot;request-response&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; 一通定义，实际上这个tCorrelationsWithPattern就是1至多个tCorrelationWithPattern 这个tCorrelationWithPattern从tCorrelation进行扩展，增加了属性pattern 这个pattern就是request、response、request-response三选一 element：fromParts12345678910111213141516171819202122&lt;xsd:element name=&quot;fromParts&quot; type=&quot;tFromParts&quot;/&gt;&lt;xsd:complexType name=&quot;tFromParts&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;fromPart&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;fromPart&quot; type=&quot;tFromPart&quot;/&gt;&lt;xsd:complexType name=&quot;tFromPart&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;part&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;toVariable&quot; type=&quot;BPELVariableName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; fromParts扩展自tExtensibleElements，由1到多个fromPart组成 fromPart同样扩展自tExtensibleElements，包含两个attribute part toVariable element：toParts12345678910111213141516171819202122&lt;xsd:element name=&quot;toParts&quot; type=&quot;tToParts&quot;/&gt;&lt;xsd:complexType name=&quot;tToParts&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;toPart&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;toPart&quot; type=&quot;tToPart&quot;/&gt;&lt;xsd:complexType name=&quot;tToPart&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;part&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;fromVariable&quot; type=&quot;BPELVariableName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; toParts扩展自tExtensibleElements，由1到多个toPart组成 toPart同样扩展自tExtensibleElements，包含两个attribute part fromVariable element：pick123456789101112131415161718&lt;xsd:element name=&quot;pick&quot; type=&quot;tPick&quot;/&gt;&lt;xsd:complexType name=&quot;tPick&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element onAlarm needs to be a Local Element Declaration, because there is another onAlarm element defined for event handlers. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;onMessage&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element name=&quot;onAlarm&quot; type=&quot;tOnAlarmPick&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;createInstance&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; pick扩展自tActivity 两个属性都在后边定义： onMessage onAlarm 一个属性： createInstance element：onMessage1234567891011&lt;xsd:element name=&quot;onMessage&quot; type=&quot;tOnMessage&quot;/&gt;&lt;xsd:complexType name=&quot;tOnMessage&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tOnMsgCommon&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tOnMsgCommon sequence中是一个activity的group complexType：tOnAlarmPick12345678910&lt;xsd:complexType name=&quot;tOnAlarmPick&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;forOrUntilGroup&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tExtensibleElements sequence中有两个group forOrUntilGroup activity 都是出现一次 element：receive1234567891011121314151617181920212223&lt;xsd:element name=&quot;receive&quot; type=&quot;tReceive&quot;/&gt;&lt;xsd:complexType name=&quot;tReceive&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlations needs to be a Local Element Declaration, because there is another correlations element defined for the invoke activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlations&quot; type=&quot;tCorrelations&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;fromParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;portType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;operation&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;createInstance&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;xsd:attribute name=&quot;messageExchange&quot; type=&quot;xsd:NCName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，用于（接收请求）等待客户端通过发送消息调用业务流程 2个element correlations fromParts 6个attribute partnerLink portType operation variable createInstance messageExchange element：repeatUntil123456789101112&lt;xsd:element name=&quot;repeatUntil&quot; type=&quot;tRepeatUntil&quot;/&gt;&lt;xsd:complexType name=&quot;tRepeatUntil&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;condition&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity sequence中包含 activity：group，数量为1 condition：element，数量也是1 element：reply1234567891011121314151617181920212223&lt;xsd:element name=&quot;reply&quot; type=&quot;tReply&quot;/&gt;&lt;xsd:complexType name=&quot;tReply&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlations needs to be a Local Element Declaration, because there is another correlations element defined for the invoke activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlations&quot; type=&quot;tCorrelations&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;toParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;portType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;operation&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;faultName&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;messageExchange&quot; type=&quot;xsd:NCName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，用于生成同步操作的响应 2个element correlations toParts 6个attribute partnerLink portType operation variable faultName messageExchange element：rethrow1234567&lt;xsd:element name=&quot;rethrow&quot; type=&quot;tRethrow&quot;/&gt;&lt;xsd:complexType name=&quot;tRethrow&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 就是tActivity的一个元素化，可以看作是一个最原始，最纯粹的activity。 和compensate、empty，exit定义是一样的，就是在语义上和用法上不一样。 element：scope1234567891011121314151617181920212223242526&lt;xsd:element name=&quot;scope&quot; type=&quot;tScope&quot;/&gt;&lt;xsd:complexType name=&quot;tScope&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;There is no schema-level default for &quot;exitOnStandardFault&quot; at &quot;scope&quot;. Because, it will inherit default from enclosing scope or process. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;partnerLinks&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;messageExchanges&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;variables&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;correlationSets&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;faultHandlers&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;compensationHandler&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;terminationHandler&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;eventHandlers&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;isolated&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;xsd:attribute name=&quot;exitOnStandardFault&quot; type=&quot;tBoolean&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，用于以分层方式将复杂流程划分为多个组织部分。scope为活动提供了行为上下文。换言之，scope可以为不同的活动（或在 或 ) 等通用的结构化活动下收集的活动集）定义不同的故障处理程序。除了定义故障处理程序以外，scope还可以声明只在作用域中可见的变量。scope还可以定义本地关联集、补偿处理程序和事件处理程序。 sequence中有： partnerLinks messageExchanges variables correlationSets faultHandlers compensationHandler terminationHandler eventHandlers activity 还有两个属性 isolated exitOnStandardFault element：compensationHandler1234567&lt;xsd:element name=&quot;compensationHandler&quot; type=&quot;tActivityContainer&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This element can contain all activities including the activities compensate and compensateScope. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt; 实际上就是一个tActivityContainer element：terminationHandler1234567&lt;xsd:element name=&quot;terminationHandler&quot; type=&quot;tActivityContainer&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This element can contain all activities including the activities compensate and compensateScope. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt; 实际上就是一个tActivityContainer element：sequence1234567891011&lt;xsd:element name=&quot;sequence&quot; type=&quot;tSequence&quot;/&gt;&lt;xsd:complexType name=&quot;tSequence&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，但是里边还可以装很多的activity的group的序列 element：throw12345678910&lt;xsd:element name=&quot;throw&quot; type=&quot;tThrow&quot;/&gt;&lt;xsd:complexType name=&quot;tThrow&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:attribute name=&quot;faultName&quot; type=&quot;xsd:QName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;faultVariable&quot; type=&quot;BPELVariableName&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，增加了两个属性 faultName faultVariable element：validate123456789&lt;xsd:element name=&quot;validate&quot; type=&quot;tValidate&quot;/&gt;&lt;xsd:complexType name=&quot;tValidate&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:attribute name=&quot;variables&quot; use=&quot;required&quot; type=&quot;BPELVariableNames&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，增加了1个属性 variables：BPELVariableNames simpleType：BPELVariableNames12345678&lt;xsd:simpleType name=&quot;BPELVariableNames&quot;&gt; &lt;xsd:restriction&gt; &lt;xsd:simpleType&gt; &lt;xsd:list itemType=&quot;BPELVariableName&quot;/&gt; &lt;/xsd:simpleType&gt; &lt;xsd:minLength value=&quot;1&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; 一个BPELVariableName的list，默认空格分割，最短一个 element：wait123456789101112&lt;xsd:element name=&quot;wait&quot; type=&quot;tWait&quot;/&gt;&lt;xsd:complexType name=&quot;tWait&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:choice&gt; &lt;xsd:element ref=&quot;for&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;until&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，增加了元素，从for和until中二选一 element：while123456789101112&lt;xsd:element name=&quot;while&quot; type=&quot;tWhile&quot;/&gt;&lt;xsd:complexType name=&quot;tWhile&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;condition&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，增加了一个sequence，里边有 condition activity complexType：tExpression1234567&lt;xsd:complexType name=&quot;tExpression&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; processContents=&quot;lax&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;expressionLanguage&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; tExpression的内容基本就是随便写 属性有一个expressionLanguage，然后还可以再增加其他属性 看起来是any，实际上要看expressionLanguage的 complexType：tCondition12345&lt;xsd:complexType name=&quot;tCondition&quot;&gt; &lt;xsd:complexContent mixed=&quot;true&quot;&gt; &lt;xsd:extension base=&quot;tExpression&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; tCondition就是在tExpression的基础上随便写 element：condition1234567&lt;xsd:element name=&quot;condition&quot; type=&quot;tBoolean-expr&quot;/&gt;&lt;xsd:complexType name=&quot;tBoolean-expr&quot;&gt; &lt;xsd:complexContent mixed=&quot;true&quot;&gt; &lt;xsd:extension base=&quot;tExpression&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; condition也是在tExpression的基础上随便写 complexType：tDuration-expr12345&lt;xsd:complexType name=&quot;tDuration-expr&quot;&gt; &lt;xsd:complexContent mixed=&quot;true&quot;&gt; &lt;xsd:extension base=&quot;tExpression&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 在tExpression的基础上随便写 complexType：tDeadline-expr12345&lt;xsd:complexType name=&quot;tDeadline-expr&quot;&gt; &lt;xsd:complexContent mixed=&quot;true&quot;&gt; &lt;xsd:extension base=&quot;tExpression&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 在tExpression的基础上随便写 simpleType：tBoolean123456&lt;xsd:simpleType name=&quot;tBoolean&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;yes&quot;/&gt; &lt;xsd:enumeration value=&quot;no&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; yes or no，二选一]]></content>
      <tags>
        <tag>bpel</tag>
        <tag>wsbpel</tag>
        <tag>ws-bpel</tag>
        <tag>bpel2.0</tag>
        <tag>schema</tag>
        <tag>xsd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WS-BPEL 2.0 xml schema 详解(三)]]></title>
    <url>%2F2019%2F03%2F22%2FWS-BPEL-2-0-xml-schema-%E8%AF%A6%E8%A7%A3-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[element：exit1234567&lt;xsd:element name=&quot;exit&quot; type=&quot;tExit&quot;/&gt;&lt;xsd:complexType name=&quot;tExit&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 就是tActivity的一个元素化，可以看作是一个最原始，最纯粹的activity。 和compensate、empty定义是一样的，在语义上和用法上不一样。 element：extensionActivity1234567&lt;xsd:element name=&quot;extensionActivity&quot; type=&quot;tExtensionActivity&quot;/&gt;&lt;xsd:complexType name=&quot;tExtensionActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt; &lt;/xsd:sequence&gt;&lt;/xsd:complexType&gt; 允许从其他命名空间增加元素当作activity装进来 element：flow123456789101112&lt;xsd:element name=&quot;flow&quot; type=&quot;tFlow&quot;/&gt;&lt;xsd:complexType name=&quot;tFlow&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;links&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 基于tActivity进行扩展，sequence中包含： element links：可以没有，在后边定义 group activity：1到多个activity的group，算是一个嵌套的定义 element：links123456789101112131415161718192021&lt;xsd:element name=&quot;links&quot; type=&quot;tLinks&quot;/&gt;&lt;xsd:complexType name=&quot;tLinks&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;link&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;link&quot; type=&quot;tLink&quot;/&gt;&lt;xsd:complexType name=&quot;tLink&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; links基于tExtensibleElements进行扩展（辣个男人又回来了），包含1至多个link link同样基于tExtensibleElements进行扩展，增加了一个属性 name：NCName，这就是link的真相了 element：forEach1234567891011121314151617181920&lt;xsd:element name=&quot;forEach&quot; type=&quot;tForEach&quot;/&gt;&lt;xsd:complexType name=&quot;tForEach&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;startCounterValue&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;finalCounterValue&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;completionCondition&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;scope&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;counterName&quot; type=&quot;BPELVariableName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;parallel&quot; type=&quot;tBoolean&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;startCounterValue&quot; type=&quot;tExpression&quot;/&gt;&lt;xsd:element name=&quot;finalCounterValue&quot; type=&quot;tExpression&quot;/&gt; 看名字就知道是一个forEach循环了，element包括 startCounterValue finalCounterValue completionCondition scope 这四个应该不用解释了吧，for循环要素 然后还有两个属性 counterName：计数器的名称 parallel：是否并行 element：completionCondition1234567891011&lt;xsd:element name=&quot;completionCondition&quot; type=&quot;tCompletionCondition&quot;/&gt;&lt;xsd:complexType name=&quot;tCompletionCondition&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;branches&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 这个condition由一组branches构成 element：branches123456789&lt;xsd:element name=&quot;branches&quot; type=&quot;tBranches&quot;/&gt;&lt;xsd:complexType name=&quot;tBranches&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExpression&quot;&gt; &lt;xsd:attribute name=&quot;successfulBranchesOnly&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; branches基于tExpression进行扩展，还有一个属性 successfulBranchesOnly：默认是no element：if1234567891011121314&lt;xsd:element name=&quot;if&quot; type=&quot;tIf&quot;/&gt;&lt;xsd:complexType name=&quot;tIf&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;condition&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;elseif&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;else&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; if也是一类activity，基于tAcitivity进行扩展，sequence中包括 condition：element，至少一个 activity：group，至少一个 elseif：element，0到多个 else：element，可以没有 element：elseif1234567891011121314&lt;xsd:element name=&quot;elseif&quot; type=&quot;tElseif&quot;/&gt;&lt;xsd:complexType name=&quot;tElseif&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;condition&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;else&quot; type=&quot;tActivityContainer&quot;/&gt; elseif基于tExtensibleElements扩展，sequence中包括 condition：element，数量1 activity：group，数量1 Else就直接是tActivityContainer了，condition都不用。 element：invoke1234567891011121314151617181920212223242526&lt;xsd:element name=&quot;invoke&quot; type=&quot;tInvoke&quot;/&gt;&lt;xsd:complexType name=&quot;tInvoke&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlations needs to be a Local Element Declaration, because there is another correlations element defined for the non-invoke activities. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlations&quot; type=&quot;tCorrelationsWithPattern&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;catch&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;catchAll&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;compensationHandler&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;toParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;fromParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;portType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;operation&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;inputVariable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;outputVariable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; annotation说明就不讲了 基于tActivity扩展，用调用其他 Web 服务，element有6个 correlations：本地的元素声明 catch catchAll compensationHandler toParts fromParts attribute有5个 partnerLink portType operation inputVariable outputVariable 感觉看名字就懂了，没啥好讲的 complexType：tCorrelationsWithPattern123456789101112131415161718192021222324252627282930&lt;xsd:complexType name=&quot;tCorrelationsWithPattern&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlation needs to be a Local Element Declaration, because there is another correlation element defined for the non-invoke activities. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlation&quot; type=&quot;tCorrelationWithPattern&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:complexType name=&quot;tCorrelationWithPattern&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tCorrelation&quot;&gt; &lt;xsd:attribute name=&quot;pattern&quot; type=&quot;tPattern&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:simpleType name=&quot;tPattern&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;request&quot;/&gt; &lt;xsd:enumeration value=&quot;response&quot;/&gt; &lt;xsd:enumeration value=&quot;request-response&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; 一通定义，实际上这个tCorrelationsWithPattern就是1至多个tCorrelationWithPattern 这个tCorrelationWithPattern从tCorrelation进行扩展，增加了属性pattern 这个pattern就是request、response、request-response三选一 element：fromParts12345678910111213141516171819202122&lt;xsd:element name=&quot;fromParts&quot; type=&quot;tFromParts&quot;/&gt;&lt;xsd:complexType name=&quot;tFromParts&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;fromPart&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;fromPart&quot; type=&quot;tFromPart&quot;/&gt;&lt;xsd:complexType name=&quot;tFromPart&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;part&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;toVariable&quot; type=&quot;BPELVariableName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; fromParts扩展自tExtensibleElements，由1到多个fromPart组成 fromPart同样扩展自tExtensibleElements，包含两个attribute part toVariable element：toParts12345678910111213141516171819202122&lt;xsd:element name=&quot;toParts&quot; type=&quot;tToParts&quot;/&gt;&lt;xsd:complexType name=&quot;tToParts&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;toPart&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;toPart&quot; type=&quot;tToPart&quot;/&gt;&lt;xsd:complexType name=&quot;tToPart&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;part&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;fromVariable&quot; type=&quot;BPELVariableName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; toParts扩展自tExtensibleElements，由1到多个toPart组成 toPart同样扩展自tExtensibleElements，包含两个attribute part fromVariable element：pick123456789101112131415161718&lt;xsd:element name=&quot;pick&quot; type=&quot;tPick&quot;/&gt;&lt;xsd:complexType name=&quot;tPick&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element onAlarm needs to be a Local Element Declaration, because there is another onAlarm element defined for event handlers. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;onMessage&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element name=&quot;onAlarm&quot; type=&quot;tOnAlarmPick&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;createInstance&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; pick扩展自tActivity 两个属性都在后边定义： onMessage onAlarm 一个属性： createInstance element：onMessage1234567891011&lt;xsd:element name=&quot;onMessage&quot; type=&quot;tOnMessage&quot;/&gt;&lt;xsd:complexType name=&quot;tOnMessage&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tOnMsgCommon&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tOnMsgCommon sequence中是一个activity的group complexType：tOnAlarmPick12345678910&lt;xsd:complexType name=&quot;tOnAlarmPick&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;forOrUntilGroup&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tExtensibleElements sequence中有两个group forOrUntilGroup activity 都是出现一次 element：receive1234567891011121314151617181920212223&lt;xsd:element name=&quot;receive&quot; type=&quot;tReceive&quot;/&gt;&lt;xsd:complexType name=&quot;tReceive&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlations needs to be a Local Element Declaration, because there is another correlations element defined for the invoke activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlations&quot; type=&quot;tCorrelations&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;fromParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;portType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;operation&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;createInstance&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;xsd:attribute name=&quot;messageExchange&quot; type=&quot;xsd:NCName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，用于（接收请求）等待客户端通过发送消息调用业务流程 2个element correlations fromParts 6个attribute partnerLink portType operation variable createInstance messageExchange element：repeatUntil123456789101112&lt;xsd:element name=&quot;repeatUntil&quot; type=&quot;tRepeatUntil&quot;/&gt;&lt;xsd:complexType name=&quot;tRepeatUntil&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;condition&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity sequence中包含 activity：group，数量为1 condition：element，数量也是1 element：reply1234567891011121314151617181920212223&lt;xsd:element name=&quot;reply&quot; type=&quot;tReply&quot;/&gt;&lt;xsd:complexType name=&quot;tReply&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlations needs to be a Local Element Declaration, because there is another correlations element defined for the invoke activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlations&quot; type=&quot;tCorrelations&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;toParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;portType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;operation&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;faultName&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;messageExchange&quot; type=&quot;xsd:NCName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，用于生成同步操作的响应 2个element correlations toParts 6个attribute partnerLink portType operation variable faultName messageExchange element：rethrow1234567&lt;xsd:element name=&quot;rethrow&quot; type=&quot;tRethrow&quot;/&gt;&lt;xsd:complexType name=&quot;tRethrow&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 就是tActivity的一个元素化，可以看作是一个最原始，最纯粹的activity。 和compensate、empty，exit定义是一样的，就是在语义上和用法上不一样。 element：scope1234567891011121314151617181920212223242526&lt;xsd:element name=&quot;scope&quot; type=&quot;tScope&quot;/&gt;&lt;xsd:complexType name=&quot;tScope&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;There is no schema-level default for &quot;exitOnStandardFault&quot; at &quot;scope&quot;. Because, it will inherit default from enclosing scope or process. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;partnerLinks&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;messageExchanges&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;variables&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;correlationSets&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;faultHandlers&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;compensationHandler&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;terminationHandler&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;eventHandlers&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;isolated&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;xsd:attribute name=&quot;exitOnStandardFault&quot; type=&quot;tBoolean&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，用于以分层方式将复杂流程划分为多个组织部分。scope为活动提供了行为上下文。换言之，scope可以为不同的活动（或在 或 ) 等通用的结构化活动下收集的活动集）定义不同的故障处理程序。除了定义故障处理程序以外，scope还可以声明只在作用域中可见的变量。scope还可以定义本地关联集、补偿处理程序和事件处理程序。 sequence中有： partnerLinks messageExchanges variables correlationSets faultHandlers compensationHandler terminationHandler eventHandlers activity 还有两个属性 isolated exitOnStandardFault element：compensationHandler1234567&lt;xsd:element name=&quot;compensationHandler&quot; type=&quot;tActivityContainer&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This element can contain all activities including the activities compensate and compensateScope. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt; 实际上就是一个tActivityContainer element：terminationHandler1234567&lt;xsd:element name=&quot;terminationHandler&quot; type=&quot;tActivityContainer&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This element can contain all activities including the activities compensate and compensateScope. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt; 实际上就是一个tActivityContainer element：sequence1234567891011&lt;xsd:element name=&quot;sequence&quot; type=&quot;tSequence&quot;/&gt;&lt;xsd:complexType name=&quot;tSequence&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，但是里边还可以装很多的activity的group的序列 element：throw12345678910&lt;xsd:element name=&quot;throw&quot; type=&quot;tThrow&quot;/&gt;&lt;xsd:complexType name=&quot;tThrow&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:attribute name=&quot;faultName&quot; type=&quot;xsd:QName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;faultVariable&quot; type=&quot;BPELVariableName&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，增加了两个属性 faultName faultVariable element：validate123456789&lt;xsd:element name=&quot;validate&quot; type=&quot;tValidate&quot;/&gt;&lt;xsd:complexType name=&quot;tValidate&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:attribute name=&quot;variables&quot; use=&quot;required&quot; type=&quot;BPELVariableNames&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，增加了1个属性 variables：BPELVariableNames simpleType：BPELVariableNames12345678&lt;xsd:simpleType name=&quot;BPELVariableNames&quot;&gt; &lt;xsd:restriction&gt; &lt;xsd:simpleType&gt; &lt;xsd:list itemType=&quot;BPELVariableName&quot;/&gt; &lt;/xsd:simpleType&gt; &lt;xsd:minLength value=&quot;1&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; 一个BPELVariableName的list，默认空格分割，最短一个 element：wait123456789101112&lt;xsd:element name=&quot;wait&quot; type=&quot;tWait&quot;/&gt;&lt;xsd:complexType name=&quot;tWait&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:choice&gt; &lt;xsd:element ref=&quot;for&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;until&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，增加了元素，从for和until中二选一 element：while123456789101112&lt;xsd:element name=&quot;while&quot; type=&quot;tWhile&quot;/&gt;&lt;xsd:complexType name=&quot;tWhile&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;condition&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，增加了一个sequence，里边有 condition activity complexType：tExpression1234567&lt;xsd:complexType name=&quot;tExpression&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; processContents=&quot;lax&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;expressionLanguage&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; tExpression的内容基本就是随便写 属性有一个expressionLanguage，然后还可以再增加其他属性 看起来是any，实际上要看expressionLanguage的 complexType：tCondition12345&lt;xsd:complexType name=&quot;tCondition&quot;&gt; &lt;xsd:complexContent mixed=&quot;true&quot;&gt; &lt;xsd:extension base=&quot;tExpression&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; tCondition就是在tExpression的基础上随便写 element：condition1234567&lt;xsd:element name=&quot;condition&quot; type=&quot;tBoolean-expr&quot;/&gt;&lt;xsd:complexType name=&quot;tBoolean-expr&quot;&gt; &lt;xsd:complexContent mixed=&quot;true&quot;&gt; &lt;xsd:extension base=&quot;tExpression&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; condition也是在tExpression的基础上随便写 complexType：tDuration-expr12345&lt;xsd:complexType name=&quot;tDuration-expr&quot;&gt; &lt;xsd:complexContent mixed=&quot;true&quot;&gt; &lt;xsd:extension base=&quot;tExpression&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 在tExpression的基础上随便写 complexType：tDeadline-expr12345&lt;xsd:complexType name=&quot;tDeadline-expr&quot;&gt; &lt;xsd:complexContent mixed=&quot;true&quot;&gt; &lt;xsd:extension base=&quot;tExpression&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 在tExpression的基础上随便写 simpleType：tBoolean123456&lt;xsd:simpleType name=&quot;tBoolean&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;yes&quot;/&gt; &lt;xsd:enumeration value=&quot;no&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; yes or no，二选一]]></content>
      <tags>
        <tag>bpel</tag>
        <tag>wsbpel</tag>
        <tag>ws-bpel</tag>
        <tag>bpel2.0</tag>
        <tag>schema</tag>
        <tag>xsd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WS-BPEL 2.0 xml schema 详解(二)]]></title>
    <url>%2F2019%2F03%2F22%2FWS-BPEL-2-0-xml-schema-%E8%AF%A6%E8%A7%A3-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[element：eventHandlers1234567891011121314151617&lt;xsd:element name=&quot;eventHandlers&quot; type=&quot;tEventHandlers&quot;/&gt;&lt;xsd:complexType name=&quot;tEventHandlers&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element onAlarm needs to be a Local Element Declaration, because there is another onAlarm element defined for the pick activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;onEvent&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element name=&quot;onAlarm&quot; type=&quot;tOnAlarmEvent&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; eventHandlers基于tExtensibleElements扩展，由2种元素的sequence组成： onEvent：见element：onEvent onAlarm：见complexType：tOnAlarmEvent element：onEvent12345678910111213&lt;xsd:element name=&quot;onEvent&quot; type=&quot;tOnEvent&quot;/&gt;&lt;xsd:complexType name=&quot;tOnEvent&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tOnMsgCommon&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;scope&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;messageType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;element&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; onEvent元素基于tOnMsgCommon进行扩展，包含一个element sequence： scope：用于表明作用范围 2个attribute： messageType element complexType：tOnMsgCommon1234567891011121314151617181920&lt;xsd:complexType name=&quot;tOnMsgCommon&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlations needs to be a Local Element Declaration, because there is another correlations element defined for the invoke activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlations&quot; type=&quot;tCorrelations&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;fromParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;portType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;operation&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;messageExchange&quot; type=&quot;xsd:NCName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; tOnMsgCommon这个complexType同样支持tExtensibleElements扩展，包含由两类element组成的sequence： correlations：type为tCorrelations fromParts 同时还引入了5种属性： partnerLink：必填的链接名 portType：选填的端口类型 operation：必填的操作 messageExchange：选填的操作信息 variable：选填的变量 complexType：tCorrelations12345678910111213141516171819202122232425262728293031&lt;xsd:complexType name=&quot;tCorrelations&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlation needs to be a Local Element Declaration, because there is another correlation element defined for the invoke activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlation&quot; type=&quot;tCorrelation&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:complexType name=&quot;tCorrelation&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;set&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;initiate&quot; type=&quot;tInitiate&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:simpleType name=&quot;tInitiate&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;yes&quot;/&gt; &lt;xsd:enumeration value=&quot;join&quot;/&gt; &lt;xsd:enumeration value=&quot;no&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; tCorrelations基于tExtensibleElements扩展，由1至多个correlation的sequence组成。 tCorrelation同样基于tExtensibleElements扩展，在此之上还定义了两个属性： set initiate：yes | join | no complexType：tOnAlarmEvent12345678910111213141516&lt;xsd:complexType name=&quot;tOnAlarmEvent&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:choice&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;forOrUntilGroup&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;repeatEvery&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:element ref=&quot;repeatEvery&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt; &lt;xsd:element ref=&quot;scope&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; tOnAlarmEvent基于tExtensibleElements扩展，由1个group：forOrUntilGroup 和 0或1个element：repeatEvery组成的sequence，或者1个element：repeatEvery，再加上一个scope组成的sequence组成。 三个元素都通过ref引用，可以继续往后看定义。 group：forOrUntilGroup123456789101112&lt;xsd:group name=&quot;forOrUntilGroup&quot;&gt; &lt;xsd:choice&gt; &lt;xsd:element ref=&quot;for&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;until&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt;&lt;/xsd:group&gt;&lt;xsd:element name=&quot;for&quot; type=&quot;tDuration-expr&quot;/&gt;&lt;xsd:element name=&quot;until&quot; type=&quot;tDeadline-expr&quot;/&gt;&lt;xsd:element name=&quot;repeatEvery&quot; type=&quot;tDuration-expr&quot;/&gt; 可以看到，forOrUntilGroup还真就是for或者until两个元素中选一个。这两个东西又分别通过tDuration-expr，tDeadline-expr来定义。 刚好element：repeatEvery也在这后边，一起讲了吧，同样通过tDuration-expr来定义。 complexType：tActivity123456789101112&lt;xsd:complexType name=&quot;tActivity&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;targets&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;sources&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;suppressJoinFailure&quot; type=&quot;tBoolean&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 一看是activity的type，感觉应该出现过，其实并没有，大概是后边会用到吧。 同样基于tExtensibleElements扩展（啥都要tExtensibleElements扩展一下，这兼容性也太强了吧），包含两个元素组成的sequence targets：出现0或1次 sources：出现0或1次 另外还有俩属性： name suppressJoinFailure：有一种故障叫joinFailure，在连接条件求值为 false 时抛出。通过将流程或活动属性 suppressJoinFailure 设置为 yes，可以禁止此故障。 element：targets123456789101112&lt;xsd:element name=&quot;targets&quot; type=&quot;tTargets&quot;/&gt;&lt;xsd:complexType name=&quot;tTargets&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;joinCondition&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;target&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; targets基于tExtensibleElements进行扩展，包含两个元素组成的sequence： joinCondition：0或1个 target：1到多个 element：joinCondition1&lt;xsd:element name=&quot;joinCondition&quot; type=&quot;tCondition&quot;/&gt; 这玩意儿的定义在tCondition里边，其实装的就是几乎啥都可以写的混合内容。 element：target123456789&lt;xsd:element name=&quot;target&quot; type=&quot;tTarget&quot;/&gt;&lt;xsd:complexType name=&quot;tTarget&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;linkName&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; tTarget这个东西是一个机遇tExtensibleElements扩展的元素，就增加了一个元素 linkName：NCName，必填，写上你的目标 element：sources1234567891011121314151617181920212223242526&lt;xsd:element name=&quot;sources&quot; type=&quot;tSources&quot;/&gt;&lt;xsd:complexType name=&quot;tSources&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;source&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;source&quot; type=&quot;tSource&quot;/&gt;&lt;xsd:complexType name=&quot;tSource&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;transitionCondition&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;linkName&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;transitionCondition&quot; type=&quot;tCondition&quot;/&gt; sources：tExtensibleElements，以及1到多个source source：tExtensibleElements扩展，还有一个元素的sequence transitionCondition：转移条件，可以不出现，也可以出现一次 还有一个属性 linkName：NCName，必填，写上你的来源 element：assign123456789101112131415&lt;xsd:element name=&quot;assign&quot; type=&quot;tAssign&quot;/&gt;&lt;xsd:complexType name=&quot;tAssign&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:choice maxOccurs=&quot;unbounded&quot;&gt; &lt;xsd:element ref=&quot;copy&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;extensionAssignOperation&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;validate&quot; type=&quot;tBoolean&quot; use=&quot;optional&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; Assign，基于tActivity扩展，增加了两个属性，二选一只猴构成sequence copy：出现1至多次 extensionAssignOperation：出现1至多次 还增加了一个属性 validate：bool值，默认是no，可选 element：copy1234567891011121314&lt;xsd:element name=&quot;copy&quot; type=&quot;tCopy&quot;/&gt;&lt;xsd:complexType name=&quot;tCopy&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;from&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;to&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;keepSrcElementName&quot; type=&quot;tBoolean&quot; use=&quot;optional&quot; default=&quot;no&quot;/&gt; &lt;xsd:attribute name=&quot;ignoreMissingFromData&quot; type=&quot;tBoolean&quot; use=&quot;optional&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; copy，基于tExtensibleElements扩展，两个元素比较好理解 from：从哪里copy to：copy到哪里 还有两个属性： keepSrcElementName：bool值，可选，默认no，是否保存源元素的属性名 ignoreMissingFromData：bool值，可选，默认no，是否忽略数据中的遗失部分 element：from12345678910111213141516171819&lt;xsd:element name=&quot;from&quot; type=&quot;tFrom&quot;/&gt;&lt;xsd:complexType name=&quot;tFrom&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;documentation&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:choice minOccurs=&quot;0&quot;&gt; &lt;xsd:element ref=&quot;literal&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;query&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;expressionLanguage&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot;/&gt; &lt;xsd:attribute name=&quot;part&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;property&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;endpointReference&quot; type=&quot;tRoles&quot;/&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; 然而这个from并不简单，我们先看看这个sequence里边装了什么 documentation：element，0至多个，前边定义过了，基本上就是一个mixed的啥都可以写的东西，属性里边指明source和language就可以了 any：0至多个来自其他命名空间的任意元素 literal/query：这俩二选一，具体是啥看后边定义 还有几个属性 expressionLanguage：表达语言 variable：BPELVariableName part：来自哪一部分 property：属性是什么 partnerLink endpointReference：通过tRoles定义 anyAttribute：还可以随便加其他属性 element：literal1234567&lt;xsd:element name=&quot;literal&quot; type=&quot;tLiteral&quot;/&gt;&lt;xsd:complexType name=&quot;tLiteral&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any namespace=&quot;##any&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt;&lt;/xsd:complexType&gt; literal就是一个mixed描述段落，里边可以有一个任意元素。 element：query123456789&lt;xsd:element name=&quot;query&quot; type=&quot;tQuery&quot;/&gt;&lt;xsd:complexType name=&quot;tQuery&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;queryLanguage&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; Query和literal相似，是一个mixed描述段落，里边可以有任意个任意元素。同时它还有属性 queryLanguage：表明查询语言 anyAttribute：看似随便加属性，实际上根据查询语言不通增加其他属性 simpleType：tRoles123456&lt;xsd:simpleType name=&quot;tRoles&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;myRole&quot;/&gt; &lt;xsd:enumeration value=&quot;partnerRole&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; myRole和partnerRole两个值二选一 element：to123456789101112131415&lt;xsd:element name=&quot;to&quot; type=&quot;tTo&quot;/&gt;&lt;xsd:complexType name=&quot;tTo&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;documentation&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;query&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;expressionLanguage&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot;/&gt; &lt;xsd:attribute name=&quot;part&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;property&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; 这个to也不简单，我们看看这个sequence里边装了什么 documentation：element，0至多个，前边定义过了，基本上就是一个mixed的啥都可以写的东西，属性里边指明source和language就可以了 any：0至多个来自其他命名空间的任意元素 query：查询到对应写入的部分 还有几个属性 expressionLanguage：表达语言 variable：BPELVariableName part：去哪一部分 property：属性是什么 partnerLink anyAttribute：还可以根据表达语言随便加其他属性 element：extensionAssignOperation1234567&lt;xsd:element name=&quot;extensionAssignOperation&quot; type=&quot;tExtensionAssignOperation&quot;/&gt;&lt;xsd:complexType name=&quot;tExtensionAssignOperation&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 这个东西是assign中的一个element，怪不得assign没有基于tExtensibleElements扩展，放在里边了。 element：compensate1234567&lt;xsd:element name=&quot;compensate&quot; type=&quot;tCompensate&quot;/&gt;&lt;xsd:complexType name=&quot;tCompensate&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 就是tActivity的一个元素化，可以看作是一个最原始，最纯粹的activity。 element：compensateScope123456789&lt;xsd:element name=&quot;compensateScope&quot; type=&quot;tCompensateScope&quot;/&gt;&lt;xsd:complexType name=&quot;tCompensateScope&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:attribute name=&quot;target&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 在compensate之上增加了一个属性： target：相当于给补偿增加了一个范围 element：empty1234567&lt;xsd:element name=&quot;empty&quot; type=&quot;tEmpty&quot;/&gt;&lt;xsd:complexType name=&quot;tEmpty&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 就是tActivity的一个元素化，可以看作是一个最原始，最纯粹的activity。 和compensate是一样的，在语义上和用法上不一样。]]></content>
      <tags>
        <tag>bpel</tag>
        <tag>wsbpel</tag>
        <tag>ws-bpel</tag>
        <tag>bpel2.0</tag>
        <tag>schema</tag>
        <tag>xsd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WS-BPEL 2.0 xml schema 详解(一)]]></title>
    <url>%2F2019%2F03%2F21%2FWS-BPEL-2-0-xml-schema-%E8%AF%A6%E8%A7%A3(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[本系列文章将一行一行的解读wsbpel2.0的源码。 相关xsd语法问题，请参见XSD学习笔记完整版 wsbpel2.0 xsd源码来自：ws-bpel_executable.xsd schema声明1234&lt;xsd:schema xmlns=&quot;http://docs.oasis-open.org/wsbpel/2.0/process/executable&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://docs.oasis-open.org/wsbpel/2.0/process/executable&quot; elementFormDefault=&quot;qualified&quot; blockDefault=&quot;#all&quot;&gt; ...&lt;\xsd&gt; 声明命名空间http://docs.oasis-open.org/wsbpel/2.0/process/executable，没有前缀。 引入http://www.w3.org/2001/XMLSchema的语素并以xsd为前缀。 elementFormDefault=&quot;qualified&quot;表示所有元素都必须加上前缀以表明其命名空间。 blockDefault=&quot;#all&quot;表示默认情况下不能通过派生类代替原类型。 annotation12345&lt;xsd:annotation&gt; &lt;xsd:documentation&gt;Schema for Executable Process for WS-BPEL 2.0 OASIS Standard 11th April, 2007 &lt;/xsd:documentation&gt;&lt;/xsd:annotation&gt; 赠送了一个简单的文档说明。 import1&lt;xsd:import namespace=&quot;http://www.w3.org/XML/1998/namespace&quot; schemaLocation=&quot;http://www.w3.org/2001/xml.xsd&quot;/&gt; 引入http://www.w3.org/2001/xml.xsd的xml语素，前缀默认为xml。 element：process1234567&lt;xsd:element name=&quot;process&quot; type=&quot;tProcess&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This is the root element for a WS-BPEL 2.0 process. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt; BPEL的根元素，此处没有定义任何内容，内部元素属性通过type=”tProcess”引入。 complexType：tProcess1234567891011121314151617181920212223&lt;xsd:complexType name=&quot;tProcess&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;extensions&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;import&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;partnerLinks&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;messageExchanges&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;variables&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;correlationSets&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;faultHandlers&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;eventHandlers&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;targetNamespace&quot; type=&quot;xsd:anyURI&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;queryLanguage&quot; type=&quot;xsd:anyURI&quot; default=&quot;urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0&quot;/&gt; &lt;xsd:attribute name=&quot;expressionLanguage&quot; type=&quot;xsd:anyURI&quot; default=&quot;urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0&quot;/&gt; &lt;xsd:attribute name=&quot;suppressJoinFailure&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;xsd:attribute name=&quot;exitOnStandardFault&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 首先是一个名为tExtensibleElements的扩展，先放一下往后看。 一个sequence，包括extensions，import，partnerLinks，messageExchanges，variables，correlationSets，faultHandlers，eventHandlers，还有一个activity的group，这里全部是ref，我们知道大概有些啥就行了，后边肯定会有详细的定义，先往后看吧。 接着是一堆attribute，包括process的 名称name 目标命名空间targetNamespace 查询语言queryLanguage，默认是urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0 表达语言expressionLanguage，默认是：urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0 抑制链接失败suppressJoinFailure，默认是否 标准错误退出exitOnStandardFault，默认是否 complexType：tExtensibleElement123456789101112&lt;xsd:complexType name=&quot;tExtensibleElements&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This type is extended by other component types to allow elements and attributes from other namespaces to be added at the modeled places. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;documentation&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; tExtensibleElements这个扩展马上就来了，可以看到，扩展除了0至多个documentation（后边再讲），还有 element：来自该元素的父元素的目标命名空间之外的任何命名空间的元素，且即使不能获取该命名空间架构，也不会发生任何错误。 attribute：同上 element：documentation123456789&lt;xsd:element name=&quot;documentation&quot; type=&quot;tDocumentation&quot;/&gt;&lt;xsd:complexType name=&quot;tDocumentation&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;source&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:attribute ref=&quot;xml:lang&quot;/&gt;&lt;/xsd:complexType&gt; documentation中： element：一个字符元素可混合出现的，元素可随意引入，不在此命名空间也没关系 attribute： source：通过URI表明来源 xml:lang: 文档语言，如en、CN等 group：activity123456789101112131415161718192021222324252627282930&lt;xsd:group name=&quot;activity&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;All standard WS-BPEL 2.0 activities in alphabetical order. Basic activities and structured activities. Addtional constraints: - rethrow activity can be used ONLY within a fault handler (i.e. &quot;catch&quot; and &quot;catchAll&quot; element) - compensate or compensateScope activity can be used ONLY within a fault handler, a compensation handler or a termination handler &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:choice&gt; &lt;xsd:element ref=&quot;assign&quot;/&gt; &lt;xsd:element ref=&quot;compensate&quot;/&gt; &lt;xsd:element ref=&quot;compensateScope&quot;/&gt; &lt;xsd:element ref=&quot;empty&quot;/&gt; &lt;xsd:element ref=&quot;exit&quot;/&gt; &lt;xsd:element ref=&quot;extensionActivity&quot;/&gt; &lt;xsd:element ref=&quot;flow&quot;/&gt; &lt;xsd:element ref=&quot;forEach&quot;/&gt; &lt;xsd:element ref=&quot;if&quot;/&gt; &lt;xsd:element ref=&quot;invoke&quot;/&gt; &lt;xsd:element ref=&quot;pick&quot;/&gt; &lt;xsd:element ref=&quot;receive&quot;/&gt; &lt;xsd:element ref=&quot;repeatUntil&quot;/&gt; &lt;xsd:element ref=&quot;reply&quot;/&gt; &lt;xsd:element ref=&quot;rethrow&quot;/&gt; &lt;xsd:element ref=&quot;scope&quot;/&gt; &lt;xsd:element ref=&quot;sequence&quot;/&gt; &lt;xsd:element ref=&quot;throw&quot;/&gt; &lt;xsd:element ref=&quot;validate&quot;/&gt; &lt;xsd:element ref=&quot;wait&quot;/&gt; &lt;xsd:element ref=&quot;while&quot;/&gt; &lt;/xsd:choice&gt;&lt;/xsd:group&gt; 定义了一个activity的group，用于在其他地方引用，比如说通过tProcess引用到process里边。 一个activity可以是以下元素中的一个，没写到的看后边源码解读好了： 基本活动名称 释义 assign 活动的作用是用新的数据来更新变量的值。Assign活动可以包括任意数量的基本复制操作。 compensate 通过该活动做一些补偿动作，通常需要和scope联合使用。只能从故障处理程序或另一个补偿处理活动中调用这个活动。补偿处理程序只能被调用一次。 compensateScope empty 无所事事，比如在一个错误发生后可以不做反应来消除这个错误 exit 该活动用于立刻终止业务流程实例。所有当前运行的活动必须被立刻终止。不用引用任何终点处理、错误处理或者补偿行为。 forEach invoke 活动允许业务流程同步或异步调用由合作伙伴提供的服务，服务实现可以是单向或请求-响应操作。Invoke活动使用“partnerLink”来引用伙伴服务。同过“portType”和“operation”指定相应的WSDL接口和操作。 pick 活动会等待一组相互排斥事件中的一个事件的发生，然后执行与发生的事件相关联的活动。它会阻塞业务流程执行，以等待某一特定的事件发生，比如接收到一个合适的消息或超时警报响起。当其中任何一个事件被触发后，业务流程就会继续执行，pick也随即完成了，不会再等待其他事件的发生。 receive 活动从流程的外部伙伴那获取数据，并将其保存到流程变量。通常一个Receive是一个流程的初始点，它会阻塞执行直到匹配的消息的到达。 reply 活动发送消息给伙伴来应答通过receive活动所接收到的消息。receive和reply的组合对应着WSDL portType上定义的一个请求-响应操作。如果receive活动对应着一个单向(one-way)操作，则不能在流程中定义对应的reply活动。 rethrow throw 提示一个错误，一个故障处理可以处理这样的错误。假如一个错误不被处理的话它最终到达最高层后导致过程的终止 validate wait 活动会暂停流程执行，等待一段给定的时间或等到某一时刻才继续运行。在WebSphere Process Server 6.0中，开发者可以非常灵活地指定wait中的到期条件，比如等待多少秒，等到特定的一个日期，或是使用内置的日期表现法。也可以使用Java代码来动态指定等待时间。 结构化活动名称 释义 extensionActivity flow 可以描述更为复杂的活动执行顺序。我们可以利用flow指定一个或多个并行执行的活动。为了定义任意的控制结构，可以在并行的活动中使用链接。 if repeatUntil scope 使用这个结构可以将一组活动组织在一起作为一个处理单位。通过这个组织方法多个活动可以使用同一个故障处理、事故处理和补偿处理。通过补偿处理BPEL可以处理长时间的处理。 sequence 定义一组按顺序先后执行的活动。执行顺序是sequence活动中嵌套活动的先后顺序。当sequence中的最后一个活动完成后，该sequence活动也就完成了。 while 继承于传统的结构化编程思想，提供了while-do循环结构的支持。它可以包含一个或多个活动。它指定反复执行其内部活动，直到成功条件不被满足为止。在WPS中允许其使用Java代码来描述条件表达式。 element：extensions12345678910111213141516171819202122&lt;xsd:element name=&quot;extensions&quot; type=&quot;tExtensions&quot;/&gt;&lt;xsd:complexType name=&quot;tExtensions&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;extension&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;extension&quot; type=&quot;tExtension&quot;/&gt;&lt;xsd:complexType name=&quot;tExtension&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;namespace&quot; type=&quot;xsd:anyURI&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;mustUnderstand&quot; type=&quot;tBoolean&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 一个extensions由1到多个extension组成。 extension扩展自tExtensibleElements，增加了namespace和mustUnderstand两个属性。 element：import1234567891011&lt;xsd:element name=&quot;import&quot; type=&quot;tImport&quot;/&gt;&lt;xsd:complexType name=&quot;tImport&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;namespace&quot; type=&quot;xsd:anyURI&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;location&quot; type=&quot;xsd:anyURI&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;importType&quot; type=&quot;xsd:anyURI&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; BPEL允许import，import元素在tExtensibleElements的基础上，增加namespace、location、importType三个属性，和xsd的import类似。 element：partnerLinks12345678910111213141516171819202122232425&lt;xsd:element name=&quot;partnerLinks&quot; type=&quot;tPartnerLinks&quot;/&gt;&lt;xsd:complexType name=&quot;tPartnerLinks&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;partnerLink&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;partnerLink&quot; type=&quot;tPartnerLink&quot;/&gt;&lt;xsd:complexType name=&quot;tPartnerLink&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;partnerLinkType&quot; type=&quot;xsd:QName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;myRole&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;partnerRole&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;initializePartnerRole&quot; type=&quot;tBoolean&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 和extensions相似，partnerLinks由1到多个partnerLink组成，同时支持tExtensibleElements扩展。 partnerLink在tExtensibleElements的基础上，增加了以下5个属性 name partnerLinkType myRole partnerRole initializaPartnerRole element：messageExchanges123456789101112131415161718192021&lt;xsd:element name=&quot;messageExchanges&quot; type=&quot;tMessageExchanges&quot;/&gt;&lt;xsd:complexType name=&quot;tMessageExchanges&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;messageExchange&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;messageExchange&quot; type=&quot;tMessageExchange&quot;/&gt;&lt;xsd:complexType name=&quot;tMessageExchange&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 和extensions相似，messageExchanges由1到多个messageExchange组成，同时支持tExtensibleElements扩展。 messageExchange在tExtensibleElements的基础上，增加了一个属性 name element：variables123456789101112131415161718192021222324252627&lt;xsd:element name=&quot;variables&quot; type=&quot;tVariables&quot;/&gt;&lt;xsd:complexType name=&quot;tVariables&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;variable&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;variable&quot; type=&quot;tVariable&quot;/&gt;&lt;xsd:complexType name=&quot;tVariable&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;from&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;BPELVariableName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;messageType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;element&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 和extensions相似，variables由1到多个variable组成，同时支持tExtensibleElements扩展。 variable在tExtensibleElements的基础上，增加了一个元素 from 增加了四个属性 name messageType type element simpleType：BPELVariableName12345&lt;xsd:simpleType name=&quot;BPELVariableName&quot;&gt; &lt;xsd:restriction base=&quot;xsd:NCName&quot;&gt; &lt;xsd:pattern value=&quot;[^\.]+&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; bpel变量的一个限制，BPELVariableName需要满足xsd:NCName限制，不能以.开头，且长度大于等于一个字符。 element：correlationSets12345678910111213141516171819202122&lt;xsd:element name=&quot;correlationSets&quot; type=&quot;tCorrelationSets&quot;/&gt;&lt;xsd:complexType name=&quot;tCorrelationSets&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;correlationSet&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;correlationSet&quot; type=&quot;tCorrelationSet&quot;/&gt;&lt;xsd:complexType name=&quot;tCorrelationSet&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;properties&quot; type=&quot;QNames&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 和extensions相似，correlationSets由1到多个correlationSet组成，同时支持tExtensibleElements扩展。 correlationSet在tExtensibleElements的基础上，增加了2个属性 properties name simpleType：QNames12345678&lt;xsd:simpleType name=&quot;QNames&quot;&gt; &lt;xsd:restriction&gt; &lt;xsd:simpleType&gt; &lt;xsd:list itemType=&quot;xsd:QName&quot;/&gt; &lt;/xsd:simpleType&gt; &lt;xsd:minLength value=&quot;1&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; QNames就是一个QName的list，最少1个，默认空格分割。 element：faultHandlers123456789101112&lt;xsd:element name=&quot;faultHandlers&quot; type=&quot;tFaultHandlers&quot;/&gt;&lt;xsd:complexType name=&quot;tFaultHandlers&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;catch&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;catchAll&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; faultHandlers，听名字就知道是干啥的了，同样支持tExtensibleElements扩展，由2种元素的sequence组成： catch catchAll element：catch123456789101112131415161718&lt;xsd:element name=&quot;catch&quot; type=&quot;tCatch&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This element can contain all activities including the activities compensate, compensateScope and rethrow. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt;&lt;xsd:complexType name=&quot;tCatch&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivityContainer&quot;&gt; &lt;xsd:attribute name=&quot;faultName&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;faultVariable&quot; type=&quot;BPELVariableName&quot;/&gt; &lt;xsd:attribute name=&quot;faultMessageType&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;faultElement&quot; type=&quot;xsd:QName&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; catch扩展自tActivityContainer，包含4个属性，对catch做了限定： faultName faultVariable faultMessageType faultElement element：catchAll1234567891011121314151617&lt;xsd:element name=&quot;catchAll&quot; type=&quot;tActivityContainer&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This element can contain all activities including the activities compensate, compensateScope and rethrow. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt;&lt;xsd:complexType name=&quot;tActivityContainer&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 不同于catch，catchAll没有那么多属性（我全都要），就是tActivityContainer本尊，扩展自tExtensibleElements，同时包含一个activity的sequence。]]></content>
      <tags>
        <tag>bpel</tag>
        <tag>wsbpel</tag>
        <tag>ws-bpel</tag>
        <tag>bpel2.0</tag>
        <tag>schema</tag>
        <tag>xsd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[owl本体语言学习笔记]]></title>
    <url>%2F2019%2F03%2F18%2Fowl%E6%9C%AC%E4%BD%93%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[OWL简介OWL(Web Ontology Language)是W3C开发的一种网络本体语言，用于对本体进行语义描述。OWL是针对各方面的需求在DAML+OIL的基础上进行改进而开发的，它一方面保持了对DAML+oIL／RDFs的兼容性，另一方面又保证了更加强大的语义表达能力，同时还要保证描述逻辑(DL，Description Logic)的可判定推理。W3C的设计人员针对各类特征的需求制定了三种相应的OWL的子语言，即OWL Lite、OWL DL和OWL Full，三种子语言的表达能力递增。 OWL Lite是表达能力最弱的子语言。它是傩乙DL的一个子集，但是通过降低OWL DL中的公理约束，保证了迅速高效的推理。它支持基数约束，但基数值只能为O或l。因为0WL Lite表达能力较弱，为其开发支持工具要比其他两个子语言容易一些。OWL Lite用于提供给那些仅需要一个分类层次和简单约束的用户。 OWL DL(Description Logic，描述逻辑)将可判定推理能力和较强表达能力作为首要目标，而忽略了对RDFS的兼容性。0WL DL包括了OWL语言的所有语言成分，但使用时必须符合一定的约束，受到一定的限制。OWL DL提供了描述逻辑的推理功能，描述逻辑是OWL的形式化基础。 OWL Full包含OWL的全部语言成分并取消了OWL DL中的限制，它将RDFS扩展为一个完备的本体语言，支持那些不需要可计算性保证(no computational guarantees)但需要最强表达能力和完全自由的RDFS用户。在OWL Full中，一个类可以看成是个体的集合，也可以看成是一个个体。由于OWL Full取消了基数限制中对可传递性质的约束，因此不能保证可判定推理。 OWL本体的组成个体（individual）个体代表领域中我们感兴趣的对象，OWL不使用唯一命名假设，即两个不同的名称可以对应一个个体（例如：“伊丽莎白女王”和“伊丽莎白温莎”是指同一个人）。在OWL中，必须明确表示个体之间是否相同，否则它们的关系是不明确的。 个体（individual）有时也被称作实例（Instance）。 属性（Property）属性是个体之间的二元关系。在描述逻辑中，它们就是角色（Role）的概念。 按照属性的表意及性质可以分为以下四类属性： 函数属性(Functional Property)——通过这个属性只能连接一个个体，如hasBirthMother 反函数属性(Inverse Functional Property)——即这个属性的反属性是函数属性，也就是对于一个给定的个体，只有最多一个个体能通过该属性连接那个个体，如isBirthMotherOf 传递属性(Transitive Property)——这个属性是可以传递的，如你的祖先的祖先也是你的祖先，hasAncestor 对称属性(Symmetric Property)——即这个属性是对称的，一个属性是对称的那么它就不能是函数属性。如你是你的兄弟的兄弟，hasSibling 按照属性的链接对象不同可以分为以下三类： 对象属性(Object Property)——连接两个个体。 数据类型属性(Datatype Property)——连接个体和XML Schema数据类型值或rdf literal,该属性不能为传递的，对称的，反函数的。 标注属性 (Annotation Property)——用来对类，属性，个体和本体添加信息(元数据)。OWL-DL对标注属性作出了如下限制：(1)标注属性的filler只能为,literal或URI或个体。(2)标注属性没有子属性，也不能为其它属性的子属性，而且不能使用domain和range。 类（class）表示一些个体的集合，它使用数学的方法描述出该类中成员必须具有的条件。概念（concept）这个词有时被用来代替类，实际上，类是概念的一个具体表现。 OWL中本体的结构命名空间在使用一组术语之前，需要精确地指出哪些具体的词汇表将会用到。一个典型的OWL本体以命名空间声明开始，这些命名空间写到rdf:RDF\标签中。 属性值是不具有命名空间的，在OWL里可以写出它们的完整URI。完整的URI中可以利用实体定义来简略。如： 123&lt;!DOCTYPE rdf:RDF [ &lt;!ENTITY vin &quot;http://www.w3.org/TR/2004/REC-owl-guide-20040210/wine#&quot; &gt; &lt;!ENTITY food &quot;http://www.w3.org/TR/2004/REC-owl-guide-20040210/food#&quot; &gt; ]&gt; 在声明这些实体后，我们可以将“&vin;merlot”作为http://www.w3.org/TR/2004/REC -owl-guide-20040210/wine#merlot的简写。 本体头部在owl：Ontology标签中给出本体的声明。这些标签支持一些重要的常务工作比如注释、版本控制以及其他本体的嵌入等。 owl:Ontology元素是用来收集关于当前文档的OWL元数据的。 rdf:about属性为本体提供一个名称或引用。 rdfs:comment提供了显然必须的为本体添加注解的能力。 owl:priorVersion是一个为用于本体的版本控制系统提供相关信息（hook）的标准标签。本体的版本控制将在后面作进一步讨论。 owl:imports提供了一种嵌入机制。owl:imports接受一个用rdf:resource属性标识的参数。 数据集成与隐私不同的个体成员可能表示同一个体，owl：sameAs表达等价的能力。 基本元素简单的个体和类外延：我们称由属于某个类的个体所构成的集合为该类的外延（extension）。 本体：为了进行相关个体的推理。 简单的具名类一个领域中最基本的概念对应各个分类层次树的根。 。。。。国际化资源标识符（IRI）。。。。。统一资源标识符（URI）。。。。 rdf:ID=”Region” 被用于引入一个名称（作为定义的一部分）在这一文档中，我们现在可以用#Region来引用Region类，例如 rdf:resource=”#Region” rdfs:subClassOf是用于类的基本分类构造符，次关系是可传递的一个类的定义由两部分组成：引入或引用一个名称，以及一个限制表。 个体123456&lt;owl:Thing rdf:ID=&quot;CentralCoastRegion&quot; /&gt; &lt;owl:Thing rdf:about=&quot;#CentralCoastRegion&quot;&gt; &lt;rdf:type rdf:resource=&quot;#Region&quot;/&gt; /*表示个体，type是一个rdf属性，用于关联一个个体和它所属的类*/ &lt;/owl:Thing&gt; 或者使用&lt;Region rdf:ID=&quot;CentralCoastRegion&quot; /&gt; 语句来表示个体 Web本体被设计成为分布式的，我们可以通过导入和补充已有的本体来创建衍生的本体。 使用方面的考虑一个类仅是一个名称和一些描述某集合内个体的属性；而个体是该集合的成员。因此，类应自然地对应于与某论域中的事物的出现集合，而个体应对应于可被归入这些类的实际的实体。 子类：类的子集合 实例：表示一个单一的个体 一个本体的开发应坚定地由它的预定用途所驱动。这些问题也存在于OWL Full和OWL DL之间的一个重要区别。OWL Full允许将类（class）用作实例（instance），而OWL DL不允许。 简单属性一个属性是一个二元关系，有两种类型的属性： 数据类型属性（datatype properties）：类实例与RDF文字或XML Schema数据类型间的关系。 对象属性（object properties）：两个类的实例间的关系。 定义属性1234&lt;owl:ObjectProperty rdf:ID=&quot;madeFromGrape&quot;&gt; &lt;rdfs:domain rdf:resource=&quot;#Wine&quot;/&gt; /*表示定义域*/ &lt;rdfs:range rdf:resource=&quot;#WineGrape&quot;/&gt; /*表示值域*/&lt;/owl:ObjectProperty&gt; 在OWL中，一个值域可被用来推断一个类型 123&lt;owl:Thing rdf:ID=&quot;LindemansBin65Chardonnay&quot;&gt; &lt;madeFromGrape rdf:resource=&quot;#ChardonnayGrape&quot; /&gt;&lt;/owl:Thing&gt; 可以推断出，LindemansBin65Chardonnay为一种葡萄酒，因为其定义域为wine 可以定义子属性，属性是传递的，例如X为Y的子属性，如果具有属性X，则必然同时具有属性Y。 属性和数据类型数据类型属性：将个体关联到数据（值域为：RDF文字或XML Schema数据类型） 12345&lt;owl:Class rdf:ID=&quot;VintageYear&quot; /&gt;&lt;owl:DatatypeProperty rdf:ID=&quot;yearValue&quot;&gt;&lt;rdfs:domain rdf:resource=&quot;#VintageYear&quot; /&gt; &lt;rdfs:range rdf:resource=&quot;&amp;xsd;positiveInteger&quot;/&gt;&lt;/owl:DatatypeProperty&gt; yearValue属性将VintageYears与一个整数值相关联。 个体的属性12345678&lt;Region rdf:ID=&quot;SantaCruzMountainsRegion&quot;&gt; &lt;locatedIn rdf:resource=&quot;#CaliforniaRegion&quot; /&gt;&lt;/Region&gt;&lt;Winery rdf:ID=&quot;SantaCruzMountainVineyard&quot; /&gt;&lt;CabernetSauvignon rdf:ID=&quot;SantaCruzMountainVineyardCabernetSauvignon&quot; &gt; &lt;locatedIn rdf:resource=&quot;#SantaCruzMountainsRegion&quot;/&gt; &lt;hasMaker rdf:resource=&quot;#SantaCruzMountainVineyard&quot; /&gt; &lt;/CabernetSauvignon&gt; 属性的特性 传递属性： P(x，y)，P(y，z) P(x，z) 对称属性： p(x，y)当且仅当P(y, x)【注意是同一个关系】 函数属性： P(x,y) 与P(x,z) 蕴含 y = z，即对应值的唯一性 逆属性 （inverseOf）：P1(x,y) 当且仅当P2(y,x)【注意是不同关系】 反函数属性 （InverseFunctional）：P(y,x) 与 P(z,x) 蕴含 y = z； InverseFunctional意味着属性的值域中的元素为定义域中的每个元素提供了一个唯一的标识。 属性限制两个属性限制机制 allValuesFrom someValuesFrom 它们都是是局部的（local），仅仅在包含它们的类的定义中起作用。 owl:allValuesFrom属性限制要求：对于每一个有指定属性实例的类实例，该属性的值必须是由owl:allValuesFrom从句指定的类的成员。 owl:someValuesFrom限制与之相似。 例子：Wine的制造商必须是Winery。allValuesFrom限制仅仅应用在Wine的hasMaker 属性上。Cheese的制造商并不受这一局部限制的约束。（代码如下） 关系 含意 allValuesFrom 对于所有的葡萄酒，如果它们有制造商，那么所有的制造商都是酿酒厂 someValuesFrom 对于所有的葡萄酒，它们中至少有一个的制造商是酿酒厂 基数限制owl:cardinality：这一约束允许对一个关系中的元素数目作出精确的限制。 例如，我们可以将Vintage标识为恰好含有一个VintageYear的类。 值域限制在0和1的基数表达式(Cardinality expressions)是OWL Lite的一部分。这使得用户能够表示“至少一个”，“不超过一个”，和“恰好一个”这几种意思。OWL DL中还允许使用除0与1以外的正整数值。owl:maxCardinality能够用来指定一个上界。owl:minCardinality能够用来指定一个下界。使用二者的组合就能够将一个属性的基数限制为一个数值区间。 hasValuehasValue 使得我们能够根据“特定的”属性值的存在来标识类。因此，一个个体只要至少有“一个”属性值等于hasValue的资源，这一个体就是该类的成员。 如果是Burgundy酒，那就都是干(dry)的酒。也即，它们的hasSugar属性必须至少有一个是值等于Dry（干的）。【我的理解是，每个Burgundy都要有一个干的（Dry）属性，以此来标识该酒是干酒】 本体映射用于实现本体的共享。 类和属性之间的等价关系（equivalentClass，equivalentProperty）属性owl:equivalentClass被用来表示两个类有着完全相同的实例。但我们要注意，在OWL DL中，类仅仅代表着个体的集合而不是个体本身。然而在OWL FULL中，我们能够使用owl:sameAs来表示两个类在各方面均完全一致。 类似的，我们可以通过使用owl:equivalentProperty属性声明表达属性的等同。 个体间的同一性SameAs：描述个体之间相同的机制与描述类之间的相同机制类似，仅仅只要两个个体的声明形成一致的就可以了。 假如hasMaker是一个函数型属性，那么下面的例子就不一定会产生冲突。 1234&lt;owl:Thing rdf:about=&quot;#BancroftChardonnay&quot;&gt; &lt;hasMaker rdf:resource=&quot;#Bancroft&quot; /&gt; &lt;hasMaker rdf:resource=&quot;#Beringer&quot; /&gt;&lt;/owl:Thing&gt; 除非和我们本体中的其他信息发生冲突，不然的话这样的描述是没有冲突的，他说明Bancroft和Beringer是相同的个体。 要清楚，修饰（或引用）两个类用sameAs还是用equivalentClass效果是不同的。用sameAs的时候，把一个类解释为一个个体，就像在OWL Full中一样，这有利于对本体进行分类。在OWL Full中，sameAs可以用来引用两个东西，如一个类和一个个体、一个类和一个属性等等，无论什么情况，都将被解释为个体。 不同的个体这一机制提供了与sameAs相反的效果。 说明了三个值互不相同。如果我们没有用 differentFrom元素来申明既干又甜的葡萄酒，这意味着“干葡萄酒”和“甜葡萄酒”是相同的。但是我们从上面申明的元素来推断，这又是矛盾的。还有一种更便利的定义相互不同个体的机制，如下 要注意，owl:distinctMembers属性声明只能和owl:AllDifferent属性声明一起结合使用。 复杂类用于创建类的表达式。OWL支持基本的集合操作，即并，交和补运算。它们分别被命名为owl:unionOf,owl:intersectionOf,和owl:complementOf.此外，类还可以是枚举的。类的外延可以使用oneOf构造子来显示的声明。同时，我们也可以声明类的外延必须是互不相交的。 注意：OWL类外延是由个体组成的集合，二这些个体都是类的成员。 集合运算符交运算123456789&lt;owl:Class rdf:ID=&quot;WhiteWine&quot;&gt; &lt;owl:intersectionOf rdf:parseType=&quot;Collection&quot;&gt; /*这是必须的，因为必须对集合操作*/ &lt;owl:Class rdf:about=&quot;#Wine&quot; /&gt; &lt;owl:Restriction&gt; &lt;owl:onProperty rdf:resource=&quot;#hasColor&quot; /&gt; &lt;owl:hasValue rdf:resource=&quot;#White&quot; /&gt; &lt;/owl:Restriction&gt; &lt;/owl:intersectionOf&gt;&lt;/owl:Class&gt; 这个例子表示，白葡萄酒就是葡萄酒和白色物体的相交的集合。如果不这么表示，计算机只知道，白葡萄酒有白色的属性；却不知道，所有白色的葡萄酒是白葡萄酒 WhiteBurgundy类恰好是白葡萄酒和Burgundies的交集。依次，Burgundies生产在法国一个叫做Bourgogne的地方并且它是干葡萄酒（dry wine）。因此，所有满足这些标准的葡萄酒个体都是WhiteBurgundy类的外延的一部分。 并运算表示两个集合的∪。使用方法同上，将intersectionOf改成unionOf。 补运算就是表示差集，complementOf典型的用法是与其它集合运算符联合使用，如下 上面的例子定义了一个NonFrenchWine类，它是Wine类与所有不位于法国的事物的集合的交集。 枚举类（one of）以直接枚举的方式描述类的成员。特别的，这个定义完整的描述了类的外延（类的范围？），因此任何其他个体都不能声明为属于这个类。如下： 这段代码说明，WineColor只包含三种，white rose和red，任何其他的颜色都不是winecolor类的实例 oneOf结构的每一个元素都必须是一个有效声明的个体。一个个体必须属于某个类。在上面的例子中，每一个个体都是通过名字来引用的。我们使用owl:Thing简单地进行引用，尽管这有点多余（因为每个个体都属于owl:Thing）。另外，我们也可以根据具体类型WineColor来引用集合中的元素： 另外，较复杂的个体描述同样也可以是oneOf结构的有效元素，例如: 不相交类（disjointWith）使用owl:disjointWith构造子可以表达一组类是不相交的。它保证了属于某一个类的个体不能同时又是另一个指定类的实例。 Pasta例子声明了多个不相交类。注意它只声明了Pasta与其它所有类是不相交的。例如，它并没有保证Meat和Fruit是不相交的。为了声明一组类是互不相交的，我们必须对每两个类都使用owl:disjointWith来声明。 在下面的例子中，我们定义了Fruit是SweetFruit和NonSweetFruit的并集。而且我们知道这些子类恰好将Fruit划分成了连个截然不同的子类，因为它们是互不相交的。随着互不相交的类的增加，不相交的声明的数目也会相应的增加到n的2次方。然而，在我们已知的用例中，n通常比较小。 本体版本控制本体和软件一样需要维护，因此它们将随着时间的推移而改变。在一个owl:Ontology元素（如上面讨论的http://www.w3.org/TR/2004/REC-owl-guide-20040210/#OntologyHeaders） 内，链接到一个以前定义的本体版本是可能的。属性owl:priorVersion被用来提供这种链接，并能用它跟踪一个本体的版本历史。 本体版本可能彼此互不兼容，例如，一个本体以前的版本可能包含与现在版本中的陈述相矛盾的陈述。在一个owl:Ontology元素中，我们使用owl:backwardCompatibleWith和owl:incompatibleWith这些属性来指出本体版本是兼容还是不兼容以前的版本。如果没有进行owl:backwardCompatibleWith声明，那么我们假定就不存在兼容性。除了上面讲到的两个属性，还有一个属性owl:versionInfo适用与版本控制系统，它提供了一些相关信息（hook）。和前面三个属性相反的是，owl:versionInfo的客体是一个文字值（literal），这一属性除了可以用来注释本体之外还可以用来注释类和属性。 Reference OWL本体语言中OWL Lite、OWL DL、OWL Full理解 owl本体语言学习笔记（一） owl本体语言学习笔记（二）]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>owl</tag>
        <tag>本体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSD/XML Schema 学习笔记完整版]]></title>
    <url>%2F2019%2F03%2F15%2FXSD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AE%8C%E6%95%B4%E7%89%88%2F</url>
    <content type="text"><![CDATA[注：本文摘自W3school Schema 教程 schema声明属性大全 属性 说明 取值 id 标识该元素的唯一ID attributeFormDefault 指定XML文档使用schema中定义的局部属性时是否必须使用命名空间限定 qualified:必须通过命名空间前缀限定、unqualified：（默认值）无须通过命名空间前缀限定 elementFormDefault 指定XML文档使用schema中定义的局部元素时是否必须使用命名空间限定 取值和含义同attributeFormDefault blockDefault 设定schema中element和complexType上的block属性的默认值、block属性用来阻止以指定的派生类型代替原类型 #all或者extension、restriction和substitution的自由组合、例如extension表示防止通过扩展派生的复杂类型替代该复杂类型 finalDefault 设定schema中element、simpleType和complexType上的final的默认值、final属性用来阻止以指定的派生类型来派生新类型 对于element和complexType：值可以是#all或extension和restriction的自由组合、对于simpleType：值可以是#all或restriction、list和union的自由组合 targetNamespace 设定schema的命名空间的URI引用 version 设定schema的版本 xmlns 设定schema使用的一个或多个命名空间的URI引用 any attributes 设定带有non-schema命名空间的任何其他属性 &lt;schema&gt; 声明&lt;schema&gt; 元素是每一个 XML Schema 的根元素：&lt;?xml version=”1.0”?&gt; 123456&lt;xs:schema&gt;......&lt;/xs:schema&gt; &lt;schema&gt; 元素可包含属性。一个 schema 声明往往看上去类似这样： 12345678910&lt;?xml version=&quot;1.0&quot;?&gt; &lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;targetNamespace=&quot;http://www.w3school.com.cn&quot;xmlns=&quot;http://www.w3school.com.cn&quot;elementFormDefault=&quot;qualified&quot;&gt;......&lt;/xs:schema&gt; 代码解释1xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot; 显示 schema 中用到的元素和数据类型来自命名空间 http://www.w3.org/2001/XMLSchema。 同时它还规定了来自命名空间 http://www.w3.org/2001/XMLSchema的元素和数据类型应该使用前缀 xs。 1targetNamespace=&quot;http://www.w3school.com.cn&quot; 显示被此 schema 定义的元素 (note, to, from, heading, body) 来自命名空间： http://www.w3school.com.cn。 1xmlns=&quot;http://www.w3school.com.cn&quot; 指出默认的命名空间是 http://www.w3school.com.cn。 1elementFormDefault=&quot;qualified&quot; 指出任何 XML 实例文档所使用的且在此 schema 中声明过的元素必须被命名空间限定。 在 XSD 文档中引用 其他Schema引用方式有两种： include import import与include的作用是一样的。 区别在于import是导入另外一个命名空间的xsd， 而inlude是包含同一个命名空间的xsd。 例子1&lt;xsd:include schemaLocation=&quot;module/owl1-lite-core.xsd&quot; /&gt; 12345678910&lt;xsd:import namespace=&quot;http://www.w3.org/XML/1998/namespace&quot; schemaLocation=&quot;xml.xsd&quot;&gt; &lt;!-- &quot;http://www.w3.org/2001/xml.xsd&quot; --&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt; Get access to the xml: attribute groups for xml:lang as declared on &apos;Label&apos; and &apos;Documentation&apos; below &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:import&gt; 在 XML 文档中引用 Schema此 XML 文档含有对 XML Schema 的引用： 1234567891011&lt;?xml version=&quot;1.0&quot;?&gt;&lt;note xmlns=&quot;http://www.w3school.com.cn&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://www.w3school.com.cn note.xsd&quot;&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 代码解释1xmlns=&quot;http://www.w3school.com.cn&quot; 规定了默认命名空间的声明。此声明会告知 schema 验证器，在此 XML 文档中使用的所有元素都被声明于 http://www.w3school.com.cn 这个命名空间。 一旦您拥有了可用的 XML Schema 实例命名空间： 1xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 您就可以使用 schemaLocation 属性了。此属性有两个值。第一个值是需要使用的命名空间。第二个值是供命名空间使用的 XML schema 的位置： 1xsi:schemaLocation=&quot;http://www.w3school.com.cn note.xsd&quot; 简单类型元素1&lt;xs:element name=&quot;xxx&quot; type=&quot;yyy&quot;/&gt; 常用类型： xs:string xs:decimal xs:integer xs:boolean xs:date xs:time 默认值和固定值缺省值（默认值）设置： 1&lt;xs:element name=&quot;color&quot; type=&quot;xs:string&quot; default=&quot;red&quot;/&gt; 固定值设置： 1&lt;xs:element name=&quot;color&quot; type=&quot;xs:string&quot; fixed=&quot;red&quot;/&gt; 例子这是一些 XML 元素： 123&lt;lastname&gt;Smith&lt;/lastname&gt;&lt;age&gt;28&lt;/age&gt;&lt;dateborn&gt;1980-03-27&lt;/dateborn&gt; 这是相应的简易元素定义： 123&lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;&lt;xs:element name=&quot;age&quot; type=&quot;xs:integer&quot;/&gt;&lt;xs:element name=&quot;dateborn&quot; type=&quot;xs:date&quot;/&gt; 列表语法123456789&lt;listid=ID itemType=QName any attributes&gt;(annotation?,(simpleType?))&lt;/list&gt; 属性 描述 id 可选。规定该元素的唯一的 ID。 itemType 在该 schema（或由指定的命名空间指示的其他 schema）中定义的内置数据类型或 simpleType 元素的名称。包含 list 元素的 simpleType 元素是从 list 值指定的简单类型派生的。list 值必须是限定名 (QName)。 如果内容包含 simpleType 元素，则不允许使用该属性，否则该属性是必需的。 any attributes 可选。规定带有 non-schema 命名空间的任何其他属性。 例子下面的例子展示了为一列整数的简单类型： 12345678910&lt;?xml version=&quot;1.0&quot;?&gt;&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;&lt;xs:element name=&quot;intvalues&quot; type=&quot;valuelist&quot;&gt;&lt;xs:simpleType name=&quot;valuelist&quot;&gt; &lt;xs:list itemType=&quot;xs:integer&quot;/&gt;&lt;/xs:simpleType&gt;&lt;/xs:schema&gt; 文档中的 “intvalues” 元素类似这样（注意这个列表有五个列表项）： 1&lt;intvalues&gt;100 34 56 -23 1567&lt;/intvalues&gt; 注释：空格被作为列表项的分隔符 属性1&lt;xs:attribute name=&quot;xxx&quot; type=&quot;yyy&quot;/&gt; 常用类型： xs:string xs:decimal xs:integer xs:boolean xs:date xs:time 例子这是带有属性的 XML 元素： 1&lt;lastname lang=&quot;EN&quot;&gt;Smith&lt;/lastname&gt; 这是对应的属性定义： 1&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot;/&gt; 默认值和固定值缺省值（默认值）设置： 1&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot; default=&quot;EN&quot;/&gt; 固定值设置： 1&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot; fixed=&quot;EN&quot;/&gt; 可选和必选在缺省的情况下，属性是可选的。如需规定属性为必选，请使用 “use” 属性： 1&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt; 限定/Facets对值的限定下面的例子定义了带有一个限定且名为 “age” 的元素。age 的值不能低于 0 或者高于 120： 12345678910&lt;xs:element name=&quot;age&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:integer&quot;&gt; &lt;xs:minInclusive value=&quot;0&quot;/&gt; &lt;xs:maxInclusive value=&quot;120&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对一组值的限定如需把 XML 元素的内容限制为一组可接受的值，我们要使用枚举约束（enumeration constraint）。 下面的例子定义了带有一个限定的名为 “car” 的元素。可接受的值只有：Audi, Golf, BMW： 1234567891011&lt;xs:element name=&quot;car&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:enumeration value=&quot;Audi&quot;/&gt; &lt;xs:enumeration value=&quot;Golf&quot;/&gt; &lt;xs:enumeration value=&quot;BMW&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 上面的例子也可以被写为： 123456789&lt;xs:element name=&quot;car&quot; type=&quot;carType&quot;/&gt;&lt;xs:simpleType name=&quot;carType&quot;&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:enumeration value=&quot;Audi&quot;/&gt; &lt;xs:enumeration value=&quot;Golf&quot;/&gt; &lt;xs:enumeration value=&quot;BMW&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt; 注释：在这种情况下，类型 “carType” 可被其他元素使用，因为它不是 “car” 元素的组成部分。 对一系列值的限定如需把 XML 元素的内容限制定义为一系列可使用的数字或字母，我们要使用模式约束（pattern constraint）。 下一个例子也定义了带有一个限定的名为 “initials” 的元素。可接受的值是大写或小写字母 a - z 其中的三个： 123456789&lt;xs:element name=&quot;initials&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:pattern value=&quot;[a-zA-Z][a-zA-Z][a-zA-Z]&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下一个例子定义了带有一个限定的名为 “choice 的元素。可接受的值是字母 x, y 或 z 中的一个： 123456789&lt;xs:element name=&quot;choice&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:pattern value=&quot;[xyz]&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对一系列值的其他限定下面的例子定义了带有一个限定的名为 “letter” 的元素。可接受的值是 a - z 中零个或多个字母： 123456789&lt;xs:element name=&quot;letter&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:pattern value=&quot;([a-z])*&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下面的例子定义了带有一个限定的名为 “letter” 的元素。可接受的值是一对或多对字母，每对字母由一个小写字母后跟一个大写字母组成。举个例子，”sToP”将会通过这种模式的验证，但是 “Stop”、”STOP” 或者 “stop” 无法通过验证： 123456789&lt;xs:element name=&quot;letter&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:pattern value=&quot;([a-z][A-Z])+&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下面的例子定义了带有一个限定的名为 “gender” 的元素。可接受的值是 male 或者 female： 123456789&lt;xs:element name=&quot;gender&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:pattern value=&quot;male|female&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下面的例子定义了带有一个限定的名为 “password” 的元素。可接受的值是由 8 个字符组成的一行字符，这些字符必须是大写或小写字母 a - z 亦或数字 0 - 9： 123456789&lt;xs:element name=&quot;password&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:pattern value=&quot;[a-zA-Z0-9]&#123;8&#125;&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对空白字符的限定如需规定对空白字符（whitespace characters）的处理方式，我们需要使用 whiteSpace 限定。 下面的例子定义了带有一个限定的名为 “address” 的元素。这个 whiteSpace 限定被设置为 “preserve”，这意味着 XML 处理器不会移除任何空白字符： 123456789&lt;xs:element name=&quot;address&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:whiteSpace value=&quot;preserve&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 这个例子也定义了带有一个限定的名为 “address” 的元素。这个 whiteSpace 限定被设置为 “replace”，这意味着 XML 处理器将移除所有空白字符（换行、回车、空格以及制表符）： 123456789&lt;xs:element name=&quot;address&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:whiteSpace value=&quot;replace&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 这个例子也定义了带有一个限定的名为 “address” 的元素。这个 whiteSpace 限定被设置为 “collapse”，这意味着 XML 处理器将移除所有空白字符（换行、回车、空格以及制表符会被替换为空格，开头和结尾的空格会被移除，而多个连续的空格会被缩减为一个单一的空格）： 123456789&lt;xs:element name=&quot;address&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:whiteSpace value=&quot;collapse&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对长度的限定如需限制元素中值的长度，我们需要使用 length、maxLength 以及 minLength 限定。 本例定义了带有一个限定且名为 “password” 的元素。其值必须精确到 8 个字符： 123456789&lt;xs:element name=&quot;password&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:length value=&quot;8&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 这个例子也定义了带有一个限定的名为 “password” 的元素。其值最小为 5 个字符，最大为 8 个字符： 12345678910&lt;xs:element name=&quot;password&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:minLength value=&quot;5&quot;/&gt; &lt;xs:maxLength value=&quot;8&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 数据类型的限定 限定 描述 enumeration 定义可接受值的一个列表 fractionDigits 定义所允许的最大的小数位数。必须大于等于0。 length 定义所允许的字符或者列表项目的精确数目。必须大于或等于0。 maxExclusive 定义数值的上限。所允许的值必须小于此值。 maxInclusive 定义数值的上限。所允许的值必须小于或等于此值。 maxLength 定义所允许的字符或者列表项目的最大数目。必须大于或等于0。 minExclusive 定义数值的下限。所允许的值必需大于此值。 minInclusive 定义数值的下限。所允许的值必需大于或等于此值。 minLength 定义所允许的字符或者列表项目的最小数目。必须大于或等于0。 pattern 定义可接受的字符的精确序列。 totalDigits 定义所允许的阿拉伯数字的精确位数。必须大于0。 whiteSpace 定义空白字符（换行、回车、空格以及制表符）的处理方式。 复杂类型元素四种类型的复合元素： 空元素 包含其他元素的元素 仅包含文本的元素 包含元素和文本的元素 注释：上述元素均可包含属性！ 例子1234&lt;employee&gt;&lt;firstname&gt;John&lt;/firstname&gt;&lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/employee&gt; 的XML Schema可以写成： 12345678&lt;xs:element name=&quot;employee&quot;&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 或者： 12345678&lt;xs:element name=&quot;employee&quot; type=&quot;personinfo&quot;/&gt;&lt;xs:complexType name=&quot;personinfo&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt;&lt;/xs:complexType&gt; 也可以在已有的复合元素之上以某个复合元素为基础，然后添加一些元素，就像这样： 1234567891011121314151617181920&lt;xs:element name=&quot;employee&quot; type=&quot;fullpersoninfo&quot;/&gt;&lt;xs:complexType name=&quot;personinfo&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt;&lt;/xs:complexType&gt;&lt;xs:complexType name=&quot;fullpersoninfo&quot;&gt; &lt;xs:complexContent&gt; &lt;xs:extension base=&quot;personinfo&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;address&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;city&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;country&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt;&lt;/xs:complexType&gt; 空元素一个空的 XML 元素： 1&lt;product prodid=&quot;1345&quot; /&gt; 上面的 “product” 元素根本没有内容。为了定义无内容的类型，我们就必须声明一个在其内容中只能包含元素的类型，但是实际上我们并不会声明任何元素，比如这样： 123456789&lt;xs:element name=&quot;product&quot;&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:restriction base=&quot;xs:integer&quot;&gt; &lt;xs:attribute name=&quot;prodid&quot; type=&quot;xs:positiveInteger&quot;/&gt; &lt;/xs:restriction&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 或者： 12345&lt;xs:element name=&quot;product&quot;&gt; &lt;xs:complexType&gt; &lt;xs:attribute name=&quot;prodid&quot; type=&quot;xs:positiveInteger&quot;/&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; or： 12345&lt;xs:element name=&quot;product&quot; type=&quot;prodtype&quot;/&gt;&lt;xs:complexType name=&quot;prodtype&quot;&gt; &lt;xs:attribute name=&quot;prodid&quot; type=&quot;xs:positiveInteger&quot;/&gt;&lt;/xs:complexType&gt; 仅含元素XML 元素，”person”，仅包含其他的元素： 1234&lt;person&gt;&lt;firstname&gt;John&lt;/firstname&gt;&lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt; 可在 schema 中这样定义 “person” 元素： 12345678&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 或者： 12345678&lt;xs:element name=&quot;person&quot; type=&quot;persontype&quot;/&gt;&lt;xs:complexType name=&quot;persontype&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt;&lt;/xs:complexType&gt; 仅含文本此类型仅包含简易的内容（文本和属性），因此我们要向此内容添加 simpleContent 元素。当使用简易内容时，我们就必须在 simpleContent 元素内定义扩展或限定，就像这样： 12345678910&lt;xs:element name=&quot;某个名称&quot;&gt; &lt;xs:complexType&gt; &lt;xs:simpleContent&gt; &lt;xs:extension base=&quot;basetype&quot;&gt; .... .... &lt;/xs:extension&gt; &lt;/xs:simpleContent&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 或者： 12345678910&lt;xs:element name=&quot;某个名称&quot;&gt; &lt;xs:complexType&gt; &lt;xs:simpleContent&gt; &lt;xs:restriction base=&quot;basetype&quot;&gt; .... .... &lt;/xs:restriction&gt; &lt;/xs:simpleContent&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 例子1&lt;shoesize country=&quot;france&quot;&gt;35&lt;/shoesize&gt; 下面这个例子声明了一个复合类型，其内容被定义为整数值，并且 “shoesize” 元素含有名为 “country” 的属性： 123456789&lt;xs:element name=&quot;shoesize&quot;&gt; &lt;xs:complexType&gt; &lt;xs:simpleContent&gt; &lt;xs:extension base=&quot;xs:integer&quot;&gt; &lt;xs:attribute name=&quot;country&quot; type=&quot;xs:string&quot; /&gt; &lt;/xs:extension&gt; &lt;/xs:simpleContent&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 我们也可为 complexType 元素设定一个名称，并让 “shoesize” 元素的 type 属性来引用此名称（通过使用此方法，若干元素均可引用相同的复合类型）： 123456789&lt;xs:element name=&quot;shoesize&quot; type=&quot;shoetype&quot;/&gt;&lt;xs:complexType name=&quot;shoetype&quot;&gt; &lt;xs:simpleContent&gt; &lt;xs:extension base=&quot;xs:integer&quot;&gt; &lt;xs:attribute name=&quot;country&quot; type=&quot;xs:string&quot; /&gt; &lt;/xs:extension&gt; &lt;/xs:simpleContent&gt;&lt;/xs:complexType&gt; 混合内容带有混合内容的复合类型XML 元素，”letter”，含有文本以及其他元素： 12345&lt;letter&gt;Dear Mr.&lt;name&gt;John Smith&lt;/name&gt;.Your order &lt;orderid&gt;1032&lt;/orderid&gt;will be shipped on &lt;shipdate&gt;2001-07-13&lt;/shipdate&gt;.&lt;/letter&gt; 下面这个 schema 声明了这个 “letter” 元素： 123456789&lt;xs:element name=&quot;letter&quot;&gt; &lt;xs:complexType mixed=&quot;true&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;orderid&quot; type=&quot;xs:positiveInteger&quot;/&gt; &lt;xs:element name=&quot;shipdate&quot; type=&quot;xs:date&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 注释：为了使字符数据可以出现在 “letter” 的子元素之间，mixed 属性必须被设置为 “true”。xs:sequence\ 标签 (name、orderid 以及 shipdate ) 意味着被定义的元素必须依次出现在 “letter” 元素内部。 或者： 123456789&lt;xs:element name=&quot;letter&quot; type=&quot;lettertype&quot;/&gt;&lt;xs:complexType name=&quot;lettertype&quot; mixed=&quot;true&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;orderid&quot; type=&quot;xs:positiveInteger&quot;/&gt; &lt;xs:element name=&quot;shipdate&quot; type=&quot;xs:date&quot;/&gt; &lt;/xs:sequence&gt;&lt;/xs:complexType&gt; 指示器七种指示器： Order 指示器： All Choice Sequence Occurrence 指示器： maxOccurs minOccurs Group 指示器： Group name attributeGroup name ALL&lt;all&gt; 指示器规定子元素可以按照任意顺序出现，且每个子元素必须只出现一次. 当使用 &lt;all&gt; 指示器时，你可以把 &lt;minOccurs&gt; 设置为 0 或者 1，而只能把 &lt;maxOccurs&gt; 指示器设置为 1 12345678&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:all&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:all&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; Choice&lt;choice&gt; 指示器规定可出现某个子元素或者可出现另外一个子元素（非此即彼）,如需设置子元素出现任意次数，可将 &lt;maxOccurs&gt; 设置为 unbounded（无限次）： 12345678&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:choice&gt; &lt;xs:element name=&quot;employee&quot; type=&quot;employee&quot;/&gt; &lt;xs:element name=&quot;member&quot; type=&quot;member&quot;/&gt; &lt;/xs:choice&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; Sequence&lt;sequence&gt; 规定子元素必须按照特定的顺序出现： 12345678&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; maxOccursOccurrence 指示器用于定义某个元素出现的频率。对于所有的 “Order” 和 “Group” 指示器（any、all、choice、sequence、group name 以及 group reference），其中的 maxOccurs 以及 minOccurs 的默认值均为 1。 &lt;maxOccurs&gt;指示器可规定某个元素可出现的最大次数,如需使某个元素的出现次数不受限制，可以使用 maxOccurs=”unbounded” 这个声明： 12345678&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;full_name&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;child_name&quot; type=&quot;xs:string&quot; maxOccurs=&quot;10&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; minOccurs&lt;minOccurs&gt;指示器可规定某个元素能够出现的最小次数： 123456789&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;full_name&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;child_name&quot; type=&quot;xs:string&quot; maxOccurs=&quot;10&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; Group name元素组通过 group 声明进行定义： 123&lt;xs:group name=&quot;组名称&quot;&gt; ...&lt;/xs:group&gt; 您必须在 group 声明内部定义一个 all、choice 或者 sequence 元素。下面这个例子定义了名为 “persongroup” 的 group，它定义了必须按照精确的顺序出现的一组元素： 1234567&lt;xs:group name=&quot;persongroup&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;birthday&quot; type=&quot;xs:date&quot;/&gt; &lt;/xs:sequence&gt;&lt;/xs:group&gt; 在您把 group 定义完毕以后，就可以在另一个定义中引用它了： 12345678910111213141516&lt;xs:group name=&quot;persongroup&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;birthday&quot; type=&quot;xs:date&quot;/&gt; &lt;/xs:sequence&gt;&lt;/xs:group&gt;&lt;xs:element name=&quot;person&quot; type=&quot;personinfo&quot;/&gt;&lt;xs:complexType name=&quot;personinfo&quot;&gt; &lt;xs:sequence&gt; &lt;xs:group ref=&quot;persongroup&quot;/&gt; &lt;xs:element name=&quot;country&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt;&lt;/xs:complexType&gt; attributeGroup name属性组通过 attributeGroup 声明来进行定义： 123&lt;xs:attributeGroup name=&quot;组名称&quot;&gt; ...&lt;/xs:attributeGroup&gt; 下面这个例子定义了名为 “personattrgroup” 的一个属性组： 12345&lt;xs:attributeGroup name=&quot;personattrgroup&quot;&gt; &lt;xs:attribute name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:attribute name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:attribute name=&quot;birthday&quot; type=&quot;xs:date&quot;/&gt;&lt;/xs:attributeGroup&gt; 在您已定义完毕属性组之后，就可以在另一个定义中引用它了，就像这样： 1234567891011&lt;xs:attributeGroup name=&quot;personattrgroup&quot;&gt; &lt;xs:attribute name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:attribute name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:attribute name=&quot;birthday&quot; type=&quot;xs:date&quot;/&gt;&lt;/xs:attributeGroup&gt;&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:attributeGroup ref=&quot;personattrgroup&quot;/&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; &lt;any&gt;&lt;any&gt; 元素使我们有能力通过未被 schema 规定的元素来拓展 XML 文档！下面这个例子是从名为 “family.xsd” 的 XML schema 中引用的片段。它展示了一个针对 “person” 元素的声明。通过使用 &lt;any&gt; 元素，我们可以通过任何元素（在 &lt;lastname&gt; 之后）扩展 “person” 的内容： 123456789&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:any minOccurs=&quot;0&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 相关属性 id:可选。规定该元素的唯一的 ID。 namespace:可选。规定包含可以使用的元素的命名空间。如果没有指定命名空间，则 ##any 为默认值。如果指定命名空间，则必须是以下值之一。 any - 来自任何命名空间的元素都可以出现（默认）。 other - 来自该元素的父元素的目标命名空间之外的任何命名空间的元素都可以出现。 local - 未由命名空间限定的元素可以出现。 targetNamespace - 来自包含该元素的父元素的目标命名空间的元素可以出现。 {URI references of namespaces, ##targetNamespace, ##local} 的列表 - 来自通过空格分隔的命名空间列表的元素可以出现。 该列表可以包含以下内容： 命名空间 ##targetNamespace 和 ##local 的 URI 引用。 processContents:可选。一个指示符，指示应用程序或 XML 处理器应如何根据由该 any 元素指定的元素处理 XML 文档的验证。 如果没有指定 processContents 属性，则默认为 strict。 如果指定了 processContents，必须是以下值之一。 strict - XML 处理器必须获得所需命名空间的架构，并且必须验证来自这些命名空间的所有元素。（默认） lax - 与 strict 相同；但是，即使不能获取该架构，也不会发生任何错误。 skip - XML 处理器不尝试验证来自指定命名空间的所有元素。 any attributes:可选。规定带有 non-schema 命名空间的任何其他属性。 &lt;anyAttribute&gt;&lt;anyAttribute&gt; 元素使我们有能力通过未被 schema 规定的属性来扩展 XML 文档！下面的例子是来自名为 “family.xsd” 的 XML schema 的一个片段。它为我们展示了针对 “person” 元素的一个声明。通过使用 &lt;anyAttribute&gt; 元素，我们就可以向 “person” 元素添加任意数量的属性： 123456789&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt; &lt;xs:anyAttribute/&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 元素替换让我们举例说明：我们的用户来自英国和挪威。我们希望有能力让用户选择在 XML 文档中使用挪威语的元素名称还是英语的元素名称。为了解决这个问题，我们可以在 XML schema 中定义一个 substitutionGroup。首先，我们声明主元素，然后我们会声明次元素，这些次元素可声明它们能够替换主元素。 1234567891011&lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt;&lt;xs:element name=&quot;navn&quot; substitutionGroup=&quot;name&quot;/&gt;&lt;xs:complexType name=&quot;custinfo&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element ref=&quot;name&quot;/&gt; &lt;/xs:sequence&gt;&lt;/xs:complexType&gt;&lt;xs:element name=&quot;customer&quot; type=&quot;custinfo&quot;/&gt;&lt;xs:element name=&quot;kunde&quot; substitutionGroup=&quot;customer&quot;/&gt; 有效的 XML 文档类似这样（根据上面的 schema）： 123&lt;customer&gt; &lt;name&gt;John Smith&lt;/name&gt;&lt;/customer&gt; 或类似这样： 123&lt;kunde&gt; &lt;navn&gt;John Smith&lt;/navn&gt;&lt;/kunde&gt; 如果需要阻止元素替换，可使用 block 属性： 1&lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot; block=&quot;substitution&quot;/&gt; 请注意，substitutionGroup 中的所有元素（主元素和可替换元素）必须被声明为全局元素，否则就无法工作！ 全局元素指 “schema” 元素的直接子元素！本地元素（Local elements）指嵌套在其他元素中的元素。 数据类型字符串字符串数据类型（String Data Type）字符串数据类型可包含字符、换行、回车以及制表符。如果您使用字符串数据类型，XML 处理器就不会更改其中的值。 1&lt;xs:element name=&quot;customer&quot; type=&quot;xs:string&quot;/&gt; 规格化字符串数据类型（NormalizedString Data Type）规格化字符串数据类型同样可包含字符，但是 XML 处理器会移除折行，回车以及制表符。 下面是一个关于在某个 schema 中规格化字符串数据类型的例子： 1&lt;xs:element name=&quot;customer&quot; type=&quot;xs:normalizedString&quot;/&gt; 文档中的元素看上去应该类似这样： 1&lt;customer&gt;John Smith&lt;/customer&gt; 或者类似这样： 1&lt;customer&gt; John Smith &lt;/customer&gt; 注释：在上面的例子中，XML 处理器会使用空格替换所有的制表符。 Token 数据类型（Token Data Type）Token 数据类型同样可包含字符，但是 XML 处理器会移除换行符、回车、制表符、开头和结尾的空格以及（连续的）空格。 下面是在 schema 中一个有关 token 声明的例子： 1&lt;xs:element name=&quot;customer&quot; type=&quot;xs:token&quot;/&gt; 文档中的元素看上去应该类似这样： 1&lt;customer&gt;John Smith&lt;/customer&gt; 或者类似这样： 1&lt;customer&gt; John Smith &lt;/customer&gt; 注释：在上面这个例子中，XML 解析器会移除制表符。 字符串数据类型 名称 描述 ENTITIES ENTITY ID 在 XML 中提交 ID 属性的字符串 (仅与 schema 属性一同使用) IDREF 在 XML 中提交 IDREF 属性的字符串(仅与 schema 属性一同使用) IDREFS language 包含合法的语言 id 的字符串 Name 包含合法 XML 名称的字符串 NCName `NCName ::= (Letter NMTOKEN 在 XML 中提交 NMTOKEN 属性的字符串 (仅与 schema 属性一同使用) NMTOKENS normalizedString 不包含换行符、回车或制表符的字符串 QName QName ::= (Prefix &#39;:&#39;)? LocalPartPrefix ::= NCNameLocalPart ::= NCName string 字符串 token 不包含换行符、回车或制表符、开头或结尾空格或者多个连续空格的字符串 对字符串数据类型的限定（Restriction）可与字符串数据类型一同使用的限定： enumeration length maxLength minLength pattern (NMTOKENS、IDREFS 以及 ENTITIES 无法使用此约束) whiteSpace 日期日期数据类型（Date Data Type）日期使用此格式进行定义：”YYYY-MM-DD” 下面是一个有关 schema 中日期声明的例子： 1&lt;xs:element name=&quot;start&quot; type=&quot;xs:date&quot;/&gt; 文档中的元素看上去应该类似这样： 1&lt;start&gt;2002-09-24&lt;/start&gt; 如需规定一个时区，您也可以通过在日期后加一个 “Z” 的方式，使用世界调整时间（UTC time）来输入一个日期 - 比如这样： 1&lt;start&gt;2002-09-24Z&lt;/start&gt; 或者也可以通过在日期后添加一个正的或负时间的方法，来规定以世界调整时间为准的偏移量 - 比如这样： 1&lt;start&gt;2002-09-24-06:00&lt;/start&gt; 或者： 1&lt;start&gt;2002-09-24+06:00&lt;/start&gt; 时间数据类型（Time Data Type）时间使用下面的格式来定义：”hh:mm:ss” 下面是一个有关 schema 中时间声明的例子： 1&lt;xs:element name=&quot;start&quot; type=&quot;xs:time&quot;/&gt; 时区同上 日期时间数据类型（DateTime Data Type）日期时间使用下面的格式进行定义：”YYYY-MM-DDThh:mm:ss” 下面是一个有关 schema 中日期时间声明的例子： 1&lt;xs:element name=&quot;startdate&quot; type=&quot;xs:dateTime&quot;/&gt; 1&lt;startdate&gt;2002-05-30T09:00:00&lt;/startdate&gt; 时区同上 持续时间数据类型（Duration Data Type）时间间隔使用下面的格式来规定：”PnYnMnDTnHnMnS”，其中： P 表示周期(必需) nY 表示年数 nM 表示月数 nD 表示天数 T 表示时间部分的起始 （如果您打算规定小时、分钟和秒，则此选项为必需） nH 表示小时数 nM 表示分钟数 nS 表示秒数 如需规定一个负的持续时间，请在 P 之前输入减号： 1&lt;period&gt;-P10D&lt;/period&gt; 日期和时间数据类型 名称 描述 date 定义一个日期值 dateTime 定义一个日期和时间值 duration 定义一个时间间隔 gDay 定义日期的一个部分 - 天 (DD) gMonth 定义日期的一个部分 - 月 (MM) gMonthDay 定义日期的一个部分 - 月和天 (MM-DD) gYear 定义日期的一个部分 - 年 (YYYY) gYearMonth 定义日期的一个部分 - 年和月 (YYYY-MM) time 定义一个时间值 对日期数据类型的限定（Restriction）可与日期数据类型一同使用的限定： enumeration maxExclusive maxInclusive minExclusive minInclusive pattern whiteSpace 数值十进制数据类型1&lt;xs:element name=&quot;prize&quot; type=&quot;xs:decimal&quot;/&gt; 您可规定的十进制数字的最大位数是 18 位。 整数数据类型1&lt;xs:element name=&quot;prize&quot; type=&quot;xs:integer&quot;/&gt; 数值数据类型 名字 秒数 byte 有正负的 8 位整数 decimal 十进制数 int 有正负的 32 位整数 integer 整数值 long 有正负的 64 位整数 negativeInteger 仅包含负值的整数 ( .., -2, -1.) nonNegativeInteger 仅包含非负值的整数 (0, 1, 2, ..) nonPositiveInteger 仅包含非正值的整数 (.., -2, -1, 0) positiveInteger 仅包含正值的整数 (1, 2, ..) short 有正负的 16 位整数 unsignedLong 无正负的 64 位整数 unsignedInt 无正负的 32 位整数 unsignedShort 无正负的 16 位整数 unsignedByte 无正负的 8 位整数 对数值数据类型的限定（Restriction）可与数值数据类型一同使用的限定： enumeration fractionDigits maxExclusive maxInclusive minExclusive minInclusive pattern totalDigits whiteSpace 杂项其他杂项数据类型包括逻辑、base64Binary、十六进制、浮点、双精度、anyURI、anyURI 以及 NOTATION。 逻辑数据类型（Boolean Data Type）逻辑数据性用于规定 true 或 false 值。 1&lt;xs:attribute name=&quot;disabled&quot; type=&quot;xs:boolean&quot;/&gt; 合法的布尔值是 true、false、1（表示 true） 以及 0（表示 false）。 二进制数据类型（Binary Data Types）二进制数据类型用于表达二进制形式的数据。 我们可使用两种二进制数据类型： base64Binary (Base64 编码的二进制数据) hexBinary (十六进制编码的二进制数据) 下面是一个关于某个 scheme 中 hexBinary 声明的例子： 1&lt;xs:element name=&quot;blobsrc&quot; type=&quot;xs:hexBinary&quot;/&gt; AnyURI 数据类型（AnyURI Data Type）anyURI 数据类型用于规定 URI。 下面是一个关于某个 scheme 中 anyURI 声明的例子： 1&lt;xs:attribute name=&quot;src&quot; type=&quot;xs:anyURI&quot;/&gt; 文档中的元素看上去应该类似这样： 1&lt;pic src=&quot;http://www.w3school.com.cn/images/smiley.gif&quot; /&gt; 注释：假如某个 URI 含有空格，请用 %20 替换它们。 杂项数据类型（Miscellaneous Data Types） anyURI base64Binary boolean double float hexBinary NOTATION QName 对杂项数据类型的限定（Restriction）可与杂项数据类型一同使用的限定： enumeration (布尔数据类型无法使用此约束*) length (布尔数据类型无法使用此约束) maxLength (布尔数据类型无法使用此约束) minLength (布尔数据类型无法使用此约束) pattern whiteSpace]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>XSD</tag>
        <tag>XML Schema</tag>
        <tag>XML</tag>
        <tag>Schema</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[商业模式新生代读书笔记三]]></title>
    <url>%2F2019%2F03%2F12%2F%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E6%96%B0%E7%94%9F%E4%BB%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[设计 商业人士不仅需要更好的了解设计，他们更需要把自己变成设计师。 ————Roger Martin 客户洞察 创意构思 可视思考 原型创作 故事讲述 情景推测 客户洞察移情图 创意构思4类不同集中点的商业模式创新： 资源驱动 产品/服务驱动 客户驱动 财务驱动 多中心驱动（未纳入四大类之中，是上述四种的混合，更多的表现为业务的重构） 创意构思过程 团队构成：团队是否有足够的多样性，来创造新的商业模式构想 全情投入/头脑风暴：在创新之前，需要研究哪些要素 扩展：针对每个构造块，能够想到哪些创新 条件筛选：什么事商业模式创新的最重要准则 原型创作：每个入围创意的完整商业模式应该是什么样子 头脑风暴的规则 保持聚焦：从问题的精确表述开始，不能跑题太远 执行规则：暂缓判决/一次一议/争取数量/视觉化/鼓励疯狂创意 可视思考：把创意写下来，在每个人都能看得到的平面上描绘出来 做好准备：头脑风暴前要有充分的了解与思考 可视思考将模式描绘出来，这个模式就转换成一个持久的事物，也是一个可以随时返回讨论的概念原点。 视觉化的故事讲述活动 原型制作原型制作可以让概念变得更加形象具体，并能促进新创意的探索。 设计理念 如果过快地专注于一个创意，你就会迷上它。如果急于精雕细琢某个创意，你就会变得依附于它，很难保持不断的探索、不断寻找更好的创意。对于那些不成熟的早期模型尤其需要审慎小心。 Jin Glymph，盖里公司合伙人 具体步骤 故事讲述为什么要讲故事 让新创意不再抽象 让商业模式不再抽象 公司视角 客户视角 让未来变得不再抽象 激发创意 证明变革 要讲的清晰易懂 调动员工的积极性 技巧技巧有很多，要充分了解谁是你的听众，你会出席什么场合，再来选择一种匹配的技巧。 情景推测两种情景推测： 描述不同的客户背景：客户事如何使用产品和服务的，什么类型的客户在使用它们，客户的顾虑、愿望和目的分别是什么 描述新商业模式可能会参与竞争的未来场景：这里的目的不是要去预测未来，而是要具体形象地草绘出未来的各种可能情况。 未来的情景推测和新型商业模式]]></content>
      <tags>
        <tag>商业模式</tag>
        <tag>商业</tag>
        <tag>模式</tag>
        <tag>读书笔记</tag>
        <tag>商业模式设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[商业模式新生代读书笔记二]]></title>
    <url>%2F2019%2F03%2F11%2F%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E6%96%B0%E7%94%9F%E4%BB%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[商业模式式样 建筑中的式样就是将原型和原形的再现抽象为建筑设计的概念 ——Christopher Alexander 商业模式式样 非绑定式商业模式 长尾式商业模式 多边平台式商业模式 免费式商业模式 开放式商业模式 非绑定式商业模式三种基础业务： 客户关系型业务 产品创新型业务 基础设施型业务 长尾式商业模式核心：多样少量 式样 多边平台式商业模式多边平台将两个或者更多有明显区别但有互相依赖的客户群体集合在一起。 式样 免费式商业模式 至少有一个庞大的用户细分群体可以享受持续的免费服务 免费服务可以来自多种模式 通过该商业模式的其他部分或其他客户细分群体，给分服务用户细分群体提供财务支持。 免费广告：多边平台的式样 免费式样 诱钓式样 开放式商业模式开放式商业模式可以用哪些通过与外部伙伴系统合作，来创造和捕捉价值的企业。 由外到内：将外部创意引入到公司内部 由内到外：将企业内部闲置的创意和资产提供给外部伙伴 由外到内的式样 由内到外的式样 总览]]></content>
      <tags>
        <tag>商业模式</tag>
        <tag>商业</tag>
        <tag>模式</tag>
        <tag>读书笔记</tag>
        <tag>商业模式式样</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[商业模式新生代读书笔记一]]></title>
    <url>%2F2019%2F03%2F06%2F%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E6%96%B0%E7%94%9F%E4%BB%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[商业模式画布 商业模式定义：商业模式描述了企业如何创造价值，传递价值和获取价值的基本原理 苹果iPod/iTunes商业模式案例 9个构造块详细说明 CS：客户细分 customer segments VP：价值主张 value propositions CH：渠道通路 channel CR：客户关系 customer relationships R$: 收入来源 revenue streams KR：核心资源 key resources KA：关键业务 key activities KP：重要合作 key partnerships C$：成本结构 cost structure 这9个商业模式构造块组成了构建商业模式边界工具的基础，这个工具我们称之为商业模式画布（Business Model Canvas） 客户细分划分依据： 满足需求的产品服务 分销渠道 类型关系 盈利能力 客户的提供物 价值主张例子：新颖、性能、定制化、成分削减、风险抑制、可达性等 渠道通路 客户关系客户关系被以下几个动机所驱动： 客户获取 客户维系 提升销售额（追加销售） 例子：个人助理、自助服务、社区、共同创作等 收入来源一个商业模式可以包含两种不同类型的收入来源： 通过客户一次性支付获得的交易收入 经常性收入来自客户为获得价值主张与售后服务而持续支付的费用 获取收入的方式：资产销售、使用收费、订阅收费、租赁收费、授权收费等 核心资源核心资源用来描绘让商业模式有效运转所必须的最重要因素 核心资源分类： 实体资产 知识资产 人力资源 金融资源 关键业务关键业务分类： 制造产品 问题解决 平台/网络 重要合作合作关系可以分为以下四类： 在非竞争者之间的战略联盟关系 竟合：在竞争者之间的战略合作关系 为开发新业务而构建的合资关系 为确保可靠供应的购买方——供应商关系 以下三种动机有助于创建合作关系： 商业模式的优化和规模经济的运用 风险和不确定性的降低 特定资源和业务的获取 成本结构两种商业模式成本结构类型： 成本驱动 价值驱动 成本结构有以下特点： 固定成本 可变成本 规模经济 范围经济]]></content>
      <tags>
        <tag>商业模式</tag>
        <tag>商业</tag>
        <tag>模式</tag>
        <tag>读书笔记</tag>
        <tag>商业画布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浙大邮箱第三方登录设置方法]]></title>
    <url>%2F2019%2F03%2F05%2F%E6%B5%99%E5%A4%A7%E9%82%AE%E7%AE%B1%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[第三方邮箱客户端（outlook、foxmail、各种手机自带邮箱APP等）可以选择IMAP或者POP3两种协议中的任意一种进行设置，设置方法如下： 客户端使用IMAP协议设置方法：接收邮件服务器：imap.zju.edu.cn 端口：143 使用SSL端口：993 发送邮件服务器：smtp.zju.edu.cn 端口：25 使用SSL端口：994 客户端使用POP3协议设置方法：接收邮件服务器：pop3.zju.edu.cn 端口：110 使用SSL端口：995 发送邮件服务器：smtp.zju.edu.cn 端口：25 使用SSL端口：994 note: 如果一种不行就试一下另一种，再不行重启试试怎么都不行的时候可能是网络问题，本人的mac用实验室的wifi可以上网却连不上邮箱，但是手机热点就可以]]></content>
      <tags>
        <tag>浙大邮箱</tag>
        <tag>第三方登录</tag>
        <tag>设置方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac显示隐藏文件/文件夹快捷键]]></title>
    <url>%2F2019%2F01%2F13%2Fmac%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Finder（访达）在最前端的时候，三个键一起按下即可 Shift + Command + . 注意：最后一个是点不是逗号]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[latex:统一图表caption格式]]></title>
    <url>%2F2018%2F12%2F27%2Flatex-%E7%BB%9F%E4%B8%80caption%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[方法通过caption包中的captionsetup来进行格式的统一设定 栗子12345678\usepackage&#123;caption&#125;\captionsetup&#123; labelsep = quad, justification = raggedright, font = &#123;singlespacing,sf&#125;, singlelinecheck=off, skip=4pt, position=top&#125; Captionsetup中具体字段含义及修改方法见：https://blog.csdn.net/stereohomology/article/details/37741591]]></content>
      <tags>
        <tag>latex</tag>
        <tag>caption</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[latex:使用longtable实现表格跨页]]></title>
    <url>%2F2018%2F12%2F27%2Flatex-%E4%BD%BF%E7%94%A8longtable%E5%AE%9E%E7%8E%B0%E8%A1%A8%E6%A0%BC%E8%B7%A8%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[方法使用包\usepackage{longtable}，然后使用\begin{longtable}...\end{longtable}代替tabular即可 注意不能在一个表格上同时使用table和longtable，比如\begin{table}\begin{longtable}...\end{longtable}\end{table}，这会使longtable无法分页。 栗子123456789101112131415161718192021222324252627282930313233343536373839\begin&#123;center&#125; \begin&#123;longtable&#125;&#123;p&#123;2.4cm&#125;p&#123;5.4cm&#125;p&#123;3.6cm&#125;&#125; \caption&#123;服务模式的语义解释和案例&#125;\\ \label&#123;revenuepatternexplain&#125;\\ \hline\noalign&#123;\smallskip&#125; 名称 &amp; 语义解释 &amp; 案例说明 \\ \hline 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ \hline \end&#123;longtable&#125;\end&#123;center&#125;]]></content>
      <tags>
        <tag>latex</tag>
        <tag>long table</tag>
        <tag>表格跨页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[latex:修改bst使bib引文按照引用顺序排序]]></title>
    <url>%2F2018%2F12%2F27%2Flatex-%E4%BF%AE%E6%94%B9bst%E4%BD%BFbib%E5%BC%95%E6%96%87%E6%8C%89%E7%85%A7%E5%BC%95%E7%94%A8%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[问题使用spring的spbasic.bst模板，结果引文是按照作者名字的字母顺序排序的。 方法 使用任意一款文本编辑器打开spbasic.bst文件 找到其中所有的SORT行 修改为%SORT即可 注意大小写，spbasic.bst中应有两处 如果未生效，可能是bst编译的文件没有更新，试着把bbl文件删除，然后重新编译一下 解释 bst文件什么也不写的话默认是按照引用顺序来排序的 很多模板中有一部分关于排序的函数，使其按照作者名字字母顺序排序 SORT行的作用就是调用这些方法，注释掉之后就变成了默认排序方法]]></content>
      <tags>
        <tag>latex</tag>
        <tag>bib</tag>
        <tag>bst</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML Schema (XSD) 入门]]></title>
    <url>%2F2018%2F11%2F29%2FXMLSchema%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[这是一篇W3school Schema 教程学习笔记。 概要XML Schema 是基于 XML 的 DTD 替代者。XML Schema 描述 XML 文档的结构。XML Schema 语言也称作 XML Schema 定义（XML Schema Definition，XSD）。 简单类型定义简易元素的语法：1&lt;xs:element name="xxx" type="yyy"/&gt; 定义简易属性的语法：1&lt;xs:attribute name="xxx" type="yyy"/&gt; 数据类型的限定 限定 描述 enumeration 定义可接受值的一个列表 fractionDigits 定义所允许的最大的小数位数。必须大于等于0。 length 定义所允许的字符或者列表项目的精确数目。必须大于或等于0。 maxExclusive 定义数值的上限。所允许的值必须小于此值。 maxInclusive 定义数值的上限。所允许的值必须小于或等于此值。 maxLength 定义所允许的字符或者列表项目的最大数目。必须大于或等于0。 minExclusive 定义数值的下限。所允许的值必需大于此值。 minInclusive 定义数值的下限。所允许的值必需大于或等于此值。 minLength 定义所允许的字符或者列表项目的最小数目。必须大于或等于0。 pattern 定义可接受的字符的精确序列。 totalDigits 定义所允许的阿拉伯数字的精确位数。必须大于0。 whiteSpace 定义空白字符（换行、回车、空格以及制表符）的处理方式。 限定的例子对值的限定下面的例子定义了带有一个限定且名为 “age” 的元素。age 的值不能低于 0 或者高于 120： 12345678910&lt;xs:element name="age"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:integer"&gt; &lt;xs:minInclusive value="0"/&gt; &lt;xs:maxInclusive value="120"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对一组值的限定如需把 XML 元素的内容限制为一组可接受的值，我们要使用枚举约束（enumeration constraint）。下面的例子定义了带有一个限定的名为 “car” 的元素。可接受的值只有：Audi, Golf, BMW： 1234567891011&lt;xs:element name="car"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:enumeration value="Audi"/&gt; &lt;xs:enumeration value="Golf"/&gt; &lt;xs:enumeration value="BMW"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对一系列值的限定如需把 XML 元素的内容限制定义为一系列可使用的数字或字母，我们要使用模式约束（pattern constraint）。下面的例子定义了带有一个限定的名为 “letter” 的元素。可接受的值只有小写字母 a - z 其中的一个： 123456789&lt;xs:element name="letter"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:pattern value="[a-z]"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下一个例子定义了带有一个限定的名为 “initials” 的元素。可接受的值是大写字母 A - Z 其中的三个： 123456789&lt;xs:element name="initials"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:pattern value="[A-Z][A-Z][A-Z]"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下一个例子也定义了带有一个限定的名为 “initials” 的元素。可接受的值是大写或小写字母 a - z 其中的三个： 123456789&lt;xs:element name="initials"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:pattern value="[a-zA-Z][a-zA-Z][a-zA-Z]"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下一个例子定义了带有一个限定的名为 “choice 的元素。可接受的值是字母 x, y 或 z 中的一个： 123456789&lt;xs:element name="choice"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:pattern value="[xyz]"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下一个例子定义了带有一个限定的名为 “prodid” 的元素。可接受的值是五个阿拉伯数字的一个序列，且每个数字的范围是 0-9： 123456789&lt;xs:element name="prodid"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:integer"&gt; &lt;xs:pattern value="[0-9][0-9][0-9][0-9][0-9]"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对一系列值的其他限定下面的例子定义了带有一个限定的名为 “letter” 的元素。可接受的值是 a - z 中零个或多个字母： 123456789&lt;xs:element name="letter"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:pattern value="([a-z])*"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下面的例子定义了带有一个限定的名为 “letter” 的元素。可接受的值是一对或多对字母，每对字母由一个小写字母后跟一个大写字母组成。举个例子，”sToP”将会通过这种模式的验证，但是 “Stop”、”STOP” 或者 “stop” 无法通过验证： 123456789&lt;xs:element name="letter"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:pattern value="([a-z][A-Z])+"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下面的例子定义了带有一个限定的名为 “gender” 的元素。可接受的值是 male 或者 female： 123456789&lt;xs:element name="gender"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:pattern value="male|female"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下面的例子定义了带有一个限定的名为 “password” 的元素。可接受的值是由 8 个字符组成的一行字符，这些字符必须是大写或小写字母 a - z 亦或数字 0 - 9： 123456789&lt;xs:element name="password"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:pattern value="[a-zA-Z0-9]&#123;8&#125;"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对空白字符的限定如需规定对空白字符（whitespace characters）的处理方式，我们需要使用 whiteSpace 限定。下面的例子定义了带有一个限定的名为 “address” 的元素。这个 whiteSpace 限定被设置为 “preserve”，这意味着 XML 处理器不会移除任何空白字符： 123456789&lt;xs:element name="address"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:whiteSpace value="preserve"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 这个例子也定义了带有一个限定的名为 “address” 的元素。这个 whiteSpace 限定被设置为 “replace”，这意味着 XML 处理器将移除所有空白字符（换行、回车、空格以及制表符）： 123456789&lt;xs:element name="address"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:whiteSpace value="replace"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 这个例子也定义了带有一个限定的名为 “address” 的元素。这个 whiteSpace 限定被设置为 “collapse”，这意味着 XML 处理器将移除所有空白字符（换行、回车、空格以及制表符会被替换为空格，开头和结尾的空格会被移除，而多个连续的空格会被缩减为一个单一的空格）： 123456789&lt;xs:element name="address"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:whiteSpace value="collapse"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对长度的限定如需限制元素中值的长度，我们需要使用 length、maxLength 以及 minLength 限定。本例定义了带有一个限定且名为 “password” 的元素。其值必须精确到 8 个字符： 123456789&lt;xs:element name="password"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:length value="8"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 这个例子也定义了带有一个限定的名为 “password” 的元素。其值最小为 5 个字符，最大为 8 个字符： 12345678910&lt;xs:element name="password"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:minLength value="5"/&gt; &lt;xs:maxLength value="8"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 最常用的类型是： xs:string xs:decimal xs:integer xs:boolean xs:date xs:time 属性的默认值和固定值12&lt;xs:attribute name="lang" type="xs:string" default="EN"/&gt;&lt;xs:attribute name="lang" type="xs:string" fixed="EN"/&gt; 可选和必选1&lt;xs:attribute name="lang" type="xs:string" use="required"/&gt;]]></content>
      <tags>
        <tag>XSD</tag>
        <tag>XML Schema</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac如何卸载pandoc]]></title>
    <url>%2F2018%2F09%2F28%2FMac%E5%A6%82%E4%BD%95%E5%8D%B8%E8%BD%BDpandoc%2F</url>
    <content type="text"><![CDATA[将以下脚本保存到本地，命名为uninstall-pandoc.pl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/perl# Script to remove all files installed by the macOS pandoc installer# and unregister the package. Modified from a script contributed# by Daniel T. Staal.use warnings;use strict;use File::Spec;# The main info: this is the list of files to remove and the pkg_id.my $pkg_id = &apos;net.johnmacfarlane.pandoc&apos;;# Find which, if any, volume Pandoc is installed on.my $volume;# First check /, then other volumes on the box.my $cur_test = `pkgutil --pkgs=$pkg_id`;if ( $cur_test =~ m/$pkg_id/ ) &#123; $volume = &apos;/&apos;;&#125; else &#123; opendir( my $dh, &apos;/Volumes&apos; ) or die &quot;Can&apos;t list Volumes: $!\n&quot;; foreach my $dir ( readdir($dh) ) &#123; next if $dir =~ m/^\./; # Skip dotfiles. my $path = File::Spec-&gt;rel2abs( $dir, &apos;/Volumes&apos; ); next if !( -d $path ); # Skip anything that isn&apos;t a directory. my $cur_test = `pkgutil --pkgs=$pkg_id --volume &apos;$path&apos;`; if ( $cur_test =~ m/$pkg_id/ ) &#123; $volume = $path; last; &#125; &#125;&#125;die &quot;Pandoc not installed.\n&quot; if !( defined($volume) );# Get the list of files to remove.my @pkg_files = `pkgutil --volume &apos;$volume&apos; --only-files --files &apos;$pkg_id&apos;`;@pkg_files = map &#123; chomp; File::Spec-&gt;rel2abs($_, $volume) &#125; @pkg_files;# Confirm uninistall with the user.print &quot;The following files will be deleted:\n\n&quot;;print join(&quot;\n&quot;, @pkg_files);print &quot;\n\n&quot;;print &quot;Do you want to proceed and uninstall pandoc (Y/N)?&quot;;my $input = &lt;STDIN&gt;;if ($input =~ m/^[Yy]/) &#123; # Actually remove the files. foreach my $file (@pkg_files) &#123; if ( -e $file ) &#123; if ( system( &apos;sudo&apos;, &apos;rm&apos;, $file ) == 0 ) &#123; warn &quot;Deleted $file\n&quot;; &#125; else &#123; warn &quot;Unable to delete $file: $?\n&quot;; die &quot;Aborting Uninstall.\n&quot;; &#125; &#125; else &#123; warn &quot;File $file does not exist. Skipping.\n&quot;; &#125; &#125; # Clean up the install. if (system(&apos;sudo&apos;, &apos;pkgutil&apos;, &apos;--forget&apos;, $pkg_id, &apos;--volume&apos;, $volume) != 0) &#123; die &quot;Unable to clean up install: $?\n&quot;; &#125;&#125; else &#123; print &quot;OK, aborting uninstall.\n&quot;; exit;&#125;print &quot;Pandoc has been successfully uninstalled.\n&quot;;exit; 在uninstall-pandoc.pl目录下运行 perl uninstall-pandoc.pl 附：官方链接和截图官方链接：http://pandoc.org/installing.html#macos 截图：]]></content>
      <tags>
        <tag>mac</tag>
        <tag>卸载</tag>
        <tag>pandoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter配置远程访问]]></title>
    <url>%2F2018%2F09%2F19%2Fjupyter%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[安装jupyter pip install ipythonpip install jupyter 生成jupyter配置文件 jupyter notebook –generate-config 12#: jupyter notebook --generate-configWriting default config to: /home/xm/.jupyter/jupyter_notebook_config.py 自动生成密码 jupyter notebook password 12345#: jupyter notebook passwordEnter password: # 这里输入密码不会显示字符的Verify password: [NotebookPasswordApp] Wrote hashed password to /home/xm/.jupyter/jupyter_notebook_config.json# 密码已经被加密记录到这个文件中了 获取密码 cat /home/xm/.jupyter/jupyter_notebook_config.json 123456#: cat /home/xm/.jupyter/jupyter_notebook_config.json&#123; &quot;NotebookApp&quot;: &#123; &quot;password&quot;: &quot;这是你的密码，一整段都复制 下来&quot; &#125;&#125; 修改配置文件 vim /home/xm/.jupyter/jupyter_notebook_config.py 12345#懒得找对应配置项的朋友，直接把这四项配置写到文件开头就可以了c.NotebookApp.ip = &apos;*&apos;c.NotebookApp.password = &apos;sha:ce...刚才复制的那个密文&apos;c.NotebookApp.open_browser = Falsec.NotebookApp.port = 8888 #可自行指定一个端口，访问时使用该端口]]></content>
      <tags>
        <tag>jupyter</tag>
        <tag>远程访问</tag>
        <tag>ipython</tag>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux如何查看磁盘可用空间]]></title>
    <url>%2F2018%2F09%2F19%2Flinux%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%8F%AF%E7%94%A8%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[命令 df -h 示例123456789101112USER_MANE@PC_NAME:~$ df -hFilesystem Size Used Avail Use% Mounted onudev 16G 0 16G 0% /devtmpfs 3.2G 26M 3.2G 1% /run/dev/sda1 198G 151G 38G 81% /tmpfs 16G 4.0K 16G 1% /dev/shmtmpfs 5.0M 4.0K 5.0M 1% /run/locktmpfs 16G 0 16G 0% /sys/fs/cgroup/dev/sdb1 917G 290G 581G 34% /SATAtmpfs 3.2G 8.0K 3.2G 1% /run/user/1004tmpfs 3.2G 0 3.2G 0% /run/user/1010tmpfs 3.2G 0 3.2G 0% /run/user/1003]]></content>
      <tags>
        <tag>linux</tag>
        <tag>磁盘</tag>
        <tag>空间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Trick]-bash: tensorboard: 未找到命令]]></title>
    <url>%2F2018%2F09%2F06%2FTrick-bash-tensorboard-%E6%9C%AA%E6%89%BE%E5%88%B0%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[原因tensorboard命令不在环境变量中 解决思路找到tensorboard脚本路径，然后运行 解决方法1python3 /home/USERNAME/.local/lib/python3.6/site-packages/tensorboard/main.py --logdir=LOGDIR NOTE： USERNAME是指用户名称 LOGDIR是指log文件存放的相对或绝对目录]]></content>
      <tags>
        <tag>trick</tag>
        <tag>linux</tag>
        <tag>tensorboard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Python]通过threading开启多线程]]></title>
    <url>%2F2018%2F08%2F09%2FPython-python%E9%80%9A%E8%BF%87threading%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[构造方法：Thread(group=None, target=None, name=None, args=(), kwargs={}) group: 线程组，目前还没有实现，库引用中提示必须是None； target: 要执行的方法； name: 线程名； args/kwargs: 要传入方法的参数。 实例方法： isAlive(): 返回线程是否在运行。正在运行指启动后、终止前。 get/setName(name): 获取/设置线程名。 start(): 线程准备就绪，等待CPU调度 is/setDaemon(bool): 获取/设置是后台线程（默认前台线程（False））。（在start之前设置） 如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，主线程和后台线程均停止 如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，程序停止 start(): 启动线程。 join([timeout]): 阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的timeout（可选参数）。 示例代码123456789101112# Split items and run function through n threads# func形如func(arg_list[0], ..., arg_list[n], items),run_through_threads 可以把items分为num份分配给num个线程运行def run_through_threads(func, arg_list, items, num=4): threads = [] item_len = len(items) for i in range(num): threads.append(threading.Thread(target=func, args=(*arg_list, items[int(i*item_len/num):int((i+1)*item_len/num)]))) for t in threads: t.setDaemon(True) t.start() for t in threads: t.join()]]></content>
      <tags>
        <tag>python</tag>
        <tag>python入门</tag>
        <tag>threading</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Python]对dict字典进行排序]]></title>
    <url>%2F2018%2F08%2F08%2FPython-%E5%AF%B9dict%E5%AD%97%E5%85%B8%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[代码12345678910#定义字典dict = &#123;'a':1, 'b':2, 'c':3, 'd':4, 'e':5&#125;#根据key进行排序dict_sorted_by_key = sorted(dict.items(), key=lambda d: d[0])#根据key进行反向排序dict_sorted_by_key_reverse = sorted(dict.items(), key=lambda d: d[0], reverse=True)#根据value进行排序dict_sorted_by_value = sorted(dict.items(), key=lambda d: d[1])#根据value进行反向排序dict_sorted_by_value_reverse = sorted(dict.items(), key=lambda d: d[1], reverse=True) 示例]]></content>
      <tags>
        <tag>python</tag>
        <tag>dict</tag>
        <tag>字典</tag>
        <tag>python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Python]获取某文件夹下所有文件名]]></title>
    <url>%2F2018%2F08%2F06%2Fpython-%E8%8E%B7%E5%8F%96%E6%9F%90%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%90%8D%2F</url>
    <content type="text"><![CDATA[导入模块 import os 读取目录下文件 os.listdir() #读取当前工作目录下文件名，返回列表os.listdir(‘/username/folder_name/‘) #读取路径下所有文件名，返回列表]]></content>
      <tags>
        <tag>python</tag>
        <tag>python入门</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Trick]git pull 强制覆盖本地文件]]></title>
    <url>%2F2018%2F07%2F31%2FTrick-git-pull-%E5%BC%BA%E5%88%B6%E8%A6%86%E7%9B%96%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[123git fetch --all git reset --hard origin/mastergit pull note：出错的话就再试一次，说不定就可以了]]></content>
      <tags>
        <tag>git</tag>
        <tag>trick</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Trick]在linux上创建root权限用户（不修改系统文件）]]></title>
    <url>%2F2018%2F07%2F31%2F%E5%9C%A8linux%E4%B8%8A%E5%88%9B%E5%BB%BAroot%E6%9D%83%E9%99%90%E7%94%A8%E6%88%B7%EF%BC%88%E4%B8%8D%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简略过程如我们现在要创建一个名为imonce的新用户： adduser imonce 赋予root权限 usermod -g sudo imonce 万事大吉 详细过程有空再补吧(‾⌣‾)]]></content>
      <tags>
        <tag>trick</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-python安装错误：EnvironmentError:mysql_config not found]]></title>
    <url>%2F2017%2F04%2F24%2Fmysql-python%E5%AE%89%E8%A3%85%E9%94%99%E8%AF%AF%EF%BC%9AEnvironmentError-%20mysql_config%20not%20found%2F</url>
    <content type="text"><![CDATA[问题描述：安装mysql-python时报错： 12345678910111213141516Collecting mysql-python Using cached MySQL-python-1.2.5.zip Complete output from command python setup.py egg_info: sh: 1: mysql_config: not found Traceback (most recent call last): File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; File &quot;/tmp/pip-build-_itbcX/mysql-python/setup.py&quot;, line 17, in &lt;module&gt; metadata, options = get_config() File &quot;setup_posix.py&quot;, line 43, in get_config libs = mysql_config(&quot;libs_r&quot;) File &quot;setup_posix.py&quot;, line 25, in mysql_config raise EnvironmentError(&quot;%s not found&quot; % (mysql_config.path,)) EnvironmentError: mysql_config not found ----------------------------------------Command &quot;python setup.py egg_info&quot; failed with error code 1 in /tmp/pip-build-_itbcX/mysql-python/ 问题原因：没有安装libmysqlclient-dev。 解决方案：执行： sudo apt-get install libmysqlclient-dev 安装成功后，再运行pip install mysql-python即可。]]></content>
      <tags>
        <tag>python</tag>
        <tag>trick</tag>
        <tag>mysql</tag>
        <tag>mysql-python安装错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python入门：pickle模块简介]]></title>
    <url>%2F2017%2F04%2F24%2FPython%E5%85%A5%E9%97%A8%EF%BC%9Apickle%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[概要这篇文章介绍了何为pickle以及pickle模块的简单使用方法，即如何使用pickle进行存储存储以及数据的提取，关于pickle模块的其他更加详细的介绍可以参看https://docs.python.org/2/library/pickle.html pickle简介pickle模块是python中用来持久化对象的一个模块。所谓对对象进行持久化，即将对象的数据类型、存储结构、存储内容等所有信息作为文件保存下来以便下次使用。 就比如说你通过pickle将一个数组保存成了文件，那么当你下次通过pickle将这个文件读取出来的时候，你读取到的依然是一个数组，而不是一个看起来长得像数组的字符串。 用pickle保存对象到文件1234567891011121314151617#导入pickle模块import pickle#创建一个名为data1的对象data1 = &#123;'a': '123', 'b': [1, 2, 3, 4]&#125;#打开(或创建)一个名为data1.pkl的文件，打开方式为二进制写入(参数‘wb’)file_to_save = open("data1.pkl", "wb")#通过pickle模块中的dump函数将data1保存到data1.pkl文件中。#第一个参数是要保存的对象名#第二个参数是写入到的类文件对象file。file必须有write()接口， file可以是一个以'w'方式打开的文件或者一个StringIO对象或者其他任何实现write()接口的对象。如果protocol&gt;=1，文件对象需要是二进制模式打开的。#第三个参数为序列化使用的协议版本，0：ASCII协议，所序列化的对象使用可打印的ASCII码表示；1：老式的二进制协议；2：2.3版本引入的新二进制协议，较以前的更高效；-1：使用当前版本支持的最高协议。其中协议0和1兼容老版本的python。protocol默认值为0。pickle.dump(data1, file_to_save, -1)#关闭文件对象file_to_save.close() 用pickle从文件中读取对象(请接着上一个脚本运行) 1234567891011121314#导入pickle模块import pickle#打开一个名为data1.pkl的文件，打开方式为二进制读取(参数‘rb’)file_to_read = open('data1.pkl', 'rb')#通过pickle的load函数读取data1.pkl中的对象，并赋值给data2data2 = pickle.load(file_to_read)#打印data2print data2#关闭文件对象file_to_read.close()]]></content>
      <tags>
        <tag>python</tag>
        <tag>python入门</tag>
        <tag>pickle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程连接mysql报错：error 2003 （hy000）:can't connect to mysql server on 'localhost' (10061)]]></title>
    <url>%2F2017%2F04%2F24%2F%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5mysql%E6%8A%A5%E9%94%99%EF%BC%9Aerror%202003%20%EF%BC%88hy000%EF%BC%89-can't%20connect%20to%20mysql%20server%20on%20'localhost'%20(10061)%2F</url>
    <content type="text"><![CDATA[问题原因mysql配置文件中有一句： bind-address = 127.0.0.1 导致mysql只能从本地进行连接。 解决思路找到mysql的配置文件，将这一行注释掉。 具体解决方案去两个配置文件中找这个配置项： /etc/mysql/my.cnf /etc/mysql/mysqld.cnf 在这两个文件的任意一个中找到 bind-address = 127.0.0.1 后，将其修改成： #bind-address = 127.0.0.1 然后执行 service mysql restart重新启动mysql服务使配置生效即可。]]></content>
      <tags>
        <tag>trick</tag>
        <tag>mysql</tag>
        <tag>远程连接报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程连接mysql报错：1130 - Host '192.168.2.204' is not allowed to connect to this MySQL server]]></title>
    <url>%2F2017%2F04%2F24%2F%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5mysql%E6%8A%A5%E9%94%99%EF%BC%9A1130%20-%20Host%20'192.168.2.204'%20is%20not%20allowed%20to%20connect%20to%20this%20MySQL%20server%2F</url>
    <content type="text"><![CDATA[问题原因MySQL自带配置数据库mysql中的表user中，User=root一栏，Host的值为localhost，导致root用户只能通过本地登录。 解决思路将User=root对应行的Host一栏的值修改为%，允许任意ip登录root。 具体解决方案在本机登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称’%’即可 1234mysql -u root -p mysql&gt;use mysql; mysql&gt;update user set host = &apos;%&apos; where user =&apos;root&apos;; mysql&gt;flush privileges;]]></content>
      <tags>
        <tag>trick</tag>
        <tag>mysql</tag>
        <tag>远程连接报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chainer入门教程(下)：MNIST手写体识别]]></title>
    <url>%2F2016%2F12%2F15%2FChainer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%8B)-MNIST%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[III. 训练一个手写体识别器在这一部分中，我们将使用MNIST手写数字数据集来尝试区分一个28x28像素的手写体图像。这是一个典型的有监督的深度学习。 对于这个问题，我们将会改变我们之前的线性回归器，同时引入一些隐藏的线性神经网络层，当然，也会引入一些非线性的激活函数。这种类型的架构通常被称为Multilayer Perceptron(MLP)。接下来我们就来看一下它是如何处理眼下的这个任务的。 下面的这一段代码会帮助你下载、引入并结构化MNIST数据集。然而为了完成这部分工作，你还需要下载data.py文件，并把它放在你的工作目录(你的脚本或notebook所在的目录)下以方便导入。 12345678# functions for importing the MNIST dataset.import data# We'll first import the data as a variable mnist.# (If this is the first time you've run this function# it could take a minute or two)mnist = data.load_mnist_data() 现在我们可以先看一下这些图片的样子： 12345678910plt.figure(figsize=(12,5))for i in range(10): example = mnist['data'][i].reshape(28, 28) target = mnist['target'][i] plt.subplot(2, 5, i+1) plt.imshow(example, cmap='gray') plt.title("Target Number: &#123;0&#125;".format(target)) plt.axis("off")plt.tight_layout()plt.show() 现在，我们要把数据集中的图像和对应的真实数字分开，并分成训练集和测试集两部分，以便我们在最后检验我们的学习成果。 1234567# Separate the two parts of the MNIST datasetfeatures = mnist['data'].astype(np.float32) / 255targets = mnist['target'].astype(np.int32)# Make a train/test split.x_train, x_test = np.split(features, [60000])y_train, y_test = np.split(targets, [60000]) 这样一来，我们就可以集中精力训练我们的MLP了。MLP包含一系列不同的layer，Chainer又有一个很不错的方法，这可以帮我们把神经网络中所有的layer都封装到一个对象中。 FunctionSet简介这个方便的对象以命名后的layer作为关键字参数，以便我们之后可以引用它们。FunctionSet工作的方式如下： 1model = FunctionSet(layer1=&lt;place link here&gt;, layer2=&lt;place link here&gt;, ...etc.) 然后layer就会在类的实例中作为属性存在。这些layer都可以通过把FunctionSet实例交给optimizer的setup方法同时进行优化： 1optimizer.setup(model) 理解了这个小tip之后，我们就可以继续构建我们的分类器了。我们需要把一个28x28像素的图像降维成一个10维的单形。输出的每一个维度代表一个具体的数字。 MLP架构为了方便教学以及理解，我们在这里建立一个只有三层的神经网络。 我们需要一个link来引入我们的28x28=784的图像，然后一步一步把它降维到10维。 另外，因为线性函数的组织是线性的，而深度学习又具有引入非线性变换的优点，所以当我们引入一些非线性函数时就会有非常好的重复线性层的堆叠。 因此，在前向传播时，我们希望线性变换层和非线性的激活函数层交替出现。通过这种方法，我们的神经网络可以学习到非线性的数据模型以得到更好的预测结果。最后我们通过一个名为softmax的交叉熵损失函数来比较输出的矢量与我们的原本提取出的答案，然后基于计算出的损失来进行反向传播。 最终我们的前向传播的架构应该是这样的形式： 12345out = linear_layer1(data)out = relu(out)out = linear_layer2(out)out = relu(out)out = linear_layer3(out) 到了训练我们的模型的时候，我们希望能够每次处理一部分的样品并在更新权重前来统计它们的损失。 Define the Model首先，我们通过声明link的集以及在训练过程中要用到的optimizer来定义模型。 123456789101112# Declare the model layers together as a FunctionSetmnist_model = FunctionSet( linear1=L.Linear(784, 300), linear2=L.Linear(300, 100), linear3=L.Linear(100, 10) )# Instantiate an optimizer (you should probably use an# Adam optimizer here for best performance)# and then setup the optimizer on the FunctionSet.mnist_optimizer = optimizers.Adam()mnist_optimizer.setup(mnist_model) 构造训练函数现在我们构造一个合适的函数来进行前向传播、定义训练用的数据集以及生成训练之后对MNIST手写图像进行预测的结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243# Construct a forward pass through the network,# moving sequentially through a layer then activation function# as stated above.def mnist_forward(data, model): out1 = model.linear1(data) out2 = F.relu(out1) out3 = model.linear2(out2) out4 = F.relu(out3) final = model.linear3(out4) return final# Make a training function which takes in training data and targets# as an input.def mnist_train(x, y, model, batchsize=1000, n_epochs=20): data_size = x.shape[0] # loop over epochs for epoch in range(n_epochs): print('epoch %d' % (epoch + 1)) # randomly shuffle the indices of the training data shuffler = np.random.permutation(data_size) # loop over batches for i in range(0, data_size, batchsize): x_var = Variable(x[shuffler[i : i + batchsize]]) y_var = Variable(y[shuffler[i : i + batchsize]]) output = mnist_forward(x_var, model) model.zerograds() loss = F.softmax_cross_entropy(output, y_var) loss.backward() mnist_optimizer.update()# Make a prediction function, using a softmax and argmax in order to# match the target space so that we can validate.def mnist_predict(x, model): x = Variable(x) output = mnist_forward(x, model) return F.softmax(output).data.argmax(1) Train the Model我们现在可以开始训练神经网络了（这里我们使用一个比较小的训练次数和一个比较大的批大小，这样可以帮我们节省一些训练时间。你也可以修改一些参数，说不定就会出现更好的结果呢~） 1mnist_train(x_train, y_train, mnist_model, n_epochs=5) 进行预测最后一件事情就是通过测试集来验证我们的模型的精确度，看看是否出现了过拟合的情况。 12345678# Call your prediction function on the test setpred = mnist_predict(x_test, mnist_model)# Compare the prediction to the ground truth target values.accuracy = (pred==y_test).mean()# Print out test accuracyprint("Test accuracy: %f" % accuracy) out: Test accuracy: 0.965900 可以看到，我们才训练了5次就有了一个96.59%的准确率，amazing~ 模型复用如果你觉得某一次的训练结果不错，想要保存下来以后使用，你可以通过Chainer的serializers来将其保存成hdf5格式： 12serializers.save_hdf5('test.model', mnist_model)serializers.save_hdf5('test.state', mnist_optimizer) 要调出使用的时候也很简单： 12serializers.load_hdf5('my_model.model', model_name)serializers.load_hdf5('my_optimizer.state', optimizer_name) Conclusion通过这篇入门教程，相信大家对于机器学习以及Chainer都有了一定的概念。可以看出，Chainer是一个非常灵活且实用的框架，机器学习也并非难以理解。如果你想进一步Chaier这个框架，个人觉得去看看Chainer的官方文档也是一个不错的选择~ Note:本文译自：Introduction to Chainer: Neural Networks in Python 每日一句：On n’est jamais content là où on est.（人们从来不会满意自己所在的地方。）]]></content>
      <tags>
        <tag>chainer</tag>
        <tag>入门教程</tag>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chainer入门教程(上)：在Chainer中做线性回归]]></title>
    <url>%2F2016%2F12%2F14%2FChainer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%8A)%EF%BC%9A%E5%9C%A8Chainer%E4%B8%AD%E5%81%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[简介神经网络技术在统计建模、数据的转换分类回归等各大领域都有很大的应用空间。但是由于计算本身的复杂性以及早期的计算能力不足，神经网络一直没有得到很大的发展。然而近几年，随着GPU计算的进步，涌现出一大批非常强大而实用的神经网络的训练框架如Caffe、Keras、CUDA convnet、Torch7等。在这片教程中，我们着重介绍另一款灵活又好用的框架：Chainer的基础使用方法。你可以通过Jupyter Notebook或是其他的python终端来跟进这篇教程。 在这篇教程中，我们将先通过编写一个简单的线性回归器来帮助你入门，然后我们再编写一个用于识别MNIST手写数字的标准的深度学习模型来让你熟悉编程逻辑。 首先我们需要安装几个python包： 123456#首先更新一下cython，旧的版本可能会导致chainer安装出错pip install --upgrade cython#再把numpy、matplotlib、chainer都安装一下pip install numpypip install matplotlibpip install chainer I. Chainer基础首先我们要导入这篇教程中要用到的包，关于每个包的作用，之后会有简单的介绍： 12345678#Matplotlib and Numpyimport numpy as npimport matplotlib.pyplot as plt#Chainer Specificfrom chainer import FunctionSet, Variable, optimizers, serializersimport chainer.functions as Fimport chainer.links as L 了解Chainer中Variables和Functions的特点和作用首先，我们通过包裹numpy数组定义两个简单的Chainer Variables变量。数组中只有一个值，这样可以方便我们后续做一些标量运算。 12345# Create 2 chainer variables then sum their squares# and assign it to a third variable.a = Variable(np.array([3], dtype=np.float32))b = Variable(np.array([4], dtype=np.float32))c = a**2 + b**2 在Chainer中，Variables对象既是象征的又是数字的。它们在data属性中包含数据的值，但也包含已在它们上执行的操作链的信息。当你需要训练神经网络时，这段操作历史是非常有用的。我们通过调用backward()方法对变量进行BP或（反向模式）自动分化，这给我们提供了所选择的优化与所有更新我们的神经网络所需要的权重信息。 这个过程之所以可以发生，是因为Chainer的Variables对象把所有对其进行操作的函数都进行了存储，分析了其表达式及导数。你将会使用到的一些函数会是带参的，包含在chainer.links中(这里我们作为L导入)。这些函数的参数将在我们的网络的每个训练迭代中更新。其他包含在chainer.functions(这里我们作为F导入)中的函数将会是无参的，只是对变量执行预定义的数学操作。连加减运算都需要调用Chainer Functions，各变量的操作历史都将保存为变量本身的一部分。这使我们能够计算任何变量的相对于任何其他变量的导数。 下面我们来看一个例子，过程如下： 通过调用data属性检查之前定义的变量 使用backward()方法，对变量c进行反向传播 通过在变量中存储的grad属性，检查其导数 12#Inspect the value of your variables.print("a.data: &#123;0&#125;, b.data: &#123;1&#125;, c.data: &#123;2&#125;".format(a.data, b.data, c.data)) output: a.data: [ 3.], b.data: [ 4.], c.data: [ 25.] 1234#Now call backward() on the sum of squares.c.backward()#And inspect the gradients.print("dc/da = &#123;0&#125;, dc/db = &#123;1&#125;, dc/dc = &#123;2&#125;".format(a.grad, b.grad, c.grad)) output: dc/da = [ 6.], dc/db = [ 8.], dc/dc = [ 1.] II. 在Chainer中做线性回归现在我们知道了一点关于基础的Chainer在做什么，让我们用它来训练最基本的神经网络、线性回归网络。当然，这里所涉及的最小二乘优化的解决方案，通过正常的等式计算分析可能更有效，但这个过程将展示每个网络的基本组成部分，你可以直接进行训练。 这个网络没有隐藏的节点，只涉及一个输入节点，一个输出节点，和一个连接他们两个的线性函数。 我们将要进行下列步骤： 生成随机的线性数据集 通过Chainer Link构造一个前向的网络 构造一个函数来进行网络训练 12345678910# Generate linearly related datasets x and y.x = 30*np.random.rand(1000).astype(np.float32)y = 7*x+10y += 10*np.random.randn(1000).astype(np.float32)plt.scatter(x,y)plt.xlabel('x')plt.ylabel('y')plt.show() 一般来说，在Chainer中想要让你的结构保持共同的神经网络，你需要构造一个forward函数，这个函数会带入你的不同的带参的link函数并在序列中把所有数据运行一遍。 然后，我们需要写一个train函数，它将在你的所有的数据上把forward函数运行epochs次。并且在每次forward之后，都调用loss/objective函数，然后通过optimizer和通过backward方法算出的梯度来更新权重。 Chainer使用者通常会在一开始的时候就定义好Link的层（这里我们只需要一层）。然后他们会通过实例化一个optimizer类来指定要用的优化器。最后，他们会通过调用优化实例的设置方法，告诉optimizer来跟踪和更新指定的模型层的参数，该层将作为一个参数被跟踪。 123456789101112131415161718192021222324252627282930313233343536373839# Setup linear link from one variable to another.linear_function = L.Linear(1,1)# Set x and y as chainer variables, make sure to reshape# them to give one value at a time.x_var = Variable(x.reshape(1000,-1))y_var = Variable(y.reshape(1000,-1))# Setup the optimizer.optimizer = optimizers.MomentumSGD(lr=0.001)optimizer.setup(linear_function)# Define a forward pass function taking the data as input.# and the linear function as output.def linear_forward(data): return linear_function(data)# Define a training function given the input data, target data,# and number of epochs to train over.def linear_train(train_data, train_target,n_epochs=200): for _ in range(n_epochs): # Get the result of the forward pass. output = linear_forward(train_data) # Calculate the loss between the training data and target data. loss = F.mean_squared_error(train_target,output) # Zero all gradients before updating them. linear_function.zerograds() # Calculate and update all gradients. loss.backward() # Use the optmizer to move all parameters of the network # to values which will reduce the loss. optimizer.update() 绘制训练结果下面的代码将会把此模型每次训练5遍，并绘制线性链接中当前的参数下的线。你将会看到模型是如何从蓝色的线收敛到红色的线（最终状态）。 12345678910111213141516# This code is supplied to visualize your results.plt.scatter(x,y, alpha =0.5)for i in range(150): linear_train(x_var, y_var, n_epochs=5) y_pred = linear_forward(x_var).data plt.plot(x, y_pred, color=plt.cm.cool(i/150.), alpha = 0.4, lw =3)slope = linear_function.W.data[0,0]intercept = linear_function.b.data[0]plt.title("Final Line: &#123;0:.3&#125;x + &#123;1:.3&#125;".format(slope, intercept))plt.xlabel('x')plt.ylabel('y')plt.show() Note:本文译自：Introduction to Chainer: Neural Networks in Python 每日一句Oh là là ! C’est incroyable !（艾玛，真是令人难以置信！）]]></content>
      <tags>
        <tag>chainer</tag>
        <tag>入门教程</tag>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Reading Notes] Object detection via a multi-region and sematic segmentation-aware CNN model]]></title>
    <url>%2F2016%2F12%2F13%2F%5BReading%20Notes%5D%20Object%20detection%20via%20a%20multi-region%20and%20sematic%20segmentation-aware%20CNN%20model%2F</url>
    <content type="text"><![CDATA[AbstractThis article propose an object detection system that relies on a multi-region deep convolutional neural network that also encodes sematic segmentation-aware features. The module aims at capturing a diverse set of discriminative appearance factors and exhibits localization sensitivity that is essential for accurate object localization. They exploit the above properties of their recognition module by intergrating it on an iterative localization mechanism that alternates between socring a box proposal and refgining its location with a deep CNN regression model. And consiquently, they detect objects with very high localization accuracy. I. IntroductionThe definition of object detection: Given an image return all the instances of one or more type of objects in form of bounding boxes that tightly enclose them. Overfeat: Using two CNN models that apply in a sliding window fashion on multiple scales of an image. The first is used to classify if a window contains an object. The second is to predict the true bounding box location of the object. And use greedy algorithm in the end to merge them. R-CNN: Using Alex Krizhevsky’s Net to extract features from box proposals provided by selective search and then it classifies them with class specific linear SVMs. How to further advance the state-of-the-art on object detection? Focusing on object representation and object localization. Object representation: Indeed features matter a lot on object detection. Instead of proposing only a network architecture that is deeper, here they also opt for an architecture of greater width. And that was accomplished at two levels: They want their object representation to capture several different aspects of an object. To achieve this, they propose a multi-component CNN model (multi-region CNN). Each component of it is steered to focus on a different region. They wish to enrich the above representation so that it also captures semantic segmentation information Object localization: They attempt to built a more powerful localization system that combines their multi-region CNN model with a CNN-model for bounding box regression, which are used within an iterative scheme that alternates between scoring candidate boxes and reﬁning their coordinates. Their Contributions: They develop a multi-region CNN recognition model that yields an enriched object representation capable of capturing a diversity of discriminative appearance factors and of exhibiting localization sensitivity that is desired for the task of accurate object localization. They furthermore extend the above model by proposing a uniﬁed neural network architecture that also learns semantic segmentation-aware CNN features for the task of object detection. They show how to significantly improve the localization capability by coupling the aforementioned CNN recognition model with a CNN model for bounding box regression. Their detection system achieves mAP of 78.2% and 73.9% on VOC2007 and VOC2012 detection challenges respectively. II. Multi-Region CNN Model Activation maps module This part of the network gets as input the entire image and outputs activation maps (feature maps) by forwarding it through a sequence of convolutional layers. Region adaptation module Given a region R on the image and the activation maps of the image, this module projects R on the activation maps, crops the activations that lay inside it, pools them with a spatially adaptive (max-)pooling layer, and then forwards them through a multi-layer network. This is the architecture of the Multi-Region CNN model: There are two aims of that: to force the network to capture various complementary aspects of the objects appearance, thus leading to a much richer and more robust object representation to also make the resulting representation more sensitive to inaccurate localization, which is also crucial for object detection The regions they deploy: Original candidate box Half boxes Central Regions Border Regions Contextual Region Why these regions helps? Discriminative feature diversification Localization-aware representation III. Semantic Segmentation-Aware CNN Model Activation maps module for semantic segmentation aware features Weakly supervised training(see Figure 4) Activation maps Region adaptation module for semantic segmentation aware features They combine the Multi-Region CNN features and the semantic segmentation aware CNN features by concatenating them. The resulting network thus jointly learns deep features of both types during training. IV. Object LocalizationThere are three main components in this section: CNN region adaptation module for bounding box regression It is applied on top of the activation maps produced from the Multi-Region CNN model and, instead of a typical one-layer ridge regression model, consists of two hidden fully connected layers and one prediction layer that outputs 4 values per category. In order to allow it to predict the location of object instances that are not in the close proximity of any of the initial candidate boxes, we Use as region a box obtained by enlarging the candidate box by a factor of 1.3. This combination offers a significant boost on the detection performance of out system by allowing it to make more accurate predictions and for more distant objects. Iterative Localization Their localization scheme starts from the selective search proposals and works by iteratively scoring them and refining their coordinates. Bounding box voting Because of the multiple regression steps, the generated boxes will be highly concentrated around the actual objects of interest. They exploit this “by-product” of the iterative localization scheme by adding a step of bounding box voting. V. Implementation Details For all the CNN models involved in their proposed system, we used the publicly available 16-layers VGG model pre-trained on ImageNet for the task of image classification. Multi-Region CNN model Its activation maps module consistes of the convolustional part of the 16-layers VGG-Net that outputs 512 feature channels. The max-pooling layer right after the last convolutional layer is omitted on this module. Each region adaptation module inherits the fully connected layers of the 16-layers VGG-Net and is fine-tuned separately from the others. Semantic segmentation-aware CNN model The activation maps module architecture consists of the 16-layers VGG-Net without the last classification layer and transformed to a Fully Convolutional Network. Classification SVMs The ground truth bounding boxes are used as positive samples and the selective search proposals that overlap with the ground truth boxes by less than 0.3, are used as negative samples. CNN region adaptation module for bounding box regression The region adaptation module for bounding box regression inherits the fully connected hidden layers of the 16-layers VGG-Net. As a loss function they use the euclidean distance between the target values and the network predictions. VI. Experimental Evaluation Results on PASCAL VOC2007 Detection error analysis Results on PASCAL VOC2012 VII. ConclusionTwo key factors: the diversification of the discriminative appearance factors that it captures by steering its focus on different regions of the object the encoding of semantic segmentation-aware features. By using it in the context of a CNN-based localization refinement scheme, they showed that it achieves excellent results that surpass the state-of-the-are by a significant margin]]></content>
      <tags>
        <tag>Reading Notes</tag>
        <tag>CNN</tag>
        <tag>object detection</tag>
        <tag>multi-region</tag>
        <tag>sematic segmentation-aware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Reading Notes] UniCrawl: A Practical Geographically Distributed Web Crawler]]></title>
    <url>%2F2016%2F12%2F11%2F%5BReading%20Notes%5D%20UniCrawl-%20A%20Practical%20Geographically%20Distributed%20Web%20Crawler%2F</url>
    <content type="text"><![CDATA[AbstractCause the wealth of information available on the web keeps growing, we want to use web crawler to get them. But the traditional method has a fatal limit of its large infrastructure cost. To reduce it, we developed this method, unicrawl, which can show a performance improvement of 93.6% in terms of network bandwidth consumption, and a speedup factor of 1.75. I. introductionNowadays, it’s common that to use parallel process on a large number of machines to achieve a reasonable collection time. While this method requires large computing infrastructures. Like Google and Bing, who rely on big data centers. As for the public crawl repositories, they require externalizing computation and data hosting to a commercial cloud provider. Which may pose the problem of data availability in the mid-long term. And cause there are large amounts of data unnecessary, postprocessing is needed. A solution to those problems is to distribute the crawling effort over several geographically distributed locations. For instance, by allowing several small companies to mutualize their crawling infrastructures. In addition, such an approach leverages data locality as sites can crawl web servers that are geographically nearby. But in this way, the synchronization between the crawler at the different sites is a new problem. Our goal is to reduce such communication costs. UniCrawl is an efficient geo-distributed crawler that aims at minimizing inter-site communication costs. Our design is both practical and scalable. We assess this claim with a detailed evaluation of UniCrawl in a controlled environment using the ClueWeb12 dataset, as well as in geo-distributed setting using 3 distinct sites located in Germany. outline:Section II is related work. Section III introduces the crawler architecture, refining it from existing well-founded central disigns. Section IV is the details about the internal implementaion. Section V presents the experimental results, both in-vitro, and in-vivo over multiple geographical locations in Germany. We discuss out results and future work in Section V. We conclude the paper inSection VII. II. Related workThere are several problems for every crawler to solve: since the amount of information to parse is huge, a crawler must scale a crawler should select which information to download first, and which information to refresh over time a crawler should not be a burden for the web sites that host the content adversaries, e.g., spider traps, need to be avoided with care Mercator/Polybot/IBM WebFountain/Ubicrawl and etc.. III. Distributed crawler architectureA. Single site Design Map-reduce: spill shuffle reduce site storage In UniCrawl, the crawl database of a site is implemented as a single distributed map structure. This map contains for each page its URL, content, and outlinks. INFINISPAN, a distributed key-value store stat supports the following features: Routing: Notes are organized in a ring Elasticity Storage Reliability Interface Consistency Querying Detail of Phases Generate: The goal of the generate phase is to select a set of pages to process during the round. Fetch: During the fetch phase, the map step first groups by host the pages that were generated in the previous phase. Parse: Once the pages are fetched, they are analyzed during the parse phase. Update: The goal of the update phase is to refresh the scores of pages that belong to the frontier in order to prioritize them. B. Multi-site OperationsSeveral key ideas allow UniCrawl to be practical in this setting: Each site is independent and crawls the web autonomously We unite all the site data stores Sites exchanges dynamically the URLs they discover over the course of the crawl Federating the storage: One of the key design concerns of UniCrawl is to bring small monifications to the site code base in order be usable over multiple geographical locations. collaboration between sites: Following the approach advocated by Cho and Garcia-Molina. UniCrawl exchanges newly discovered URLs over time. This exchange occurs at the end of the update phase. We implement the crawl database as a distributed ensemble map that span all the sites. This map operates in frontier mode with a replication factor of one. Crawl quality and cost: The quality of the crawling operation is not only measured by means of pure web-graph exploration but also by the rounds it takes to discover the most interesting pages. IV. ImplementationWe implemented UniCrawl inJava, starting from the code base of Nutch version 2.5.3. Nutch makes use of Apache Gora, an open-source framework that provides an in-memory and persistent data model for big data. Intotal, our contribution accounts for about a dozen thousands lines of code (LOC) split as follows: 9.4 kLOC for Ensemble, 1.1 kLOC for Gora and 2.3 kLOC patch for Nutch A. Merging phasesCause each new map-reduce job creation is expensive as it requires to start a dedicated Java virtual machine, and deploy the appropriate jars. To lower this cost, we merge the fetch and parse phases in out UniCrawl implementation. This means that whenever a reducer fetches a new page, it parses its content and extract the out-links. These links are then directly inserted in the crawl database together with the fetched page. B. CachingTo avoid sending out an URL multiple times across sites, we use a distributed solution. In more details, this cache is a bounded ENSENMBLE map C local to each site and replicated at all nodes in a site. During the update phase, when a reducer selects a URL in the frontier that is associated to a remote site, it first check locally with C is this URL woa previously sent. If this is the case , the reducer simply skips the call to putIfAbsent. Since C is replicated at all nodes, every map-reduce node is co-located with an INFINISPAN node, and C is in memory, this inclusion test costs less than a millisecond. V. EvaluationEvaluate UniCrawl through several key metrics such as the page processing rate, the memory usage and the network traffic across sites. Two parts: Evaluate our approach in-vitro, by running UniCrawl against the ClueWeb12 benchmark in an emulated multi-site architecture and crawling from a local repository. Report several experimental results where we deploy UniCrawl at multiple localtions in Germany and access actual web sites. A. In-vitro validation Single site performance Emulating multiple sites B. UniCrawl in the wild URL Exchange Comparison with Nutch Scalability]]></content>
      <tags>
        <tag>Reading Notes</tag>
        <tag>web</tag>
        <tag>crawler</tag>
        <tag>unicrawl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F12%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Reading Notes]Privacy-CNH: A Framework to Detect Photo Privacy with Convolutional Neural Network using Hierarchical Features]]></title>
    <url>%2F2016%2F12%2F10%2F%5BReading%20Notes%5D%20Privacy-CNH-%20A%20Framework%20to%20Detect%20Photo%20Privacy%20with%20Convolutional%20Neural%20Network%20using%20Hierarchical%20Features%2F</url>
    <content type="text"><![CDATA[MotivationMobile devices have revolutionized how people share photos with each other on social networks with a single click of a button. The content of the photos people shared to the internet are rarely analyzed by the websites before the photos are made available to view. After the photos are posted on the social network to the public to view, it is close to impossible to permanently delete the uploaded photos. Photo leakage, regretion after posting and malicious posting happens from time to time. Related WorksExisting works on photo privacy detection, which rely on low-level vision features, are non-informative to the users regarding what privacy information is leaked from their photos. Detailed Design PCNH is a combination of PCNN and PONN. Given the image features in the input layer, the object features learning pipeline processes the features using hi(x) as the activation functions and the param eters of network structure is encoded as Vi, finally obtaining the photo privacy detection result in the output layer. The convolutional features learning pipeline processes the features using j(x) as the activation function and the parameters of network structure is encoded as Ws, finally obtaining the photo privacy detection result in the output layer. hi(x), j(x) are activation functions, which map from a vector to a scalar. Evaluation]]></content>
      <tags>
        <tag>Reading Notes</tag>
        <tag>PCNH</tag>
        <tag>CNN</tag>
        <tag>Privacy Detect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0到100：zabbix及其支持环境的完整安装教程]]></title>
    <url>%2F2016%2F08%2F08%2F%E4%BB%8E0%E5%88%B0100%EF%BC%9Azabbix%E5%8F%8A%E5%85%B6%E6%94%AF%E6%8C%81%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[版本信息：Ubuntu15.10Apache2.4.12php5.6.11（zabbix3.0要求php版本至少5.4以上）Mysql5.6.31zabbix3.0 前言：本教程包括了ubuntu上LAMP(Linux+Apache+Mysql+Php)环境的搭建以及zabbix安装。因为我们最终是要通过外部计算机访问我们的服务器的，所以我希望你可以先运行一下“ifconfig -a”语句来查看以下自己的IP地址，以方便之后测试服务器。文中将以“IPAddr”来代替你的IP地址，阅读时请注意。这是博主虚拟机上的IP地址： 0.预安装后边会用到的软件，装一下即可：sudo apt-get install vim -y 1.Apache安装在命令行运行下列语句下载apache：sudo apt-get install apache2 -y启动apache服务：sudo /etc/init.d/apache2 start看到下列语句说明启动成功：从其他PC上打开浏览器，输入http://IPAddr，打开页面，如果显示如下，则表示Apache安装成功。 2.安装Mysql在命令行运行下列语句下载mysql：sudo apt-get install mysql-server -y安装的时候会弹出窗口让你设置root帐户的初始密码，根据个人喜好设置一个即可。同样的，安装完了我们也要启动一下mysql的服务：sudo /etc/init.d/mysql start看到下列语句说明启动成功： 3.安装php5在命令行输入下列语句下载php5：sudo apt-get install php5 -y接着安装phpmyadmin：sudo apt-get install phpmyadmin -y安装的过程中根据提示，选择apache2，dbconfig-common那里选择YES，再输入系统root的密码和数据库root的密码即可。版本不同，顺序可能不大一样，总之问什么答什么就对了。顺便改写以下/var/www目录的权限，方便以后编辑网站文件：sudo chmod 777 /var/www创建phpmyadmin的链接：sudo ln -s /usr/share/phpmyadmin /var/www/html/修改一下php5的配置，打开配置文件：sudo vim /etc/php5/apache2/php.ini加入红框中的语句：保存退出。现在在其他的PC上打开浏览器，输入http://IPAddr/phpmyadmin，显示以下页面表示配置成功： 4.安装配置zabbix server###4.1 下载deb： 1234cd ~wget http://repo.zabbix.com/zabbix/3.0/ubuntu/pool/main/z/zabbix-release/zabbix-release_3.0-1+trusty_all.debdpkg -i zabbix-release_3.0-1+trusty_all.debapt-get update ###4.2 安装服务器端运行下列语句：sudo apt-get install zabbix-server-mysql zabbix-frontend-php -y安装完成之后试着启动一下zabbix服务,出现下列语句即为成功： ###4.3 配置zabbix_server.conf打开配置文件：sudo vim /etc/zabbix/zabbix_server.conf把对应项的值改为如下(没有的自己在对应位置加上即可)： DBHost=localhost DBName=zabbix DBUser=zabbix DBPassword=zabbix ###4.4 配置mysql 1234567891011mysql -u root -p(输入你的数据库root密码)mysql&gt; create database zabbix character set utf8 collate utf8_bin;mysql&gt; grant all privileges on zabbix.* to zabbix@localhost identified by &apos;zabbix&apos;;mysql&gt; flush privileges;mysql&gt; \qcd /usr/share/doc/zabbix-server-mysqlzcat create.sql.gz | mysql -u root -p zabbix（输入你的数据库root密码，点击回车后稍微等一会儿）sudo cp -r /usr/share/zabbix /var/www/html/zabbix/etc/init.d/zabbix-server restart 最后出现下列语句即为成功：###4.5 配置php编辑php的配置文件：sudo vim /etc/php5/apache2/php.ini把对应项的值改为如下(没有的自己在对应位置加上即可)： post_max_size = 16M max_execution_time = 300 max_input_time = 300 date.timezone = “Asia/Shanghai” 改完之后重启apache2：/etc/init.d/apache2 restart 5.进入zabbix在另外一台PC上打开浏览器，在地址栏输入：http://IPAddr/zabbix显示以下页面：点击右下角的Next step进入Check of pre-requisites页面：这个页面是检测服务器配置是否合格的页面，必须全部为OK才可以点击Next step进入Configure DB connection页面。其中password为zabbix（我们刚刚配置数据库时设置的）。接下来的Zabbix server details和Pre-installation summary两个页面无脑点Next step即可。显示如下页面我们就可以点击Finish了。点击Finish之后出现zabbix server的登录页面，这里Username为Admin，Password为zabbix，最后点击Sign in，大功告成~]]></content>
      <tags>
        <tag>zabbix安装</tag>
        <tag>lamp配置</tag>
      </tags>
  </entry>
</search>
