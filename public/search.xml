<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[互联网医疗服务：昨天、今天、明天]]></title>
    <url>%2F2019%2F06%2F08%2F%E4%BA%92%E8%81%94%E7%BD%91%E5%8C%BB%E7%96%97%E6%9C%8D%E5%8A%A1%EF%BC%9A%E6%98%A8%E5%A4%A9%E3%80%81%E4%BB%8A%E5%A4%A9%E3%80%81%E6%98%8E%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[自党的十八届五中全会明确将“互联网+”行动计划作为未来发展战略，“互联网+健康医疗”便逐渐成为我国医疗行业发展的新方向。2016年6月24日“首届国际互联网医疗大会暨中国互联网医疗健康产业联盟成立大会”在乌镇召开，对医疗、医药、保险等产业链各节点、及线上线下更有效率地融合；如何使相关政策、行业标准的推出与产业创新更好协同；如何有效推进互联网医疗健康产业发展等问题，进行了深入探讨。“互联网+健康医疗”新型服务模式有利于改善医疗质量、减少患者入院率、降低医疗成本、提高效率，是我国深化医疗卫生体制改革的重要任务和支撑，其对于我国建设跨地域、跨机构就诊信息共享的区域医疗联合体有着较强的现实和理论意义。 互联网的飞速发展催生了新的医疗服务模式，互联网医疗已成为医疗卫生和预防保健领域中不可或缺的一部分。随着李克强总理提出制定“互联网+”行动计划，医疗领域中“互联网+医疗”的产品和服务如雨后春笋般涌现，而建立以互联网为载体、患者主动参与疾病诊疗、可随时随地进行线上线下互动的医疗服务管理新模式，构建新的互联网医疗服务体系，能使广大群众享受更加高效、公平和便捷的医疗卫生和预防保健服务。本文在介绍近年来国内、外互联网医疗服务主要模式的基础上，就互联网医疗发展面临的机遇、挑战和未来走势作一探讨。 昨天：我国传统医疗服务模式传统医疗服务模式结构我国传统医疗服务模式是以医院为中心的星型结构（如下图），医院处于中心地位。药企、医疗器械，保险公司、医保等机构以及患者、其他医疗服务都围绕医院展开。从检查、科室就医，处方药，患者就医流程都由医生主导，医患信息不透明。另外，政府对于医院财政支出不足，而随着我国老龄化加剧，现今的医保资金难以满足逐渐增加的参保人数需求，所以医保资金的压力逐渐转移到医院。第三，处方药作为医院收入的一大来源，也是一定程度上掌握在医院手里。 传统医疗的不足传统医疗服务模式中，由于资金流、信息流以及物料流等以医院为核心环节，其他各环节信息流通不畅导致工作效率低下，引起以下诸多弊端。首先，医疗资源分布不均。由于三甲医院对基层医疗机构人才和资源的虹吸效应，优质医疗资源过度集中于大城市，基层医疗人员数量不足、诊疗水平达不到标准，导致“乡镇医院无患者可医，大医院人满为患”。再者，就医方式效率低，就医体验“三长一短”，服务质量不尽如人意，导致医患关系紧张。且仅有单纯的院内服务，缺乏院后服务。其次，政府财政支持不足，医保缺口明显。目前医院正常运营大部分资金来源于自身盈利，但其本质的公益性又使得收入有所限制，加之政府的宏观调控，使得医院处于两难境地。导致这些弊端本质在于人们日益增长的医疗保健需求同传统医疗服务所提供的资源不对称，无法满足当今人们需求变化的节奏。 今天：互联网医疗服务的主要模式国外的主要模式国外互联网医疗的建设起步较早，现已形成相对完善的管理和组织体系。考虑到人们对医疗保健知识的渴求日益增强，而在医疗环境中获取的健康信息及其可用性又很有限，因此越来越多的互联网医疗服务软件被开发出来并得到广泛应用。一项调查结果表明，美国居民中约31%的手机用户使用手机寻找健康或医疗信息，约35%的手机用户下载了应用程序来跟踪或管理自己的健康状况。另一项相似调查的结果显示，72%的成年人在互联网上查询健康信息，65%的互联网用户表示使用互联网和手机可更好地了解健康信息，互联网医疗干预的灵活性受到了广泛的追捧和欢迎。 可穿戴医疗设备可穿戴医疗设备能通过传感器及时获取生理、行为和健康相关的数据，研究人员则可通过互联网同步获得这些数据并分析可能的影响因素。便携式和可穿戴传感器已越来越多地用于采集个人的生物、心理和行为数据，用于个人保健和健康的监测。通过可穿戴医疗设备获取的信息除能用于医疗保健外，还能用于相关医学研究并为制定公共卫生政策提供依据。 数据平台的构建和共享在美国的医疗服务体系中，患者的电子病历和电子处方可在医生之间共享，当居民在异地发生意外时，医疗机构就能通过他的身份信息迅速获取其电子病历及处方，帮助医生及时、准确地了解他的疾病史等情况。这种数据共享也有利于远程医疗的开展，利用医生、患者和科研机构三者之间形成的互联网数据大平台，医生、患者和科研人员可根据自己的需要利用和获取相关信息，有利于诊疗活动的开展，并提高患者的就医满意度，保障患者健康。 监测和记录利用互联网医疗设备进行生物信息监测和健康指导已渐走入大众生活，通过监测可帮助患者及医护人员及时发现相关风险，提高患者的自我健康管理能力。ZEO通过蓝牙手机和床旁设备相连接，通过睡眠监测得出综合睡眠报告，用户也可通过监测得分的变化或与同年龄组平均分相比较而了解自己的睡眠状况。另外，越来越多的智能手机内置了运动传感器，可检测用户的异常行为，如老年人的跌倒、帕金森病患者的步态僵直等。还有的互联网医疗服务软件能监测睡眠状况、检测心血管疾病、警示健康状况或监测慢性阻塞性肺疾病患者的血氧饱和度和呼吸等指标值。类似的，血压仪、血糖仪和电子心电仪等医疗监测设备已得到广泛使用，这些便携式医疗设备能帮助患者在家中进行自我健康监测，时刻为患者提供健康信息及服务。 信息化诊所运营商互联网医疗的移动性使得人们无论是在家中、还是在路途中都能得到医疗服务和获取各种与健康相关的信息，避免了传统就医模式中的看病难、流程繁琐等问题，节省时间的同时还降低了就医成本，并具有促进自我健康管理的作用。One Medical Group运营了多家诊所，患者可网上预约就诊或在线购买药品、甚至在线查询检查结果。新技术提高了临床医疗的透明度，但仍存在相关信息的所有权和医疗记录访问的权限等敏感问题，需予进一步关注。互联网医疗的有效性、安全性和成本—效益的评估将是对其未来研究工作的重要部分。 慢性病管理平台随着经济、社会的迅速发展，慢性病发病率逐年升高，已成为首要的公共卫生问题，使得研究者和企业都非常关注对慢性病人群的医疗服务问题。WellDoc是一种糖尿病患者用血糖水平自我管理软件，通过手机和云端平台记录和存储血糖水平数据，患者能用其监测自己的血糖水平变化情况。移动健康工具的出现推动了卫生保健领域、尤其是慢性病管理的发展。有研究显示，69%的美国成年人使用互联网技术监测健康指标来管理和控制自己的慢性病。互联网医疗可提高慢性病患者的疾病自我管理能力，提高其生活质量。 国内主要模式国内医疗资源短缺且配置不合理，互联网医疗也相对落后。目前，我国互联网医疗可按诊疗时间分为诊疗前、诊疗中和诊疗后3个环节，按诊疗内容分为预约挂号、检查诊疗、药物配送、健康监测和支付保险5项服务，按适用对象分为面向医生和直接面向用户2类，按建设机构分为医院自建、企业自建和医院、企业合建3型。 网上就医服务在互联网医疗模式下，患者可通过手机应用软件或相关网站选择合适的医院进行预约挂号及完成在线支付，并可通过网络实时查看目前排队情况以方便就医，节省就医时间。微信医院或互联网医院主要是为患者提供就医服务，包括预约挂号、预约就诊等。由于微信应用广泛并具有简单、快捷的特点，微信医院得到了患者更多的认同和接受。以“掌上药店”和“天猫药馆”为代表的线上药品销售商店会自动显示附近联网的药房，患者可根据自己情况进行线上下单和结算，然后选择自取或快递的配送方式，购药变得十分方便。 医疗咨询和医患沟通以“平安医生”、“轻问诊”为代表的网络医疗咨询平台具有问诊、自诊、健康信息搜索、健康状况提醒等功能，受到患者和人们的欢迎和追捧。随着我国经济水平整体提高和疾病谱改变，人们的医疗卫生观念正逐渐由“治已病”向“防未病”转变，并希望能通过互联网获取更多的医疗保健知识。互联网医疗通过搭建医疗咨询和医患沟通平台拉近医患之间的距离，向患者提供医疗信息的同时树立了医生的个人品牌，有利于缓解医院门诊压力。 大数据平台在互联网医疗模式下，患者的医疗信息可存储于计算机，并通过云端平台发送给医疗人员和相关机构。阿里云的“未来医院”能帮助医院建立移动医疗服务平台，利用电子平台完成从门诊挂号到住院缴费、电子处方、药品配送、患者转诊、医保实时报销等各环节。目前，互联网医疗也已进军医保领域，包括线上投保及查询、医保结算以及医保机构对居民健康大数据的分析、评估和预测。 医生集团互联网的迅猛发展为医生与患者之间的信息交流提供了便捷渠道，一定程度上降低了医疗信息的不对称状况和沟通成本，有助于医生更好地建立个人品牌，而医生集团则为医生自由执业提供了一个新的选项。“张强医生集团”是国内出现的首个医生集团，现已有更多的医生集团。医生集团在增加医生自由执业路径的同时，也面临着医疗制度和法律、法规的制约，其未来的发展还有待相应制度、体制的进一步完善及支持。 明天：互联网医疗的走势分析机遇 传统医疗服务的痛点催生了互联网医疗。我国医疗体系存在医疗资源短缺且分布不均衡的问题，同时基层医疗服务水平也亟待提高，人们对医疗体制改革的呼声很高。患者有看病难、看病贵、看病繁琐、费用昂贵、渴望能够获得个性化的医疗和卫生保健知识等问题，医生则有难以与患者高效互动、缺乏接受培训和进行科研的时间等问题。在此情况下，互联网医疗顺势而出，在建立以患者为核心的医疗服务模式、诊疗信息的互联互通、健康管理和慢性病监测等方面顺应了患者的需求，同时也为医生带来了更多的职业便利和执业机会。 人口老龄化、慢性病普遍化为互联网医疗发展带来了机遇。人口老龄化，慢性病患病率逐渐提高，由此加重了我国医疗资源的紧张程度和人均医疗费用的增长速度。慢性病和老年患者多需反复就诊、长期用药、定期检测，患者的疾病自我管理能力和治疗依从性影响到疾病的进展，而通过可穿戴医疗设备等互联网医疗的监测和慢性病管理正可在一定程度上解决这些问题。 科技创新将推动互联网医疗快速发展。智能移动终端和移动网络的普及促进了互联网医疗的快速发展，可穿戴医疗设备、慢性病管理平台、智能设备等的出现改变了传统的就医诊疗模式，数据云端处理及分析的广泛应用则宣告着精准医疗和生物信息学时代的到来，医疗模式将从治疗疾病向预防疾病方向转变。 挑战 相关法律、法规亟待完善。互联网医疗服务的主体已从患者、医生和医院转变为如今的医疗服务需求者、医疗机构、资源提供者、医保机构和第三方医疗服务商，各主体间相互联系、相互影响、相互制约，构成了完整的服务网络。然而，我国互联网医疗起步较晚，相关法律、法规亟待完善。医疗活动具有严肃性和复杂性，承担着重大的社会责任，有关医生多点执业的实施、互联网医疗的开展、药品网络营销的安全性、医生实名制的真实性、患者隐私信息的保护、医疗数据能否真实反映患者的实际病情、医疗责任划分及保险制度等都需有进一步的相关法律、法规的制约或支持。 加强科技创新和技术发展。我国互联网医疗尚不如其他行业那样具有完善的管理体制和成熟的技术，目前整体发展水平相对滞后，必须有相关行业的支持和技术支撑，使医学、技术和管理有机结合，形成相互补充、相互促进的联合体，方能使之达到可持续发展的状态。因此，需对医生进行必要的培训，使其具备相应的计算机应用技能;医院必须与企业进行合作，及时更新和强化硬件实力，但应注意患者数据的安全性和隐私保护。 建立品牌，提高影响力。传统医疗服务依赖于医院实体运行，医院高墙耸立，信息不对外流通，而互联网医疗是一个开放的平台，医生自身品牌及影响力的建立就显得尤为重要。然而，受传统就医模式及思维的影响，普遍群众对互联网医疗的认知和接受程度都较低，且缺乏信任感。这就需要互联网医疗在坚持医疗服务的同时，还需利用新媒体等手段建立品牌，以促进自己的发展和良性运行。 reference:http://news.hc3i.cn/art/201704/38557.htmhttp://xueshu.baidu.com/usercenter/paper/show?paperid=2932796969c7427f0fe6772845e28776&amp;site=xueshu_se]]></content>
      <categories>
        <category>昨天、今天、明天</category>
      </categories>
      <tags>
        <tag>互联网医疗</tag>
        <tag>服务</tag>
        <tag>SERVICE</tag>
        <tag>昨天、今天、明天</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[边缘计算：愿景和挑战]]></title>
    <url>%2F2019%2F06%2F07%2F%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%EF%BC%9A%E6%84%BF%E6%99%AF%E5%92%8C%E6%8C%91%E6%88%98%2F</url>
    <content type="text"><![CDATA[边缘计算有可能解决响应时间要求、电池寿命限制、带宽成本节约以及数据安全和隐私等问题。本文首先介绍了边缘计算的定义，然后介绍了从云卸载到智能家居和城市，以及协同边缘到实现边缘计算概念的几个案例研究。最后，我们提出了边缘计算领域的一些挑战和机遇，希望本文能引起社会的关注，并对这一方向的研究有所启发。 为什么要研究边缘计算到2019年，由人、机器和事物产生的数据将达到500 zettabytes，正如思科全球云指数所估计的那样，但是到那时全球数据中心IP流量将仅达到10.4 zettabytes。到2019年，45%的物联网创建数据将存储、处理、分析，并在网络附近或边缘采取行动。思科互联网业务解决方案集团（Cisco Internet Business Solutions Group）预测，到2020年，将有500亿台设备连接到互联网上。有些物联网应用可能需要很短的响应时间，有些可能涉及到私有数据，有些可能产生大量的数据，这对网络来说可能是一个沉重的负担。云计算的效率不足以支持这些应用程序。 什么是边缘计算数据在网络边缘的生成越来越多，因此，在网络边缘处理数据也会更有效。以前的工作，如微型数据中心、Cloudlet和雾计算，已经引入到社区，因为当数据在网络边缘生成时，云计算并不总是有效的数据处理。在这一部分中，我们列出了一些原因，为什么对于某些计算服务，边缘计算比云计算更有效，然后我们给出了我们对边缘计算的定义和理解。 为什么需要边缘计算来自云计算的推动随着边缘数据生成量的不断增加，数据传输速度正成为云计算范式的瓶颈。例如，波音787每秒将生成大约5千兆字节的数据，但飞机与地面卫星或基站之间的带宽不足以传输数据。 来自物联网的拉动可以肯定的是，网络边缘的事物数量在几年内将发展到数十亿以上。因此，它们产生的原始数据将是巨大的，使得传统的云计算效率不足以处理所有这些数据。这意味着物联网产生的大部分数据将永远不会传输到云，而是将在网络边缘消耗。 从数据消费者到生产者的改变从数据消费者到数据生产者/消费者的变化需要在边缘放置更多的函数。例如，今天人们拍照或录像，然后通过云服务（如YouTube、Facebook、Twitter或Instagram）共享数据，这是很正常的。 此外，每一分钟内，YouTube用户上传72小时的新视频内容；Facebook用户分享近250万条内容；Twitter用户推特推特推特推特推特推特近30万次；Instagram用户发布近22万张新照片。 边缘计算是什么边缘计算是指允许在网络边缘、代表云服务的下游数据和代表物联网服务的上游数据进行计算的启用技术。在这里，我们将“边缘”定义为数据源和云数据中心之间的任何计算和网络资源。 边缘计算可以与雾计算互换，但是边缘计算更多地集中在事物方面，而雾计算更多地集中在基础设施方面。 边缘计算的优势在边缘计算中，我们希望将计算放在数据源附近。与传统的基于云的计算模式相比，这有几个好处。在这里，我们使用社区的一些早期结果来展示潜在的好处。研究人员建立了一个概念验证平台，用于运行人脸识别应用程序，通过将计算从云端移动到边缘，将响应时间从900 ms缩短到169ms。Ha等人使用Cloudlet卸载可穿戴认知辅助的计算任务，结果表明，响应时间在80-200ms之间，而且Cloudlet卸载还可以减少30%-40%的能耗。clonecloud在移动与云的结合分区、迁移与合并、按需实例化分区等方面，其原型可以为测试应用减少20倍的运行时间和能源。 案例研究云卸载在传统的内容交付网络中，只有数据缓存在边缘服务器上。这是基于内容提供商在互联网上提供数据的事实，这在过去几十年中是正确的。在物联网中，数据在边缘产生和消耗。因此，在边缘计算范式中，不仅应该在边缘缓存数据，还应该缓存应用于数据上的操作。 应用： 导航应用程序可以将导航或搜索服务移动到局部区域的边缘，在这种情况下，只涉及几个地图块。 可以在边缘节点上进行内容过滤/聚合，以减少要传输的数据量。 视觉辅助娱乐游戏、增强现实、互联健康等实时应用可以通过边缘节点快速响应。 视频分析由于数据传输延迟和隐私问题，云计算不再适用于需要视频分析的应用程序。 与单独的云计算相比，可以在每台边缘设备上利用数据和计算能力，并更快地获得结果。 智能家居下图显示了智能家居环境中Edgeos的一个变体的结构。Edgeos需要通过Wi-Fi、蓝牙、ZigBee或蜂窝网络等多种通信方式从移动设备和各种事物收集数据。来自不同来源的数据需要在数据抽象层中进行融合和按摩。 智慧城市 大数据分析：到2019年，拥有100万人口的城市每天将产生180 PB的数据。 低延迟 位置感知 边缘协作协作边缘将地理上分布的多个利益相关者的边缘连接起来，尽管这些利益相关者的物理位置和网络结构不同。这些特殊的连接边缘为利益相关者提供了共享和合作数据的机会。 例如医院会总结并分享某次流感爆发的信息，如平均成本、症状和人口等。理论上，患者会按照处方从药房获得药片。一种可能是病人没有接受治疗。然后医院必须承担再入院的责任，因为它不能得到病人没有服用药物的证据。现在，通过协作边缘，药房可以向医院提供患者的购买记录，这大大简化了医疗保健责任。 挑战和机遇可编程性通常，程序是用一种编程语言编写的，并为特定的目标平台编译，因为程序只在云中运行。然而，在边缘计算中，计算是从云上卸载的，边缘节点很可能是异构平台。在这种情况下，这些节点的运行时是不同的，程序员编写一个可能部署在边缘计算范式中的应用程序面临着巨大的困难。 命名在边缘计算中，一个重要的假设是事物的数量是巨大的。在边缘节点的顶部，有许多应用程序在运行，每个应用程序都有其自己的结构，说明如何提供服务。与所有计算机系统一样，边缘计算中的命名方案对于编程、寻址、事物识别和数据通信都非常重要。然而，边缘计算范式的有效命名机制尚未建立和标准化。边缘从业者通常需要学习各种通信和网络协议，以便与系统中的异构事物进行通信。边缘计算的命名方案需要处理事物的移动性、高度动态的网络拓扑、隐私和安全保护，以及针对大量不可靠事物的可扩展性。 数据抽象通过服务管理层的空气位置指示器，各种应用程序可以运行在消耗数据或提供服务的EDGEOS上。在无线传感器网络和云计算范式中，数据抽象已经得到了很好的讨论和研究。然而，在边缘计算中，这个问题变得更具挑战性。有了物联网，网络中会有大量的数据生成器，这里我们以一个智能家庭环境为例。在智能家居中，几乎所有的东西都会向Edgeos报告数据，更不用说在家里部署了大量的东西。然而，网络边缘的大多数东西，只定期向网关报告感应到的数据。 来自不同事物的报告数据具有不同的格式 有时很难确定数据抽象的程度 数据抽象的另一个问题是对事物的适用操作 服务管理 差异化：随着物联网部署的快速增长，我们预计将在网络边缘部署多种服务，如智能家居。 可扩展性：可扩展性在网络边缘可能是一个巨大的挑战，与移动系统不同，物联网中的东西可能是非常动态的。 隔离：隔离是网络边缘的另一个问题。 可靠性：最后但不是最不重要的，可靠性也是网络边缘的一个关键挑战。我们可以从服务、系统和数据的不同角度来识别可靠性方面的挑战。 隐私和安全 社区的隐私和安全意识。 从Edge上收集的数据的所有权。 缺少有效的工具来保护网络边缘的数据隐私和安全。 优化指标 延迟：延迟是评估性能的最重要指标之一，特别是在交互应用程序/服务中。 带宽：从延迟的角度来看，高带宽可以减少传输时间，特别是对于大数据（如视频等）。 能源：能源是网络边缘最宝贵的资源。 成本：从服务提供商的角度，如YouTube、Amazon等，边缘计算为他们提供了更少的延迟和能源消耗，潜在的增加投入和改进的用户体验。 结论现在，越来越多的服务被从云推到网络的边缘，因为在边缘处理数据可以确保更短的响应时间和更好的可靠性。此外，如果可以在边缘处理更大的数据部分，而不是上传到云端，那么也可以节省带宽。物联网和通用移动设备的迅速发展改变了EDGE在计算范式中的角色，从数据消费者转变为数据生产者/消费者。在网络边缘处理或按摩数据会更有效。 论文原文：Edge Computing: Vision and Challenges]]></content>
      <categories>
        <category>Reading Notes</category>
        <category>Service Computing</category>
      </categories>
      <tags>
        <tag>Service Computing</tag>
        <tag>Edge Computing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年10大战略性科技趋势7·8·9·10]]></title>
    <url>%2F2019%2F06%2F05%2F2019%E5%B9%B410%E5%A4%A7%E6%88%98%E7%95%A5%E6%80%A7%E7%A7%91%E6%8A%80%E8%B6%8B%E5%8A%BF7%C2%B78%C2%B79%C2%B710%2F</url>
    <content type="text"><![CDATA[2019年十大战略技术趋势 趋势7:区块链区块链是一种分布式账本。分布式账本是一个按时间顺序扩展的加密签名、不可撤销的交易记录列表，由网络中的所有参与者共享。 区块链通过消除业务摩擦提供业务价值，通过使分类账独立于单个应用程序和参与者来实现这一点，并在分布式网络中复制分类账，以创建基于共识的重大事件权威记录。 区块链还支持分布式信任架构，允许不受信任方进行商业交易，并使用各种资产创造和交换价值。 区块链承诺通过建立信任、提供透明度和减少业务生态系统之间的摩擦、潜在地降低成本、减少交易结算时间和改善现金流来重塑行业。 完整的区块链解决方案面临着关键挑战，这些挑战将成为2023年强大的可扩展解决方案的交付的巨大阻碍。区块链技术和概念是不成熟的，在关键任务和规模业务运营中无法被理解和验证。 尽管如此，到2030年，区块链将创造3.1万亿美元的商业价值。 区块链的实用方法发展需求： 清楚了解业务机会和潜在的行业影响 清楚了解区块链技术的能力和局限性 信任架构 实现技术发展所需的技能 趋势8:智能空间智能空间是一种物理或数字环境，在这种环境中，人类和技术支持的系统在日益开放、连接、协调和智能的生态系统中相互作用。多个元素——包括人、流程、服务和事物——在一个智能空间中聚集在一起，为一组目标人物或行业场景创造一种更加沉浸式、交互式和自动化的体验。 一段时间以来，这一趋势一直围绕着智能城市、数字工作场所、智能家居和互联工厂等要素展开。我们相信，市场正进入一个快速交付强大智能空间的时期，无论是作为员工、客户、消费者、社区成员还是公民，技术都将成为我们日常生活中不可或缺的一部分。人工智能相关趋势、物联网连接边缘设备的扩展、物联网和组织的数字孪生兄弟的发展以及区块链的成熟，为推动目标环境中更多的连接、协调和智能解决方案提供了越来越多的机会。 智能空间正沿着五个关键维度发展： 开放 Openness 互联 Connectedness 协调 Coordination 智能 Intelligence 有界 Scope 一看就明白，不多解释了。 趋势9:数字伦理和隐私数字道德和隐私正日益受到个人、组织和政府的关注。消费者越来越意识到他们的个人信息是有价值的，并要求控制。各组织认识到保护和管理个人数据的风险越来越大，各国政府正在实施严格的立法，以确保做到这一点。 任何关于隐私的讨论都必须以更广泛的数字道德和客户、参与者和员工的信任为基础。虽然隐私和安全是建立信任的基础组件，但信任实际上不仅仅是这些组件。正如牛津词典所定义的，“信任”是对某人或某物的可靠性、真实性或能力的坚定信念。信任是在没有证据或调查的情况下接受陈述的真实性。最终，一个组织在隐私方面的立场必须由其在伦理和信任方面的更广泛立场所驱动。从隐私到道德的转变将对话从“我们是否顺从”转向“我们是否做了正确的事情”。从合规驱动的组织到道德驱动的组织的转变可以被描述为以下几个意图层次： Mind compliance：作为层次结构中的最低级别，心理依从性是由外部驱动的，并专注于避免问题。在这里，企业根据允许的内容来决定技术的使用。如果没有反对建议的规则，就允许这样做。 Mitigating risk：这一级别的重点是企业愿意承担的风险，而不会对自身造成伤害。这包括评估对他人造成伤害的风险，以及“被抓住”做一些会导致公众尴尬和名誉风险的事情。 Makeing a difference：伦理考虑可以用来改变客户、行业甚至整个社会。对于商业企业来说，这意味着通过在道德之外创造价值主张来实现竞争差异化。对于公共部门机构来说，这可能意味着根据他们的期望为公民创造价值。 Following your values：这是指由你的道德指南针驱动的决策。你的品牌代表什么？你有什么公司价值观？你的“品牌许可”是什么？ 趋势10:量子计算一种商业化、价格合理、可靠的量子计算（qc）产品或服务可以改变一个行业。一个例子是药品，在药品中，新的药物化合物可以快速衍生，客户或人群的细分可以发生在地方政府、航空公司、零售和金融服务部门。在过去的两年里，Gartner对质量控制的调查每年增加了三倍多。引起这一兴趣的因素有三个： 量子计算控制对密码术的威胁 对量子计算的能力和特定应用的时间框架的好奇 量子计算作为竞争优势的潜在用途 量子计算的主要潜在应用包括： 优化。优化问题很可能是质量控制的第一个用例。质量控制优化可能有助于机器学习、人工智能和神经网络。他们的承诺是，随着技术的成熟，到2023年，他们将能够显著提高模式识别的加速。 材料科学。质量控制可用于分析复杂的原子相互作用，从而更快地发现新材料，从而实现新经济和新发现。创造新的可申请专利的材料是关键行业早期采用者的主要潜在利润来源。 化学。qc可以在原子尺度上实现量子模拟，允许设计新的化学过程。 个性化药物。质量控制可以用来模拟原子水平的分子相互作用，以加快新的癌症治疗药物上市的时间。质量控制可以加速并更准确地预测蛋白质的相互作用，从而产生新的药物方法。 生物学。qc可用于光合作用等过程的自然量子模拟，或用于模拟能量系统和相互作用。质量控制可以帮助加速新的或改进肥料的开发，帮助改善世界粮食来源。 许多挑战仍然存在： 量子误差。当谈到量子优势时，最小化量子误差是很重要的。将通用的门模型量子计算机扩展到实际的有用尺寸将需要加入量子误差校正方案。人们相信，当量子计算机达到100到300个逻辑量子比特，并且有些复杂的问题需要更多的解决时，就可以完成有意义的工作。 去相干。当一个量子系统不完全与环境隔离，而是与环境接触时，相干随时间衰减。这个过程叫做量子退相干。量子算法只在相干到位时执行。目前，只有很短的相干时间是可能的。 缺乏标准的开发语言。由于系统的量子性质，质量控制开发语言将与现有的开发语言非常不同。随着硬件的进步，招募和培训开发人员，建立产品的思想共享，使其成为标准，这是一场竞赛。 摘译自：https://www.gartner.com]]></content>
      <categories>
        <category>gartner</category>
        <category>趋势</category>
      </categories>
      <tags>
        <tag>科技趋势</tag>
        <tag>gartner</tag>
        <tag>战略研究</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年10大战略性科技趋势5·6]]></title>
    <url>%2F2019%2F06%2F04%2F2019%E5%B9%B410%E5%A4%A7%E6%88%98%E7%95%A5%E6%80%A7%E7%A7%91%E6%8A%80%E8%B6%8B%E5%8A%BF5%C2%B76%2F</url>
    <content type="text"><![CDATA[2019年十大战略技术趋势 趋势5:赋能边缘边缘计算描述了一种计算拓扑结构，其中信息处理、内容收集和传递更靠近这些信息的源和存储库。边缘计算借鉴了网格网络和分布式处理的概念。它试图将流量和处理保持在本地，目标是减少流量和延迟。因此，边缘内容交付的概念已经存在很多年了。“在哪里处理数据”的钟摆在高度集中的方法（如大型机或集中云服务）和更分散的方法（如PC和移动设备）之间摇摆。连接和延迟挑战、带宽限制以及嵌入在边缘的更大功能都有利于分布式部署模型。处理能力的优势和在超尺度下运行的低成本，加上管理和协调数千个地理上分离的端点的复杂性，有利于集中化模型。 当前对边缘计算的大部分关注来自于物联网系统向特定行业（如制造业或零售业）的嵌入式物联网世界提供断开连接或分布式功能的需求。拓扑的广泛应用以及明确的应用和网络体系结构还不常见。需要扩展系统和网络管理平台，以包括边缘位置和边缘功能特定技术。边缘计算解决了许多紧迫的问题，例如高广域网成本和不可接受的延迟。边缘计算拓扑结构将使数字业务和IT解决方案在不久的将来具有独特的优势。 边缘计算和云计算是互补的概念 趋势6:沉浸体验到2028年，用户体验将经历用户对数字的感知方式的重大转变。世界以及他们如何与之互动。对话平台正在改变人们与数字世界互动的方式。虚拟现实（VR）、增强现实（AR）和混合现实（MR）正在改变人们对数字世界的感知方式。这种感知和交互模式的结合转变将带来未来的沉浸式用户体验。这种模式将从一个懂技术的人转变为一个懂技术的人。翻译意图的负担将从用户转移到计算机上。通过许多人的感官与用户交流的能力将为传递细微信息提供更丰富的环境。 VR and AR虚拟现实和现实现实是分开的，但相关的技术。MR扩展了两种方法，以更强大的方式将物理世界结合起来。体验的视觉方面很重要，但其他感官模型也很重要，如触觉（触觉反馈）和声音（空间音频）。特别是在MR中，用户可以与数字和现实世界中的对象交互，同时在物理世界中保持存在。 虚拟现实提供了一个计算机生成的三维环境，它围绕着一个用户，以一种自然的方式响应一个人的行为。这通常是通过一个身临其境的头戴式显示器（HMD），阻止用户的整个视野。手势识别或手持控制器提供手和身体跟踪，并可结合触摸敏感反馈。位置跟踪使一个或多个参与者能够在没有位置的房间中行走。基于房间的系统提供了更深的沉浸感，为多个参与者提供了一种3D体验，或者一个人可以在没有房间的房间里行走。 增强现实是以文本、图形、视频和其他与现实世界对象集成的虚拟增强的形式实时使用信息。它是使用HMD或移动设备呈现的。虚拟世界元素在现实世界背景上的叠加将AR与虚拟现实区分开来。增强现实旨在增强用户与真实物理环境的交互，而不是将它们与实际物理环境分离。这个定义也适用于MR。一般来说，MR使人们能够与虚拟对象交互。 摘译自：https://www.gartner.com]]></content>
      <categories>
        <category>gartner</category>
        <category>趋势</category>
      </categories>
      <tags>
        <tag>科技趋势</tag>
        <tag>gartner</tag>
        <tag>战略研究</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年10大战略性科技趋势3·4]]></title>
    <url>%2F2019%2F06%2F03%2FGartner-2019%E5%B9%B410%E5%A4%A7%E6%88%98%E7%95%A5%E6%80%A7%E7%A7%91%E6%8A%80%E8%B6%8B%E5%8A%BF%EF%BC%883%EF%BC%8C4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[2019年十大战略技术趋势 趋势3:AI驱动开发人工智能驱动的开发探索了将人工智能功能嵌入应用程序的工具、技术和最佳实践的演变。它还探讨了如何使用人工智能创建开发过程中使用的人工智能驱动工具。 这一趋势正沿着三个维度发展： 用于构建人工智能解决方案的工具正在从面向数据科学家的工具（人工智能基础设施、人工智能框架和人工智能平台）扩展到面向专业开发人员社区的工具（人工智能平台和人工智能服务）。 用于构建人工智能供电解决方案的工具本身被赋予了人工智能驱动能力，帮助专业开发人员并自动化与人工智能增强解决方案开发相关的任务。 特别是，支持人工智能的工具正在从帮助和自动化与应用程序开发（AD）相关的功能发展到利用业务领域专业知识进行增强，并自动化更高层次的广告流程堆栈（从一般开发到业务解决方案设计）活动。 趋势4:数字孪生数字孪生是指现实世界实体或系统的数字表示。数字孪生兄弟的实现是一个封装的软件对象或模型，反映了一个独特的物理对象。来自多个数字孪生兄弟的数据可以在多个现实世界实体（如发电厂或城市）中聚合为一个复合视图。对现实世界中的实体或系统进行数字表示的概念并不新鲜。它的传统可以追溯到计算机辅助的物理资产设计表示或个人客户的配置文件。数字双胞胎最新迭代的区别在于： 模型在于它们如何支持特定的业务结果的健壮性 数字孪生兄弟与现实世界的链接，可能实时监控 应用先进的大数据分析和人工智能来推动新的业务机会 与他们互动并评估“假设”情景的能力 在物联网项目的背景下，数字孪生正在引起人们的兴趣。精心设计的数字孪生资产可以显著提高企业的决策能力。它们与现实世界中的对应物相关联，用于了解事物或系统的状态、响应变化、改进操作和增加价值。 摘译自：https://www.gartner.com]]></content>
      <categories>
        <category>gartner</category>
        <category>趋势</category>
      </categories>
      <tags>
        <tag>科技趋势</tag>
        <tag>gartner</tag>
        <tag>战略研究</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年10大战略性科技趋势1·2]]></title>
    <url>%2F2019%2F05%2F25%2FGartner-2019%E5%B9%B410%E5%A4%A7%E6%88%98%E7%95%A5%E8%B6%8B%E5%8A%BF(12)%2F</url>
    <content type="text"><![CDATA[关键发现： AI开启了数字业务的新方向 我们对技术的感知和互动方式正在发生根本性的转变 事物和流程的数字化正在更多的被用于监控、分析和控制真实世界的环境 确定技术趋势并依据对业务的潜在影响排列优先级可以创造竞争优势 建议：通过技术创新进行业务转型的公司架构和技术创新领导者必须： 探索基本上可以通过AI驱动的自主功能为组织内的任何物理设备或客户环境提供支持的方式 与高级商业领袖一起教育，参与和思考他们的战略相关优先事项以及AI可以自动化或增强人类活动的地方 开发和部署混合平台，将对话交互与虚拟，增强和混合现实相结合，以针对目标用例创建身临其境的用户体验 通过开发和优先处理有针对性的高价值业务案例来构建物理事物和组织流程的数字双胞胎，从而支持物联网计划 在量子计算仍处于新兴状态时，了解并监控它。 找出具有潜力的现实问题并评估其对安全的可能影响 战略规划预测到2021年，10％的新车将具有自动驾驶功能，而2018年则不到1％。到2020年，公民数据科学家的数量将比专家数据科学家的数量增长快五倍。到2022年，至少40％的新应用程序开发项目将在团队中拥有人工智能联合开发人员。到2021年，一半的大型工业公司将使用数字双胞胎，使这些组织的效率提高10％。到2028年，存储，计算和高级AI和分析技术将扩展边缘设备的功能。到2022年，70％的企业将尝试使用沉浸式技术进行消费和企业使用，25％的企业将其部署到生产中。到2030年，区块链将创造3.1万亿美元的商业价值。到2022年，超过50％在工业4.0生态系统中合作的人将使用虚拟助手或智能代理与周围环境和人们进行更自然的交互。到2021年，那些绕过隐私要求并且缺乏隐私保护的组织将比遵守最佳实践的竞争对手支付高出100％的合规成本。到2023年，20％的组织将为量子计算项目编制预算，而2018年则不到1％。 分析数字化转型会导致企业不断更新其业务模型。企业领导需要接受并鼓励不断的改变，这也是在未来变化世界中的成功之道。 在未来，所有的智能设备和智能终端会组成一个“智能数字网”，这会成为一个颠覆性的技术趋势，所有的创新型公司都要做好准备应对。智能数字网的三个核心主题： 智能。智能主题探讨了AI，特别强调机器学习，如何渗透到几乎所有现有技术并创建全新的技术类别。 数字。数字主题专注于融合数字和物理世界，以创造自然和身临其境的数字增强体验。 网络。网络主题主要开发人、业务、设备、内容、服务等之间的联系。 2019年十大战略技术趋势 趋势1:自主事物自主事物通过AI来自动化执行原本由人类执行的行为。不同于之前死板的程式化的自动化，自主事物可以更好的在人类环境下进行更自然的交互。 自主物理事物and自主虚拟事物自主物理事物的应用： 巡逻机器人 高级农业 更安全的载具运输 自主虚拟事物的应用： 虚拟个人助理 独立代理 自主能力的范围 人工辅助 部分自动化 条件性自动化 高级自动化 全自动化 自主、智能、协调 Intel在2018年冬奥会开幕式上使用无人机群 迪拜警方准备使用自己部署的无人机盯梢 自主智能汽车可以互相通讯协调以优化城市交通 群智智能助理可以通过集成多终端数据满足复杂需求 多代理之间的自动协调可以是IT操作变得更加流畅和安全 趋势2:增强分析增强分析包括： 增强数据准备。它使用机器学习自动化来增强数据分析和数据质量，协调，建模，操作，丰富，元数据开发和编目。 增强分析。这使得业务用户和公民数据科学家能够自动查找，可视化和叙述相关发现，而无需构建模型或编写算法。 增强数据科学和机器学习。它使用AI来自动化数据科学和机器学习/AI建模的关键方面，例如特征工程，模型选择（自动机器学习[autoML]），模型操作，解释，调整和管理。 赋能民间数据科学家到2020年，民间数据科学家的数量将比专业数据科学家的数量的增长快五倍。 在民间数据科学家之上更多地使用机器学习以及自动化和人工增强模型将意味着更少的偏差。它将减少用户浏览数据所花费的时间，使他们有更多时间根据数据采取最相关的见解。它还将使一线工作人员能够获得更多情境化的分析见解和指导性建议，以改进决策和行动。 行动起来 接受增强分析作为数据化转型策略的一部分 通过增强分析寻找机会 开发一种定位增强分析的影响的策略 摘译自：https://www.gartner.com]]></content>
      <categories>
        <category>gartner</category>
        <category>趋势</category>
      </categories>
      <tags>
        <tag>科技趋势</tag>
        <tag>gartner</tag>
        <tag>战略研究</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Reading Notes] A Service Computing Manifesto: The Next Ten Years]]></title>
    <url>%2F2019%2F05%2F22%2FReading-Notes-A-Service-Computing-Manifesto-The-Next-Ten-Years%2F</url>
    <content type="text"><![CDATA[ABSTRACT这份宣言的主要内容 确定阻碍现实世界中服务计算发展和潜在实现的主要障碍 提出服务计算的研究方向 制定路线图，使服务计算领域能够重新定义自己和 成为社会和经济活动的强大引擎之一。 推荐关注于4个主要研究方向 服务设计 service design 服务集成 service composition 基于众包的信誉 crowdsourcing based reputation 物联网 the Internet of Things BACKGROUND服务计算的定义我们将服务计算（或者称为面向服务的计算）定义为：探索或开发为服务提供广泛支持的计算抽象、计算架构、计算技术和计算工具的学科。 We define service computing (alternatively termed service- oriented computing) as the discipline that seeks to develop computational abstractions, architectures, techniques, and tools to support services broadly. 服务计算的来源在计算的早期阶段，面临的挑战是以机器可读的格式表示信息，该格式由位和字节组成，称为数据。 随着时间的推移，人们对用意义补充数据产生了浓厚的兴趣，从而将其转化为信息。随着计算技术的进一步发展，人们开始在信息中加入推理，从而产生了知识。最近，对更高抽象级别的需求导致了向知识添加行动，从而产生服务的概念。 服务计算的目标服务计算的最终目标是弥合IT和业务服务之间的差距，使IT服务能够更有效地运行业务服务。 The ultimate goal of service computing is to bridge the gap between IT and business services to en- able IT services to run business services more effectively and efficiently. 服务计算的目标是利用服务范例的功能和简单性及其功能和非功能组件来构建模块化软件应用程序，并为选择和组合服务提供更高级别的抽象，从而将其提升到第一类对象状态。 服务计算的相关机构和会议为了自动化组合服务资源，以根据用户的目标和偏好提供定制的IT服务，标准化机构，如万维网联盟（W3C）和结构化信息标准促进组织（OASIS），已经为实施服务系统领导了规范和标准化工作。 服务计算的挑战现有的Web服务标准和技术无法为关键新兴领域的计算需求提供足够的支持，包括移动计算，云计算，大数据和社交计算。这些是IDC命名的第三平台的四项关键技术，目前正在影响全球业务的格局。 服务计算和SOA的区别面向服务的体系结构（SOA）是一种独立于技术的框架，用于定义，注册和调用服务。 服务计算比SOA更广泛，包括对较低级别的服务数据管理和分析的业务流程建模，管理和分析的上层。 SOA已成为服务计算的核心概念，并为实现服务计算提供了基础技术。 服务计算和传统计算的区别 服务计算的驱动因素是将服务计算与技术分离，以实现面向服务的系统，充分利用服务计算的承诺和期望 这项工作强调服务计算对计算新兴趋势的贡献和影响 CHALLENGES IN SERVICE COMPUTING RESEARCH 当前的服务计算研究主要集中在七个问题领域：架构，规范语言，协议，框架，生命周期，服务质量，以及跨越自治企业边界建立信任和声誉。 current service computing research focuses mostly on seven problem areas: architecture, specification languages, protocols, frameworks, lifecycle, quality of service, and the establishment of trust and reputation across the boundaries of autonomous enterprises. 服务计算中经常被忽视的战略挑战是分析为什么服务计算尚未在现实世界中发挥其全部潜力，以及需要采取哪些措施来改变这一点。 一项重大挑战是实现在不同平台上工作的多个组织的无缝合作，以满足消费者的需求。 我们确定了服务计算中的四个新兴研究挑战：服务设计，服务组合，基于群体的声誉和物联网（IoT）。 We identify four emerging research challenges in service computing: Service Design, Service Composition, Crowdsourcing-Based Reputation, and the Internet of Things (IoT). Challenges in Service Design服务设计是关于对服务性质及其关系的正式理解的映射。 现有设计方法： 通常不会考虑到服务系统固有地将自治部件集合在一起这一事实 没有任何全面的理论框架来定义和分析Web上复杂的服务系统 Challenges in Service Composition由于需要对大规模的Web和云服务进行组合，有以下几个挑战： 准确有效地从这些大型存储库中搜索服务正成为一个至关重要的挑战 现有服务选择，组合和推荐方法都是在假设静态数据环境下运行的，这是不充分的 从众多不断变化的设备和服务中选择和组合服务，以实时和上下文感知的方式满足用户需求 基于社会关系的服务构成构成了根本的严峻挑战 Challenges in Crowdsourcing-Based Reputation 众包的质量。鉴于声誉受到若干相关因素的影响，因此强烈需要预测众包声誉的结果。目前尚不清楚这些因素如何影响众包的质量。 众包贡献者的可信度。一些服务用户的意见可能是不公平的，甚至是对特定服务产品的恶意。 测试平台。对设计适当的评估指标以比较服务的信任和信誉模型存在强烈需求。 Challenges in the IoT物联网（IoT）是一个新兴和有前景的领域，它建议将每个有形实体转变为互联网上的一个节点。 物联网提出了两个基本挑战：（1）与事物的沟通（2）事物的管理。 一个挑战是资源有限，传统标准（如SOAP和BPEL）太庞大，无法应用于物联网。 此外，由于架构差异，现有的服务组合模型不能直接用于物联网互操作。与单类型Web服务组件模型（即，服务）相反，IoT组件模型是异构的和多层的（例如，设备，数据，服务和组织）。与传统设置相比，组件的所需功能更具动态性和上下文感知能力。 与服务计算相关的基本物联网挑战包括： 持续维护物联网设备的网络个性和环境。 特别是，物联网事物需要具有反映其物理空间的Web身份和Web表示（例如，Web代理）。 他们还需要在社交，环境，以用户为中心和应用程序环境中进行连接和通信，并且需要维护和管理此类上下文。 不断发现，集成和（重新）使用物联网事物及其数据。 具体而言，物联网环境是一个联合环境，其中事物及其数据，云服务和IT服务（例如，用于数据分析和可视化）通常由具有不同接口的独立提供商以及业务，成本提供。 和QoS模型。 为了提供新的互联网规模的服务，物联网必须（重新）使用他人部署的物联网和其他人为自己的目的收集的数据。 SERVICE COMPUTING RESEARCH ROADMAPService Design服务系统的设计应建立在正式的服务模型之上，以便能够有效地访问具有不同功能的大型服务空间。 服务模型支持不同服务及其操作之间的依赖关系非常重要。 总之，满足上述要求的正式服务模型将成为通过服务提供高效透明的计算资源访问的中心，这是充分发挥服务计算潜力的关键一步。 特别是，服务的三个关键特征至关重要：功能，行为和质量。 功能由服务提供的操作指定; 行为反映了如何调用服务操作，并由服务操作之间的依赖性约束决定; 质量决定了服务的非功能特性。 Service Composition几个研究方向： 大规模的Web和云服务组合。 服务组合研究应扩展到由纯文本描述的非WSDL描述的服务或服务。 大数据驱动的服务组合。当前大数据研究的一个重要主题是开发在线处理数据的算法和模型 基于社交网络的服务组合。大规模社交网络中的服务选择，推荐和组合应该结合社交网络和复杂的网络分析方法以及信任计算技术。 一个有希望的方向是结合记录服务用户与服务数据的交互的社交网络数据，以检测服务之间的隐藏关系并生成潜在的服务组合。可以通过捕获用户个人判断的社交媒体服务来提取反映用户选择和组合服务的兴趣的特定于域的质量特征 云计算环境为部署服务提供了一个有吸引力的选择，因为它提供了潜在的可扩展性和可访问性。 但是，它引入了与以下问题相关的问题： 维护 - 资源不受服务提供商的明确控制。 安全性 - 云可能不在服务提供商的企业边界内。 服务级别协议（SLA） - 资源分配是云提供商的责任。 例如，服务可能不可用，不仅是由于服务提供商的更新，还因为云提供商的更新。 Crowdsourcing-Based Reputation 众包的质量。应进行社会研究，以调查这些利益因素对众包可靠性的影响以及众包贡献者的范围。这两种因素，例如社会关系和个人偏好，可以同时相互影响。 未来的研究应该针对如何模拟两组因素之间的相互关系以及如何将它们整合起来预测它们对众包数据质量的影响。 众包贡献者的可信度。还应探索用于选择具有不同成本和可信赖的众包用户的权衡策略。 Internet of Things物联网研究的新方向在于设备发现和集成领域。一个有趣的方向是多跳连接，它利用人与物之间的相互作用来关联物联网事物。 CONCLUSION服务计算拥有光明的未来，支持新兴计算领域的巨大进步，如移动计算，云计算，大数据，社交计算等。 我们在本宣言中提出，服务计算的潜力远远大于迄今为止所取得的成就。 我们为将服务计算提升到创新的新高度铺平了道路。 为了开拓进取，我们做出了一个重要的声明，即，要使服务计算范例取得成功，就需要将其与当时的技术分离开来。 挑战可能很困难，但收益很大，没有理由为什么雄心勃勃的研究议程不会给计算机科学和社会带来巨大的好处。]]></content>
      <categories>
        <category>Reading Notes</category>
        <category>Service Computing</category>
      </categories>
      <tags>
        <tag>Service Computing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转]109个数据指标，全方位剖析零售业]]></title>
    <url>%2F2019%2F05%2F11%2F109%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%8C%87%E6%A0%87%EF%BC%8C%E5%85%A8%E6%96%B9%E4%BD%8D%E5%89%96%E6%9E%90%E9%9B%B6%E5%94%AE%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[原文链接：http://www.gzjundian.com/show-19-93-1.html 如何能让你的分析报告真正为企业带来价值？如何拉近一套数据与实际生活生产之间距离，做到报告从数据中来、分析到业务中去？今天我们就零售行业中涉及到的三大块业务，探究如何为零售企业做切实有用的分析报告。 众所周知，人、货、场是零售业基本的思维模式。无论是线上还是线下，人、货、场都是零售营运的核心三要素。我们今天的探讨就从零售行业的人、货、场三个维度开始思考。 人包括店铺员工、顾客和第三方人员等；货泛指商品；场指卖场、电子商务的销售平台、渠道等，因此，零售业常用的分析指标有： 人货场只是第一个层次，员工、顾客、卖场、商品等为第二层。 一、“人”的部分1.销售指标【成交率】=成交顾客数÷客流量×100% 成交率和店员和销售技巧、产品陈列、产品销售价格、促销价格等都有关系。但是在产品、促销状态等都一致的情况下，成交率就只和店员的销售技巧有关了，所以这个指标可以用来判断店铺员工的销售能力。 【完成率】=销售完成数÷目标数×100% 这是一个判断销售目标进度的一个指标，在人货场三个领域都可以用到。 2.服务指标【平均成交时长】=每一位顾客成交的时间总和÷成交顾客数 这是一个考察店铺员工效率的指标。一般还需要和客单价结合起来看会比较客观（可以做四象限），用最短的时间成交最高的金额，这样员工一般认为都是最优秀的员工。 【平均接待时长】=接待每一位顾客的时间总和÷接待顾客数 目前需要店铺手动计算这个指标。还有一个指标和平均接待时长类似，就是顾客平均停留时长。区别是前者是从开始接待顾客到离开店铺的时间段计算时长，后者是用顾客进门到出门的时间段来计算的。这两个指标同样不仅仅和“人”有关，还与“场”“货”有关。对于零售店铺来说大部分时候是希望顾客的停留时间越长越好。 【投诉率】=投诉的顾客总数÷顾客总数×100% 3.管理指标【定编满足率】=实际员工总数÷标准配置人数×100% 这是考核企业招聘能力强弱的一个指标，同时它也是一个内控指标。定编满足率太低势必会影响效率，太高且超过100%又会造成人效的浪费。定编满足率还可以细分为部门定编满足率、普通员工定编满足率、管理层员工定编满足率等。 【员工流失率】=某段周期内流失员工数÷（（期初员工总数+期末员工总数）÷2）×100% 员工流失率分月流失率、季度流失率、年流失率等。处在不同周期的流失率是不能直接对比的。人事部经常用的是员工离职率，员工流失率和员工离职率有一点点区别，员工离职指正常人才转移，而员工流失包含不正常人才流失。 【工资占比】=企业支付的员工工资总额÷销售额×100% 4.顾客指标【客单价】=销售总金额÷有交易的顾客总数 一般用成交总笔数来代替顾客总数，理论上这两个数字是一致的，但是顾客经常会出现逛一次商场多次开单交易的情况，所以成交笔数实际上是大于等于有交易顾客数的。客单价既可以反映顾客的质量，也可以反映店铺员工的销售能力，还可以反映店铺的商品组合等。 【件单价】=销售总金额÷销售总数量 【连带率】=销售总数量÷成交总单数 连带率有不同的称谓，例如附加值、效益比、平均客件数、购物篮系数等。连带率反映的是顾客每次购物的深度。对于超市来说，除了分析常规连带率之外，还可以分析单品连带率、品类连带率，连带率越大说明该单品或品类越重要，需要在陈列、促销、库存管理等方面特别关注。百货行业还可以统计叫品牌连带率的指标，即计算顾客每次购物时平均消费几个品牌的产品。 5.会员指标【新增会员数】=期末会员数—期初会员总数 如果将会员看成是企业的财富，新增会员就是在不断地积累财富。大部分零售企业会把这一项作为店铺员工KPI考核指标之一。新增会员数的一个附加指标是未办卡率，统计那些达到会员办卡条件却没有开新卡的顾客占比情况，这个指标可以反映店铺开新卡的能力以及顾客对品牌的喜好程度，这是一个分析指标，不建议作为考核治疗。 【会员增长率】=某段时间内新增会员数÷期初有效会员数×100% 会员增长率是体现企业会员增长速度的一个指标。 【会员贡献率】=会员销售总金额÷销售总金额×100% 会员贡献率不是越高越好，在每个企业会有一个合理的区间，太高就显得新增顾客太少，增长被局限了，太低则没有稳定的销售来源。行业不一样这个区间段也会不一样，店铺间也会不一样，例如商业区的店铺和写字楼、社区店铺的会员贡献率都是不一样的。 【有效会员数】 【有效会员占比】=有效会员数÷累积会员数×100% 会员总数多不一定强，有效会员数多才是硬道理。有效会员就是满足一定贸易条件的会员。随着企业的发展，必然会存在很在一段时间内没有交易过的会员，这些会员实际上已经没有任何的价值了，需要在分析中剔除出去，否则会员分析也没有意义。有效会员的贸易条件一般根据时间和交易量来设定，例如在12个月内必须有至少1次消费，6个月内必须有不少于3次消费记录等，这两个设定标准需要结合顾客的消费频率来定，行业不同标准也会有差异。 【会员回购率】=某段时间内有交易的老会员数÷期初有效会员总数×100% 会员回购率一般用在月、季和年度的分析上，是衡量顾客忠诚度的一个指标，严格地说这是一个老会员的回购率公式，因为期间新增会员的回购不包含在其中。 回购率和回头率常被误解为一回事，其实会员回购率和会员回头率是有区别的，回头率公式中的分子应该是某段时间内到达过店铺的会员，他们不一定实施了购物。对于店铺来说，先得让顾客回头，其次才是回购，所以这个两个指标是有先后顺序的。没有高的回头率，哪来的高回购率，所以零售商们都在想尽办法促使会员顾客高频次地回头。 【会员流失率】=某段时间内流失掉的会员数÷期初有效会员总数×100% 这个指标反映了会员顾客的流失速度，也反应了企业营运现状，它和会员增长率是一对相向指标，建议每月都追踪这两个指标。会员流失有它合理的一面，例如对定位在20~30岁的服装品牌来说，顾客年龄变大自然就会流失，再如对超市来说，如果顾客搬家了，流失也是合理的。 会员流失率反应了顾客总量的流失情况，却没有办法反映出流失顾客的质量，流失掉一个客单价为300元和流失掉客单价为3000元的顾客显然不能划等号。这就衍生出一个新的指标，相对会员流失率，公式如下： 【相对会员流失率】=某段时间流失的会员数量÷期初有效会员数×流失率权重值×100% 【流失率权重值】=流失会员的平均客单价÷有效会员的平均客单价 【会员回购频率】 【会员回购频率1】=某段时间内所有会员消费次数÷（期初有效会员总数+期中新增会员数） 【会员回购频率2】=某段时间内所有老会员消费次数÷期初有效会员总数 该指标反映会员顾客在某个时间段内的消费频次，分析这个指标选取合适的时间周期很重要，时间周期太短，这个值基本上就接近为1.0，没有丝毫意义。服装专卖店、手机专卖、电器专卖等可按6或12个月为一个滚动周期，百货商场一般用3或6个月为一个滚动周期，超市可以按1或者3个月来滚动分析。3个月为一个滚动周期并不是数一个季度才分析一次，而是每个月都可以分析。 【会员回购频率3】=某段时间内所有会员消费次数÷期间有交易的会员总数 【会员回购频率4】=某段时间内所有老会员消费次数÷期间有交易的老会员总数 这4个公式各有侧重，公式1或2侧重于研究回购频率的趋势，公司3和4侧重短期会员购物行为分析，零售企业在实践使用时应该以老会员的分析为主。 【平均年龄】=某个事件点会员年龄总和÷有效会员总数 平均年龄是衡量品牌定位的一个标准，不过这个指标收数据源的影响非常大。有很多顾客不愿意提供自己的私人信息，还有就是终端店员不负责任地录入数据，所以在系统中很可能看到上有古稀老人，下有婴儿的年龄数据。分析平均年龄时需要剔除这些异常数据，否则那些90岁以上的顾客就足以把平均年龄拉大好几岁。对年龄的扩展分析是将顾客年龄分段分析，就是年龄分析。平均年龄属于对顾客基础信息分析的范畴，这个范畴还包括性别、职业、地域、收入等。 二、“货”的部分正如“人”“货”“场”是零售分析的基本思维模式一样，商品分析也有它的基本模式，这就是“进”“销”“存”，“进”即为采购环节，“销”自然是销售环节，狭义的“存”指商品库存管理环节，广义的“存”指整个商品的供应链管理。人货场是一个平行关系，而进销存却是一个又先后顺序的三角关系，前者是基于业务的分析管理，后者是基于商品的流程管理。大部分零售业的POS系统都是基于进销存的一种软件系统。 某种商品的库存太大、占用资金，我们常常理所当然地认为是采购进货不合理，进得太多，所以采购部经常背黑锅。其实销售环节和供应链环节都会影响库存，例如商品在卖场陈列不合理，仓库发货不及时，盘点错误造成系统显示有库存而实际库存为0等。所以分析商品的问题务必从进销存三个维度进行思考，不能一遇到问题就武断地认为是进销存某个环节的问题。 商品的分析指标很多，常用的如商品的折扣率、动销率、周转率等，还有商品的三度（广度、宽度、深度）等。一般来说大店看重商品的周转，小店看重商品的单词利润，线上看重商品的折扣，线下侧重商品的库存。大家的侧重点不同，不过总体来说商品的分析如图所示。 1.采购环节（1）采购三度【广度】 广度=采购的商品品类 广度比=采购的商品品类数÷可采购的商品总品类数×100% 广度关系到商品品类多样化，很多追求消费者一站式购买的卖场就是追求大广度。例如一个服装专卖店，公司当季商品有20个品类，买手实际采购了16个品类，则广度为16，广度比未80%。再比如一个中型超市有200个品类的商品在销售，可供销售的总品类数是300个，则广度为200，广度比为67%。商品的广度体现了商品的丰富程度。广度也不是越大越好，这和零售店铺的消费群体有关，也和营运成本有关，所以最佳的广度是指用最经济的成本且最能满足目标消费群体绝大部分需求的值。 【宽度】 宽度=采购的SKU总数 宽度比=采购的SKU总数÷可采购的商品SKU总数×100% 商品的宽度代表了商品的丰富且可供选择的程度，宽度越大的店铺消费者挑选的余地就越大。而宽度比则是反应和竞争对手宽度、自己目标宽度或上游供应商宽度的对比程度。例如对于一个化妆品专卖店来说，店铺共有1000个SKU商品在销售，而最大的竞争对手同期销售的商品是1500个SKU，则该专卖店商品的宽度为1000，相对于竞争对手的宽度比67%。由于资源局限性，大型超市等一般会限定商品的宽度值，所以就会出现每新增一个商品必须要剔除一个旧品的规定。电子商务网网站则相对宽松一些，他们的陈列没有实体零售店铺的空间限制，所以理想状态下宽度是可以做大无限大。 【深度】 深度=采购的商品总数量÷采购的SKU总数 深度比=深度÷采购目标深度×100% 深度是指平均每个SKU的商品数量，它的意义代表了商品可销售的数量的多少，比如某个服装专卖店某次采购了400个SKU的商品，一共1000件，则深度为2.5。深度越大越不容易缺货，但是也可能会造成高库存。 （2）覆盖度（也叫铺货率）覆盖度=有某款或品类产品销售的店铺数÷适合销售该产品的总店铺数×100%商品的覆盖度指标适合连锁性质的公司使用，它是衡量商品铺货率的一个指标，需要注意覆盖度公式的分母不是总店铺数，而是适合销售该产品的总店铺数，二者差距较大。一般来讲，覆盖度越大商品的销售就会越好。 （3）采销匹配度采销匹配度不是一个具体的指标，它实际上是一种分析方法。通过对比品类、型号、价格等方面在某段销售周期内采购和销售的比重来判断商品销售进度的一种方式。 2.供应链环节（1）服务指标【订单满足率】=订单中能够供应的商品数量总和÷订单商品数量总和×100% 例如物流部收到5张订单供1000件商品，由于缺货等原因实际可以发出的商品只有920件，则订单满足率就是92%。这是一个反应仓库缺货状态的指标，对于连锁企业来讲，100%的订单满足率是一个理想状态，一般都达不到。如果真能够做到100%满足率，意味着不但需要预测非常准，还需要增加更多库存来满足突发订单，这样的代价就是仓储成本增加，资金成本增加，这也是一种资源的浪费。 【订单执行率】=能够执行的订单数量÷总订单数量×100% 某天物流部收到100张订单，但是其中10张订单由于缺货或其他原因不能执行，则订单执行率90%。仓库缺货，物流配送（有货但是送不出去）等都会影响这个指标。 订单满足率和订单执行率的区别是，前者计算的是商品数量的满足情况，后者计算的是订单数量的执行情况。后者常常被很多企业作为订单满足率，这其实是不严谨的。订单满足率侧重用来衡量商品库存状况，订单执行率侧重用来衡量储运状况。 【准时交货率】=准时交货的订单数÷能够执行的订单总数×100% 准时交货率是一个反应供应链效率的指标，需要注意的是分母并不是订单总数，而是能够执行的订单总数，对于那些不能执行的订单去计算他们的准时交货率是非常滑稽的一件事。计算准时交货率的前提是先要明确什么是“准时交货”，24小时？48小时？还是根据距离远近区别对待？ 【订单响应周期】=系统中收货时确认的时间-系统中下订单的时间 一张订单的处理是从客户在系统中下订单（对于非系统下单的情况，就应该以收到订单的时间来准）开始到确认收货这样的一个完整的流程，这是一个反应供货效率的指标，一般计算平均订单响应周期。需要注意的是，随着新客户的不断增加、客户类型的变化等，平均订单响应周期自然会发生变化。所以平均订单响应周期变长和供应链效率降低并不能划等号，要进一步分析数据突变的原因。 在实际分析过程中还需要结合订单区域、产品类型、客户类型等进行详细分析。 （2）管理指标【库存周转率】 库存周转率1=出库数量÷（（期初库存数量+期末库存数量）÷2） 库存周转率2=销售数量÷（（期初库存数量+期末库存数量）÷2） 公式1是从供应链管理角度的指标，公司2是对公司销售周转率的衡量，二者是有区别的。一件商品一般只会被销售一次，但是因为退货回仓库的原因而会有大于1次的出库情况。“（（期初库存数量+期末库存数量）÷2）”这部分也可以用评价库存来代替，就是每月的平均库存。用平均库存的好处是营运人员投机取巧拉高周转率的难度加大，有的营运人员会在期初和期末这两个时间节点故意压低库存，甚至是牺牲销售的前提下压低节点库存，如果计算12个月的平均库存则投机难度就非常大了。 【物流成本占比】=物流成本÷（（期末库存金额+期中库存金额）÷2）×100% 广义的物流成本包括仓储成本、运输成本、管理成本等。狭义的物流成本仅仅指运输成本，狭义的物流成本占比就是运输成本和所运输的商品总值的比。 【客户投诉率】=客户投诉率=客户投诉订单批次÷订单总数×100% 这个公式很理解，但是在实际操作中缺失错误百出。问题出在公式的分子和分母的不对等上面。 （3）库存指标【期初库存、期末库存、平均库存】 平均库存=（期初库存+期末库存）÷2 年平均库存还可以直接取每月末库存的平均值，一般财务部习惯用期初加期末除以2的计算方法，销售营运部喜欢用平均库存的算法。 【库存天数】=期末库存金额÷（某个销售期的销售金额÷销售期天数） 库存天数是一个极为重要的库存管理指标，是有效衡量库存滚动变化的量化标准，也是用来衡量库存可持续销售时间的追踪指标。 我们可以用库存天数来判断店铺是否有缺货的风险，某个店铺的安全库存天数是45天，如果实际库存低于这个值则有缺货风险，反之则表示库存过大。这个指标既可以计算整体企业的库存天数，也可以计算每个品类或单品的库存天数，在分析具体问题的时候，常常需要结合起来看。另外，有些企业喜欢用库存周数的概念，实质是一样的，将库存天数除以7即为库存周数。一般来讲快速消费品行业使用库存天数，耐用消费品使用库存周数。 【库销比】=期末库存金额÷某个销售期的销售金额×100% 库销比的销售周期一般取月，也就是月库销比，当然也可以取周，如果是周库销比实际上就是和库存周数一个概念。月库销比在年度同比的时候是有参考价值的，但是在环比时就有问题了，因为每个月的天数是不一致的，有28天、29天、30天和31天4种情况，销售期不同销售金额就会不同，这样的月库销比实际上是没有可比性的。而库存周数和库存天数就不存在这个问题，所以我一般很少用这个指标。 【有效库存比】=有效库存金额÷总库存金额×100% 要计算有效库存比首先需要定义有效库存的标准，有效库存是指能给门店带来销售价值的商品库存，也就是能产生销售贡献的商品库存。从定义上看残次商品、过季商品和没有销售的商品都不属于有效库存商品。不过在实际上的分析过程中有效库存的确会复杂很多，首先需要剔除残次商品、过季商品、一段时间内没有销售的商品，然后再确定一个标准值将有销售的商品分成有效库存和无效库存，这个标准一般以周销售量或月销售量来衡量，并且渠道不同标准是不一样的。 确定有效库存的标准可以利用二八法则来辅助计算，占总销售20%的商品的平均销量值即为有无效库存的分界线。当然也可以人为确定这个分界线的值。 3.销售环节（1）商品指标【货龄】=商品的年龄 对于有保质期的商品，例如食品、饮料等，货龄是从生产日期开始计算的，对于没有严格保质期或有效期的商品，例如服装、手机等，货龄应该是从开始上架销售的日期开始计算的。分析货龄目的一是防止商品过期，二是作为制定商品价格调整的依据。货龄越大，库存越高的商品就是价格调整的首选。 【售罄率】=某段时间内的销售数量÷（期初库存数量+期中进货数量）×100% 售罄率是检验商品库存消化速度的一个指标。一般采取期货制订货的企业，如鞋服行业用得比较多，可以随时补货的快速消费品一般不同这个指标。特殊时期的囤货制也可以使用售罄率这个指标，例如包销或买断销售都属于囤货制。根据销售期的不同，一般有周售罄率、月售罄率、季售罄率、季末售罄率等。季末售罄率指整个商品消化期的销售数量和商品的总到货数量的比值。 【折扣率】=商品实收金额÷商品标准零售价金额×100% 商品的折扣率直接影响到企业的利润水平，是企业的生命线，但遗憾的是很多企业只是在财务报表中才有这个数据。财务报表只是一个结果，折扣率更应该是一个营运指标，需要定期追踪它是否正常、分析趋势是否向坏等。 【动销率】=某段周期内销售过的商品SKU数÷（期初有库存的商品SKU数+期中新进商品SKU数）×100% 动销率的统计周期一般是周、月、季度，分析的对象可以是品类、类别、SKU等。动销率属于一个追踪和管理指标，一般传统零售比较重视这个指标，动销率都比较高。但是电子商务由于追求长尾效应，动销率都比较低，不过最近有些电子商务也开始重视这个指标了。 【缺货率】=某个周期内卖场有缺货记录的商品数÷（期初有库存的商品数+期中新进商品数）×100% 对于供应链的缺货分析建议使用【订单满足率】，这里的缺货率主要是针对销售端的缺货，适用于采购部和销售部。注意这个缺货率是分析缺货的商品比率，不是缺货的数量或金额多少（缺货数量和缺货金额很难量化）。缺货率比较难以统计的是缺货记录，POS系统弱的门店只能靠人工统计，软件系统好的客户可以通过设置商品零库存状态用来自动判断是否缺货。库存为0一般是缺货，但是库存大于0的商品也可能是“缺货”状态，因为这里的库存很可能是残次或虚假库存，实际可供销售的库存为0，这种情况比较难以统计，需要人工加系统的方法来识别。缺货率中的销售周期最短可以是1天，最长不建议超过1个月。在计算年平均缺货率的时候可以计算月缺货率的平均值。 （2）结构指标【品类结构占比】=某品类销售额÷总销售额×100% 【价位段占比】=某价格段销售额÷总销售额×100% 【正价销售占比】=正价商品销售额÷总销售额×100% 正价商品为标准零售价的商品，与之对应的是折扣商品或特价商品。正价商品销售占比越高，企业利润越高。对于促销频率高的行业，以及有议价空间的行业（如手机专卖店）等该指标显得尤为重要，它是员工销售能力和企业管理水平的综合体现。但遗憾的是很多企业只重视折扣率，而忽视了这个指标。 （3）价格体系指标【商品现值】 商品现值就是商品当前被消费者认可的价值。一台手机刚出来时售价是4000元，一年后消费者可以接受的零售价只有2800元，这个2800元就是这台手机目前的现值。随着时间的流逝，新机型的推出，手机现值还会不断变化着。商品价格会随着时间流逝而变化的商品适合用商品现值的概念来管理，例如服装、手机、食品等。 【价格弹性指数】 价格弹性指数是商品价格变化1%时，商品销量变化的百分比。例如某款商品价格下降1%时，销量就上升5%，则价格弹性指数就是5.0%。价格变动时不光会影响到自身的销量变化，还会影响到竞争对手的销售变化。所以还有一个品牌间的价格弹性指数，品牌A相对于品牌B的价格弹性指数为4.2，这表示品牌A的价格每下降1%便能够从品牌B那里抢到相当于品牌B4.2%的销量，也就是品牌B销售会下降4.2%。确定商品的价格弹性指数最好的方法是最随机测试。 （4）畅滞销分析【前十大销售及占比】 前十大销售就是在所有商品中销售额或销售量最好的十个商品的总销量，前十大商品占比也就是他们的销售额或销售量占总销售量的比重。这是一个常规分析指标和追踪指标，除了对总销售进行前十大排名分析外，还可以对具体的类别进行同样的分析。 前十大商品销售占比越大，商品销售就越集中，销售管理更容易，但是销售风险也会加大。很多电子商务的卖家非常追求爆款，恨不得前三个商品就能占到公司总销售的80%以上。爆款一般综合毛利都偏低，且一旦生产或物流环节出现状况，对企业的销售影响可能是致命的。 【前十大库存及占比】 和前十大销售及占比概念一样，只是前者是基于销售，后者是基于库存。这是一个库存管理指标，同样是看趋势，看数据是否异常。 【滞销品销售占比】 滞销商品销售占比指的是滞销商品占总销售的比重，同理还可以演化出一个滞销商品库存占比。 4.售后环节【退货率】 退货率1=某个周期内退货数÷总销售数×100% 退货率2=某个周期内退货单数÷总销售单数×100% 退货率公式非常简单，不过它和【客户投诉率】有一个同样的问题，就是本周期内的退货数并不一定来源于本期内的销售即不含在分母中。处理方法同客户投诉率一样有三种方法：综合处理法（不考虑退货单的来源问题），追踪来源法（将退货单还原到发货期进行分析），剔除法（将非当日退单剔除再计算退货率）。 【特殊服务率】=特殊服务的顾客÷总销售顾客数×100% 有些零售店铺为了提高顾客的体验感，会搞一些特殊的服务活动，例如有的服装专卖店有免费熨洗服务，有些电器商场有以旧换新的服务等，这个指标就是用啦检验这种服务效果的。 【残损率】=残损商品数÷商品总数×100% 残损商品会影响企业和门店的销售和利润，残损率不仅仅是一个分析指标，它更应该是一个追踪指标，并且还应该根据残损商品的来源进行分析，找到残损的主要原因，是仓储残损率高，还是销售渠道残损率高等。 三、“场”的部分1.销售额【时段、日、周、月、季度、年】 月销售额指标、季度销售额指标、年销售额指标这是最常用且和绩效挂钩的硬指标。日和时段指标往往不受管理层重视，其实这是不合理的。零售行业的销售是靠一个个时段、一天天追出来的，没有基础指标的完成，谈何月、年指标的完成？ 【预测额】 一般分为【日销售预测额】、【月销售预测额】和【年销售预测额】，日销售预测在大型百货商场、超市、电子商务的销售中经常使用，对日销售进行预测，只需要根据历史数据中每日各个时段的销售百分比就可以计算出来。月和年的预测，前面已经讲解过了。 2.追踪指标【进店率】=进店人数÷路过人数×100% 进店率公式并不难，难的是如何提高进店率，此时各位又可以搬出人货场的思维模式来操练一下。进店率有个系统误差，就是店铺工作人员的进出会影响精度，可以统计工作人员每天大致的重复进店次数然后在进店人数中扣除。 【上楼率】=本层向上的顾客数÷进入本层的顾客数×100% 有5000名顾客进入首层，总共有3000名顾客上到二层及以上楼层，则一层的上楼率为60%。上楼率对多层经营的卖场来说是一个非常重要的指标。 【接触率】 随着科技的发展，管理更多精细化，接触率越来越受零售商重视，通过它可以深层次地了解顾客的购买行为。接触率就是消费者和商品的接触比率。又可以分为试穿率、试用率、触摸率等。 （1）【试穿率】=试穿顾客数÷进店人数×100% 这个指标常用语鞋服行业，目前还没有发现有仪器能监控此指标，大多靠人工统计，需要注意的是同一个顾客无论试穿多少次都只能统计一次。 （2）【试用率】=试用顾客数÷进店人数×100% 这个指标常用于化妆品、食品等行业，如果是封闭销售（例如专卖店）则用进店人数作为分母，不过这些行业大多在超市和百货商场开放式销售，所以进店人数可以转换为有接触的顾客数（例如和促销人员有语言交流的或者是驻足一段时间的顾客），绝对不能轻易用路过人数。 （3）【触摸率】=触摸某商品的顾客数÷路过某商品的人数×100% 触摸率反应商品外观被关注的程度，目前借助一些视频设备可以自动采集这个数据。一般来说某商品的触摸率和成交数量成正比，但是有时候触摸率很高，但是交易很低，作为管理者可能需要分析这种现象产生的原因，为什么消费者有冲动而无行动，出现这种情况很大可能是价格原因。 【成交率】=成交顾客数÷进店人数×100% 【完成率】=完成数÷目标数×100% 完成率根据统计时间段的不同又可以分为实时完成率、滚动完成率、累积完成率、预测完成率。 【大宗交易占比】=大宗购物金额÷总销售额×100% 大宗交易需要企业自己定义何为大宗交易，例如超市可定义单笔成交额大于1万为大宗交易，化妆品和服务专卖店可以定义每次购物数量大于10件为大宗交易等。之所以要监控大宗交易，是因为大宗交易中藏着很多见不得人的交易，而这些交易对渠道和品牌都是伤害。现在很多百货公司的团购部俨然变成了网购批发入口。 很多服装品牌为了维护价格的统一性，会严格控制向非直接客户的发货，而很多网络销售的店主没办法直接从品牌商进货，于是他们选择在店铺做大型促销的时候从零售店铺大量采购，这里面大多会有里应外合的配合，甚至很多零售百货公司会有专人来促进这种交易，大家各取所需。对于很多大型超市，为了冲业绩，采购人员会伙同供应商做虚假交易，首先由超市向供应商下一张大订单，供应商也会发货，不过这批货不会进入超市仓库（采购人员会协调仓库人员做虚拟入仓），直接会以较低的价格卖给如批发市场等渠道，最后采购人员再用这批货款从超市将这批已经不存在的货买出来，这样所有流程走完，采购和供应商都收获了销售额。 3.分析指标【增长率】=增长数÷基础数×100%=（报告期数-基础数）÷基础数×100% 基础数的选择有三种情况，基础数为同期的数据则是同比，基础数为上一个周期的数据则为环比，和2013年9月的销售额对比就是环比，和2013年1月对比为定基比。这三种情况分别对应同比增长率、环比增长率、相对增长率，前两者是用得最多的。 同比增长率中经常使用同店同比增长率（以下简称同店同比）的概念，即本期和同期在对等条件下（相同的店铺）进行对比。同比增长率体现了企业总体的增长情况，同店同比则可以看出企业绝对增长情况。很多企业的增长率非常高，但是大部分增长都来源于新开门店的增长，靠新开店铺的增长是不可能长期持续的。 4.效率指标【坪效】 【销售坪效】=销售额÷店铺面积 【利润坪效】=利润额÷店铺面积 坪效是反映店铺单位面积产出的指标，常常纳入KPI考核项目。坪效的使用需要注意已下几点： （1）计算坪效的最小周期是月，完全没有必须要去计算周、日坪效 （2）如果店铺面积、位置等状态没有发生变化，销售坪效一定和销售成正比，没有必要再去分析坪效趋势。 （3）坪效的对比具有强弱对比性，同一个商场同一楼层的同品类商品具有强对比性，不同品类的对比性会稍微弱一些，不同楼层的不同品类对比又更加弱。同一个商圈的同样业态对比性强，不同的商圈同样业态对比稍弱，不同的商圈不同的业态有可能根本就没有可对比性。同一品牌专卖店在一线城市和三线城市的坪效对比性也不强。所以不要轻易以坪效论营销。 （4）坪效另一个意义在于店铺面积、位置发生变化后进行前后差异的对比分析。 （5）有的企业将坪效用在新开门店销售预估的使用上，这是可以的，但是一定要注意可比性。 【人效】 【销售人效】=销售额÷店铺面积 【利润人效】=利润额÷店铺面积 人效反应的是单人产出，它常常用来管理店铺的人力资源配置、人力成本核算等。 【每平米租金】=租金÷面积 这是用来判断店铺租金相对高低的一个指标。包括每平米日租金、每平米月租金、每平米年租金等 【租金倍率】=销售额÷租金 租金倍率是衡量投入1元租金能产生多少销售额的一个指标。每平米租金由于城市、商圈等差异，没办法直接对比，而租金倍率由于考虑到租金产生的效益则可以直接对比。 5.竞争状况【市场占有率】 也称市场份额，是指一个企业的销售量或销售额在同类市场产品中所占的比重，它直接反应了消费者对商品的喜好程度，同类市场是一个变化的值，既可以是广义的总体市场，也可以是企业的目标市场，甚至可以是某个商圈或商场。例如含氟牙膏可以和牙膏对比，也可以和含氟牙膏对比，甚至计算它在家乐福或沃尔玛超市中的市场占有率。正因为标准的多样性，市场中才充斥着各种号称自己市场占有率第一的品牌。这个指标一般通过市场调查获得。 【竞品指数】=本公司销售额/量÷竞争对手销售额/量 竞品指数是对市场占有率的一种简化，因为我们大部分时间没有办法统计出同类市场的销售数据，所以只能锚定其中一个或几个对手的数据对比。通过分析竞品指标我们也能大致了解自己品牌的市场占有率走势。 【平均排名】 竞争对手的销售数据也不是很容易拿到的，但是每个商场自己品牌的排名值却比较容易到手，这时就可以计算品牌间的平均排名值，通过分析平均排名的变化也可以侧面了解自己的市场占有率情况。平均排名常常被鞋服、化妆品等行业用来作为对店长、销售主管、区域经理等的考核指标。 6.促销指标【费销比】=促销费用金额÷促销期间产生的销售额×100% 【目标完成率】=促销期间销售完成数÷促销目标×100% 【同比增长率】=同比增长数÷同期销售额×100% 【促销爆发度】=（促销期间的平均权重销售额-促销后的平均权重销售额）÷促销前的平均权重销售额×100% 【品牌参活度】=参与促销活动的品牌数÷卖场总品牌数×100% 这个指标常常用在百货和超市的促销活动准备期，用来衡量营运经理促销活动时的执行力。对于品牌商可以将此指标修改为单品参活度，例如公司一共有200个SKU产品，五一期间有40个SKU做促销，单品参活度即为20%。十一促销有50个SKU参与，但是总SKU为300个，单品参活度反而降低为16.7% 【会员参与率】=参与促销活动的会员数÷有效会员总数×100% 促销活动前我们一般会通过邮件、短信、微信、电话等手段通知会员顾客，而会员参与度就是用来评估这些手段效果的一个指标。 7.渠道扩展【净开店率】=（开店数-关店数）÷期初店铺数×100% 【渠道结构占比】=该渠道销售额÷总销售×100% 渠道结构分析是销售分析中最常见的一种分析方式，也是著名的营销4P理论中的一个P（place）。 【重要客户占比】=重要客户销售额÷总销售额×100% 重要客户如何定义是这个指标的关键，有如下几种确定重要客户的方法供参考： ①以销售额的前N名客户作为重要客户，例如前十大客户等 ②根据二八法则，以总销售额80%的客户作为重要客户 ③根据ABC分析法以A类客户作为重点客户 ④根据企业未来战略制定重点客户 单看每个月的重要客户占比没有太大的意义，需要连续观察该数据的走势才有判断的依据，同时需要注意不能经常更改重要客户名单。 四、财务-部分1.销售利润率【毛利率】=（销售收入-营业成本）÷销售收入×100% 【纯毛利】=（销售收入-营业成本-费用）÷销售收入×100% 【交叉比率】=商品毛利率×商品周转率 商品周转率=销售收入÷（（期初库存值+期末库存值）÷2） 毛利率大，周转次数高的商品是优质产品，但是这种商品是比较少的。很多商家采取薄利多销的策略实际上就是牺牲部分商品的毛利率，从而换取较高的周转率。交叉比率一般以季度、半年、年为计算周期。 2.回款指标【回款（金额）达标率】=回款金额÷欠款金额×100% 【回款（客户）达标率】=回款客户÷欠款客户×100% 回款考核中的金额达标率和客户达标率两个指标是孪生兄弟，谁也离不开谁。前者确保回款金额的重要性，后者确保回款客户的普遍性。有的企业只考核回款金额达标率，这就有可能造成一些小额欠款客户的款不被收款人员关心，因为对金额回款率的影响极小。 3.贸易条件【联营扣率】 联营扣率是百货公司为了确保自己的经营利润而和商家合同约定在销售收入中扣除的比率，例如商场某品牌的联营扣率是23%，意味着在商场结款时只能结到销售收入的77% 【租售比】=租金÷销售额×100% 对品牌商来说租售比可以和联营扣率进行对比分析，都是为了取得经营权所需要付出的代价。前面谈到的租金倍率指标实际上是租售比的倒数。 这是个竞争不断加剧的时代，我们必须更加专业的利用数据。数据并不是人们最终需要的东西，他们需要的是信息，是对未来发展的洞察力。 作为数据分析师，最怕你的分析报告没有产生价值，本文的指标可以帮助你在分析零售数据的时候，提高对数据的认识，并真正帮助企业提高运营管理深度。 除此之外，如何从数据中发现商业规则、洞察消费者行为、量化商业价值，都需要数据分析师们拥有能融合商业理解、数据分析并具备从海量数据中发现知识的能力。希望本文章能作为大家学习零售数据分析指标的小手册，随取随用。]]></content>
      <categories>
        <category>零售业剖析</category>
      </categories>
      <tags>
        <tag>零售</tag>
        <tag>零售业</tag>
        <tag>数据指标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4小时java入门]]></title>
    <url>%2F2019%2F05%2F07%2F4%E5%B0%8F%E6%97%B6java%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[译自：https://learnxinyminutes.com/docs/java/ ps：好多类都写到一起了，自己要运行的话记得写到不同的java文件中哦 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854// 导入java.util包中的ArrayList类import java.io.BufferedReader;import java.io.FileReader;import java.math.BigDecimal;import java.math.BigInteger;import java.util.*;// 导入java.util包中的Scanner类// 导入java.security包中的所有类import java.security.*;import java.util.function.Supplier;public class LearnJava &#123; // 要运行一个java程序，必须要有一个main方法作为入口 public static void main(String[] args) &#123; /////////////////////////////////////// // 输入/输出 /////////////////////////////////////// /* * 输出 */ //通过 System.out.println() 来输出一行数据 System.out.println("Hello World!"); System.out.println( "Integer: " + 10 + " Double: " + 3.14 + " Boolean: " + true ); //如果输出之后不想换行，可以使用System.out.print() System.out.print("Hello "); System.out.print("World");// /*// * 输入// *///// //通过Scanner读取输入// //必须import java.util.Scanner;// Scanner scanner = new Scanner(System.in);//// //读取string输入// String name = scanner.next();//// //读取byte输入// byte numByte = scanner.nextByte();//// //读取int输入// int numInt = scanner.nextInt();//// //读取long输入// float numFloat = scanner.nextFloat();//// //读取oduble输入// double numDouble = scanner.nextDouble();//// //读取boolean输入// boolean bool = scanner.nextBoolean(); /////////////////////////////////////// // 变量 /////////////////////////////////////// /* * 变量声明 */ //通过&lt;type&gt; &lt;name&gt;声明变量 int fooInt; //声明多个变量： // &lt;type&gt; &lt;name1&gt;, &lt;name2&gt;, &lt;name3&gt; int fooInt1, fooInt2, fooInt3; /* * 变量初始化 */ // 通过&lt;type&gt; &lt;name&gt; = &lt;val&gt;来初始变量 int barInt = 1; // 初始化多个变量： // &lt;type&gt; &lt;name1&gt;, &lt;name2&gt;, &lt;name3&gt; // &lt;name1&gt; = &lt;name2&gt; = &lt;name3&gt; = &lt;val&gt; int barInt1, barInt2, barInt3; barInt1 = barInt2 = barInt3 = 1; /* * 变量类型 */ // Byte - 8位有符号二进制补码整数 // (-128 &lt;= byte &lt;= 127) byte fooByte = -100; // 如果您想将一个字节解释为无符号整数 // 只需要下边这句 int unsignedIntLessThan256 = 0xff &amp; fooByte; // 下边这句 int signedInt = (int) fooByte; // Short - 16位有符号二进制补码整数 // (-32,768 &lt;= short &lt;= 32,767) short fooShort = 10000; // Integer - 32位有符号二进制补码整数 // (-2,147,483,648 &lt;= int &lt;= 2,147,483,647) int bazInt = 1; // Long - 64位有符号二进制补码整数 // (-9,223,372,036,854,775,808 &lt;= long &lt;= 9,223,372,036,854,775,807) long fooLong = 100000L; // 数值后边的'L'指示这个变量是long类型 // 没有L的话依然会默认用int存储 // 注意: byte, short, int 和 long 都是有符号的. 也就是说可以为正数或负数 // 没有无符号变量 // 然而，char就是16位无符号的 // Float - 单精度32位IEEE 754浮点数 // 2^-149 &lt;= float &lt;= (2-2^-23) * 2^127 float fooFloat = 234.5f; // 数字末尾的f 或者 F 是用来标识这个变量通过float进行存储 // 否则就会默认按照double存储 // Double - 双精度64位IEEE 754浮点数 // 2^-1074 &lt;= x &lt;= (2-2^-52) * 2^1023 double fooDouble = 123.4; // Boolean - true &amp; false boolean fooBoolean = true; boolean barBoolean = false; // Char - 一个16位的unicode字符 char fooChar = 'A'; // final 变量不能被重新赋值 final int HOURS_I_WORK_PER_WEEK = 9001; // 但是可以稍后初始化 final double E; E = 2.71828; // BigInteger - 不可变的任意精度整数 // // BigInteger是一类数据类型，允许程序员操作超过64位长度的整数 // 这样生成的整数存储为字节组成的数组，并通过内建在BigInteger中的函数进行操作 // // BigInteger 可以通过一个字节组成的数组或者字符串初始化 String fooByteArray = "1000000000000000000000000000000000000000000"; BigInteger fooBigInteger = new BigInteger(fooByteArray); // BigDecimal - 不可变的，任意精度的带符号十进制数 // // BigDecimal包含两个部分:一个任意精度的整数无标度值和一个32位整数标度 // // BigDecimal允许程序员完全控制十进制舍入 // 建议将BigDecimal与精度值一起使用，并在需要精确小数精度的地方使用BigDecimal // // BigDecimal 可以使用int、long、double或String初始化 // 也可以初始化未缩放值(BigInteger)和scale (int) fooInt = 1; BigDecimal fooBigDecimal = new BigDecimal(fooBigInteger, fooInt); //警惕采用float或double的构造函数 //float/double的不准确性也会被拷贝到BigDecimal中 //当您需要精确值时，首选String构造函数 BigDecimal tenCents = new BigDecimal("0.1"); // String：字符串 String fooString = "My String Is Here!"; // \n 是一个转义字符，开始一个新行 String barString = "Printing on a new line?\nNo Problem!"; // \t 是一个转义字符，用于添加制表符 String bazString = "Do you want to add a tab?\tNo Problem!"; System.out.println(fooString); System.out.println(barString); System.out.println(bazString); // 字符串构建 // #1 - 通过加号"+"运算符 // 这是实现它的基本方法（在通过引擎优化） String plusConcatenated = "Strings can " + "be concatenated " + "via + operator."; System.out.println(plusConcatenated); // 输出: 字符串可以通过+运算符连接 // #2 - 通过StringBuilder //这种方式不会创建任何中间字符串。 它只存储字符串片段，并在调用toString（）时将它们连接在一起 //提示：此类不是线程安全的。 StringBuffer是一种线程安全的替代方案（对性能有一些影响）。 StringBuilder builderConcatenated = new StringBuilder(); builderConcatenated.append("You "); builderConcatenated.append("can use "); builderConcatenated.append("the StringBuilder class."); System.out.println(builderConcatenated.toString()); //字符串只在现在构建 // 输出: You can use the StringBuilder class. // 在完成某些处理结束之前不需要完全构造的String时，StringBuilder非常有效。 StringBuilder stringBuilder = new StringBuilder(); String inefficientString = ""; for (int i = 0 ; i &lt; 10; i++) &#123; stringBuilder.append(i).append(" "); inefficientString += i + " "; &#125; System.out.println(inefficientString); System.out.println(stringBuilder.toString()); // inefficientString需要更多的工作来生成，因为它在每次循环迭代时都会生成一个String。 // 使用+进行简单字符串连接，编译后相当于同时调用StringBuilder和toString（） // 使用StringBuilder可以避免循环中的字符串连接。 // #3 - 使用String格式化器 // 另一种创建字符串的替代方法，快速且可读。 String.format("%s may prefer %s.", "Or you", "String.format()"); // 输出: Or you may prefer String.format(). // Arrays：数组 // 必须在实例化时确定数组大小 // 以下格式用于声明数组 // &lt;datatype&gt;[] &lt;var name&gt; = new &lt;datatype&gt;[&lt;array size&gt;]; // &lt;datatype&gt; &lt;var name&gt;[] = new &lt;datatype&gt;[&lt;array size&gt;]; int[] intArray = new int[10]; String[] stringArray = new String[1]; boolean boolArray[] = new boolean[100]; // 声明和初始化数组的另一种方法 int[] y = &#123;9000, 1000, 1337&#125;; String names[] = &#123;"Bob", "John", "Fred", "Juan Pedro"&#125;; boolean bools[] = &#123;true, false, false&#125;; // 索引数组 - 访问元素 System.out.println("intArray @ 0: " + intArray[0]); // 数组是零索引且可变的 intArray[1] = 1; System.out.println("intArray @ 1: " + intArray[1]); // 其他值得一试的数据类型 // ArrayLists - 除了提供更多功能之外的类似数组，且数组长度是可变的 // LinkedLists - 双向链表的实现，全部操作按照双向链表执行。 // Maps - 键对象到值对象的映射。 Map是一个接口，因此无法实例化。 必须在实现类的实例化时指定Map中包含的键和值的类型。 每个键可以仅映射到一个对应的值，并且每个键可以仅出现一次（没有重复）。 // HashMaps - 此类使用哈希表来实现Map接口。 这允许基本操作的执行时间（例如get和insert元素）即使对于大型集合也保持不变。 // TreeMap - 按键排序的映射。 每个修改都维护由实例化时提供的Comparator定义的排序，或者如果它们实现Comparable接口则对每个Object进行比较。 密钥实现Comparable失败以及无法提供Comparator将导致ClassCastExceptions。 插入和删除操作需要O(log(n))时间，因此除非您正在利用排序，否则请避免使用此数据结构。 /////////////////////////////////////// // Operators：运算符 /////////////////////////////////////// System.out.println("\n-&gt;Operators"); int i1 = 1, i2 = 2; // 多个声明的简写 // 算数很直接 System.out.println("1+2 = " + (i1 + i2)); // =&gt; 3 System.out.println("2-1 = " + (i2 - i1)); // =&gt; 1 System.out.println("2*1 = " + (i2 * i1)); // =&gt; 2 System.out.println("1/2 = " + (i1 / i2)); // =&gt; 0 (int/int 返回 int) System.out.println("1/2.0 = " + (i1 / (double)i2)); // =&gt; 0.5 // Modulo：模运算 System.out.println("11%3 = "+(11 % 3)); // =&gt; 2 // 比较运算符 System.out.println("3 == 2? " + (3 == 2)); // =&gt; false System.out.println("3 != 2? " + (3 != 2)); // =&gt; true System.out.println("3 &gt; 2? " + (3 &gt; 2)); // =&gt; true System.out.println("3 &lt; 2? " + (3 &lt; 2)); // =&gt; false System.out.println("2 &lt;= 2? " + (2 &lt;= 2)); // =&gt; true System.out.println("2 &gt;= 2? " + (2 &gt;= 2)); // =&gt; true // 布尔运算符 System.out.println("3 &gt; 2 &amp;&amp; 2 &gt; 3? " + ((3 &gt; 2) &amp;&amp; (2 &gt; 3))); // =&gt; false System.out.println("3 &gt; 2 || 2 &gt; 3? " + ((3 &gt; 2) || (2 &gt; 3))); // =&gt; true System.out.println("!(3 == 2)? " + (!(3 == 2))); // =&gt; true // 位运算符! /* ~ 一元位补 &lt;&lt; 带符号左移 &gt;&gt; 带符号/算术右移 &gt;&gt;&gt; 无符号/逻辑右移 &amp; 按位与运算 ^ 按位异或运算 | 按位或运算 */ // 增量运算符 int i = 0; System.out.println("\n-&gt;Inc/Dec-rementation"); // ++ 和 -- 运算符分别表示递增和递减1 // 如果它们放在变量之前，它们会先递增后返回 // 放在变量之后表示先返回后递增 System.out.println(i++); // i = 1, prints 0 (后递增) System.out.println(++i); // i = 2, prints 2 (先递增) System.out.println(i--); // i = 1, prints 2 (后递减) System.out.println(--i); // i = 0, prints 0 (先递减) /////////////////////////////////////// // Control Structures：控制结构 /////////////////////////////////////// System.out.println("\n-&gt;Control Structures"); // if语句和c语言里边差不多 int j = 10; if (j == 10) &#123; System.out.println("I get printed"); &#125; else if (j &gt; 10) &#123; System.out.println("I don't"); &#125; else &#123; System.out.println("I also don't"); &#125; // While循环 int fooWhile = 0; while(fooWhile &lt; 100) &#123; System.out.println(fooWhile); fooWhile++; &#125; System.out.println("fooWhile Value: " + fooWhile); // Do While 循环 int fooDoWhile = 0; do &#123; System.out.println(fooDoWhile); fooDoWhile++; &#125; while(fooDoWhile &lt; 100); System.out.println("fooDoWhile Value: " + fooDoWhile); // For 循环 // for 循环声明的结构 =&gt; for(&lt;start_statement&gt;; &lt;conditional&gt;; &lt;step&gt;) for (int fooFor = 0; fooFor &lt; 10; fooFor++) &#123; System.out.println(fooFor); // 迭代10次, fooFor 0-&gt;9 &#125; // System.out.println("fooFor Value: " + fooFor); 这句会报错，因为fooFor在for循环内部声明，无法在循环外部调用 // 嵌套的for循环，通过标签退出 outer: for (int ii = 0; ii &lt; 10; ii++) &#123; for (int jj = 0; jj &lt; 10; jj++) &#123; if (ii == 5 &amp;&amp; jj ==5) &#123; break outer; // 跳出外部的outer循环，而不是只有内部的 &#125; &#125; &#125; // For Each 循环 // for循环还能够遍历数组和通过Iterable接口实现的对象 int[] fooList = &#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;; // for each 循环结构 =&gt; for (&lt;object&gt; : &lt;iterable&gt;) // 可以读成: 对于迭代对象中的每个元素 // 注意: 对象类型必须匹配可迭代对象中的元素类型 for (int bar : fooList) &#123; System.out.println(bar); //迭代9次并输出1-9 &#125; // Switch Case // switch使用byte，short，char和int数据类型 // 它也适用于枚举类型（在枚举类型中讨论） // String类，以及一些包装基本类型的特殊类：字符，字节，短整数和整数 // 从Java 7及更高版本开始，我们也可以使用String类型 // 注意：请记住，不在任何特定情况下添加“break”会导致其接着执行下一个case（假设它满足所提供的条件）。 int month = 3; String monthString; switch (month) &#123; case 1: monthString = "January"; break; case 2: monthString = "February"; break; case 3: monthString = "March"; break; default: monthString = "Some other month"; break; &#125; System.out.println("Switch Case Result: " + monthString); // Try-with-resources语句（Java 7+） // Try-catch-finally语句在Java中按预期工作，但在Java 7+中，try-with-resources语句也可用 // Try-with-resources通过自动关闭资源简化了try-catch-finally语句 // 为了使用try-with-resources，先在try语句内包含一个类的实例。 该类必须应用java.lang.AutoCloseable。 try (BufferedReader br = new BufferedReader(new FileReader("foo.txt"))) &#123; // 你可以试着干一些会抛出异常的事情 System.out.println(br.readLine()); // 在Java 7中，即使抛出了异常，资源也会被关闭 &#125; catch (Exception ex) &#123; // 在catch语句生效之前，资源就会关闭 System.out.println("readLine() failed."); &#125; // 在这个例子中，不需要finally声明，BufferReader就已经关闭了 // 这可以被用来避免在一些边缘情况中，有些finally声明不会被调用的情况 // 了解更多请访问: // https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html // 条件语句的简写 // 你可以使用'？'操作符来进行快速分配或逻辑分叉 // 可以解读成 "If (statement) is true, use &lt;first value&gt;, otherwise, use &lt;second value&gt;" int foo = 5; String bar = (foo &lt; 10) ? "A" : "B"; System.out.println("bar : " + bar); // 打印 "bar : A", 因为声明foo&lt;10 为 true. // 或者就简单的这么写 System.out.println("bar : " + (foo &lt; 10 ? "A" : "B")); //////////////////////////////////////// // Converting Data Types：转换数据类型 //////////////////////////////////////// // 转换数据 // 字符串 到 整数 Integer.parseInt("123");//返回一个整数123 // 整数 到 字符串 Integer.toString(123);//返回一个字符串123 // 对于其他转换，可以看一下下面的类 // Double // Long // String /////////////////////////////////////// // Classes And Functions：类和函数 /////////////////////////////////////// System.out.println("\n-&gt;Classes &amp; Functions"); // (Bicycle类的定义在后边) // 通过new来实例化一个类 Bicycle trek = new Bicycle(); // 调用对象的方法 trek.speedUp(3); // You should always use setter and getter methods trek.setCadence(100); // toString 会返回这个对象的字符串表示 System.out.println("trek info: " + trek.toString()); &#125;// main方法的结束&#125;// LearnJava类的结束// 您可以在一个.java文件中包含其他非公共外层类，但这不是一个好习惯// 正确的做法是将不同的类拆分为单独的文件// Class 声明语法：// &lt;public/private/protected&gt; class &lt;class name&gt; &#123;// // 数据字段，构造函数，函数都在里面// // 函数在Java中称为方法// &#125;class Bicycle &#123; // Bicycle类的字段/变量 public int cadence; // Public: 可以从任何地方访问 private int speed; // Private: 只能从类内部访问 protected int gear; // Protected: 可以从类和子类中访问 String name; // 默认只能从这个包中访问 static String className; // 静态的类变量 // Static block：静态块 // Java没有静态构造函数的实现，但有一个静态块可用于初始化类变量（静态变量） // 加载类时将调用此块 static &#123; className = "Bicycle"; &#125; // Double Brace Initialization：双大括号初始化 // Java语言没有关于如何以简单方式创建静态集合的语法。 通常您最终会使用一下方式： private static final Set&lt;String&gt; COUNTRIES = new HashSet&lt;String&gt;(); static &#123; COUNTRIES.add("DENMARK"); COUNTRIES.add("SWEDEN"); COUNTRIES.add("FINLAND"); &#125; // 但是通过使用一种叫做Double Brace Initialization的东西，可以通过一种更简单的方式实现同样的事情。 private static final Set&lt;String&gt; COUNTRIES2 = new HashSet&lt;String&gt;() &#123;&#123; add("DENMARK"); add("SWEDEN"); add("FINLAND"); &#125;&#125;; // 第一个大括号是创建一个新的AnonymousInnerClass，第二个大括号是声明一个实例初始化块 // 创建匿名内部类时调用此块 // 这不仅适用于集合，它适用于所有非最终类 // 构造函数是一种创建类的方法 // 这就是一个构造函数 public Bicycle() &#123; // 你也可以调用另一个构造函数: this(1, 50, 5, "Bontrager"); gear = 1; cadence = 50; speed = 5; name = "Bontrager"; &#125; // 这是一个带参数的构造函数 public Bicycle(int startCadence, int startSpeed, int startGear, String name) &#123; this.gear = startGear; this.cadence = startCadence; this.speed = startSpeed; this.name = name; &#125; // Method 语法: // &lt;public/private/protected&gt; &lt;return type&gt; &lt;function name&gt;(&lt;args&gt;) // Java类通常为其字段实现getter和setter // Method 声明语法: // &lt;access modifier：访问修饰符&gt; &lt;return type&gt; &lt;method name&gt;(&lt;args&gt;) public int getCadence() &#123; return cadence; &#125; // void方法不需要return public void setCadence(int newValue) &#123; cadence = newValue; &#125; public void setGear(int newValue) &#123; gear = newValue; &#125; public void speedUp(int increment) &#123; speed += increment; &#125; public void slowDown(int decrement) &#123; speed -= decrement; &#125; public void setName(String newName) &#123; name = newName; &#125; public String getName() &#123; return name; &#125; //显示此对象的属性值的方法 @Override // 从Object类中继承. public String toString() &#123; return "gear: " + gear + " cadence: " + cadence + " speed: " + speed + " name: " + name; &#125;&#125; // Bicycle类的结束// PennyFarthing 是 Bicycle 的一个子类class PennyFarthing extends Bicycle &#123; // (Penny Farthings是那些带有大前轮的自行车，这种自行车没有齿轮) public PennyFarthing(int startCadence, int startSpeed) &#123; // 通过super调用父类的构造函数 super(startCadence, startSpeed, 0, "PennyFarthing"); &#125; // 如果要覆盖一个父类的方法，您应该用@annotation标记一下（这里是@Override） // 了解更多请访问: http://docs.oracle.com/javase/tutorial/java/annotations/ @Override public void setGear(int gear) &#123; this.gear = 0; &#125;&#125;// Object casting：对象转换// 由于PennyFarthing类扩展自Bicycle类，我们可以说PennyFarthing是一个Bicycle并写道：// Bicycle bicycle = new PennyFarthing();// 这称为对象转换，其中一个对象被用于另一个对象。 这里有许多细节和处理更多中间概念： https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html// Interfaces：接口// Interface 声明语法// &lt;access-level&gt; interface &lt;interface-name&gt; extends &lt;super-interfaces&gt; &#123;// // Constants// // Method declarations// &#125;// 例子 - Food:public interface Edible &#123; public void eat(); // 任何实现此接口的类都必须实现此方法&#125;public interface Digestible &#123; public void digest(); // 从Java 8开始，接口可以有默认方法 public default void defaultMethod() &#123; System.out.println("Hi from default method ..."); &#125;&#125;// 我们现在可以创建一个实现这两个接口的类。public class Fruit implements Edible, Digestible &#123; @Override public void eat() &#123; // ... &#125; @Override public void digest() &#123; // ... &#125;&#125;// 在Java中，你只能extend一个类，但是你可以实现多个接口，如下：public class ExampleClass extends ExampleClassParent implements InterfaceOne, InterfaceTwo &#123; @Override public void InterfaceOneMethod() &#123; &#125; @Override public void InterfaceTwoMethod() &#123; &#125;&#125;// Abstract Classes：抽象类// 抽象类声明语法// &lt;access-level&gt; abstract class &lt;abstract-class-name&gt; extends// &lt;super-abstract-classes&gt; &#123;// // Constants and variables// // Method declarations// &#125;// 抽象类不能被实例化// 抽象类可以定义抽象方法// 抽象方法没有正文并且标记为抽象，非抽象子类必须通过@Override来覆盖来自其超类的所有抽象方法// 在将重复逻辑与自定义行为相结合时，抽象类可能很有用，但由于抽象类需要继承，因此它们违反了“基于继承的组合”，因此需要组合时请考虑使用其他方法// https://en.wikipedia.org/wiki/Composition_over_inheritancepublic abstract class Animal&#123; private int age; public abstract void makeSound(); // 非抽象方法可以有正文 public void eat() &#123; System.out.println("I am an animal and I am Eating."); // 注意，在这里我们可以获取私有变量 age = 30; &#125; public void printAge() &#123; System.out.println(age); &#125; // 抽象类可以有main函数 public static void main(String[] args) &#123; System.out.println("I am abstract"); &#125;&#125;class Dog extends Animal&#123; // 注意，仍需重写抽象类中的抽象方法 @Override public void makeSound() &#123; System.out.println("Bark"); // age = 30; ==&gt; ERROR! 这里会报错，age是Animal的私有变量 &#125; // 注意，如果你在这里使用@Override注解会发生错误，因为java不允许重写静态方法 // 这种情况被成为方法隐藏 // 了解更多请访问: http://stackoverflow.com/questions/16313649/ public static void main(String[] args) &#123; Dog pluto = new Dog(); pluto.makeSound(); pluto.eat(); pluto.printAge(); &#125;&#125;// Final Classes：final类// Final Class 声明语法// &lt;access-level&gt; final &lt;final-class-name&gt; &#123;// // Constants and variables// // Method declarations// &#125;// final类不能被继承，因此最终一定是一个child// 在某种程度上，final类与抽象类相反，因为抽象类必须被扩展才能使用，而final类不能被扩展public final class SaberToothedCat extends Animal&#123; // 注意，仍需重写抽象类中的抽象方法 @Override public void makeSound() &#123; System.out.println("Roar"); &#125;&#125;// Final Methods：final方法public abstract class Mammal&#123; // 如果用final来修饰变量的话，则该变量的值不能被修改，成为常量，如下： protected final int finalFoo = 0; // Final Method 语法: // &lt;access modifier&gt; final &lt;return type&gt; &lt;function name&gt;(&lt;args&gt;) // final方法和final类一样，不能在子类中被重写 // 因此一定是该方法的最终实现 public final boolean isWarmBlooded() &#123; return true; &#125;&#125;// Enum Type：枚举类型//// 枚举类型是一种特殊的数据类型，它使变量成为一组预定义的常量。// 变量必须等于为其预定义的值之一。 因为它们是常量，所以枚举类型字段的名称是大写字母。// 在Java编程语言中，使用enum关键字定义枚举类型。// 例如，您可以将星期几的枚举类型指定为：public enum Day &#123; SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY&#125;// 我们可以像这样使用Daypublic class EnumTest &#123; // enum变量 Day day; public EnumTest(Day day) &#123; this.day = day; &#125; public void tellItLikeItIs() &#123; switch (day) &#123; case MONDAY: System.out.println("Mondays are bad."); break; case FRIDAY: System.out.println("Fridays are better."); break; case SATURDAY: case SUNDAY: System.out.println("Weekends are best."); break; default: System.out.println("Midweek days are so-so."); break; &#125; &#125; public static void main(String[] args) &#123; EnumTest firstDay = new EnumTest(Day.MONDAY); firstDay.tellItLikeItIs(); // =&gt; Mondays are bad. EnumTest thirdDay = new EnumTest(Day.WEDNESDAY); thirdDay.tellItLikeItIs(); // =&gt; Midweek days are so-so. &#125;&#125;// Enum types(枚举类型) 比我们上边展示的要强大的多// enum正文可以包含各种方法和字段// 详细的可以看： https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html// 现在开始学Lambda表达式//// Java8版本的新增功能是lambda表达式。// Lambda在函数式编程语言中更常见，这意味着它们是可以在不属于类的情况下创建的方法，如同它本身就是一个对象一样传递，并按需执行。// 最后要注意，lambdas必须通过一个功能接口实现// 功能接口是仅声明了一个抽象方法的接口// 它可以有任意数量的默认方法// Lambda表达式可以用作该功能接口的实例// 满足要求的任何接口都被视为功能接口// 您可以阅读更多有关上述接口的资料//import java.util.Map;import java.util.HashMap;import java.util.function.*;import java.security.SecureRandom;public class Lambdas &#123; public static void main(String[] args) &#123; // Lambda 声明语句: // &lt;zero or more parameters&gt; -&gt; &lt;expression body or statement block&gt; // 我们将在接下来的例子中使用这个hashmap Map&lt;String, String&gt; planets = new HashMap&lt;&gt;(); planets.put("Mercury", "87.969"); planets.put("Venus", "224.7"); planets.put("Earth", "365.2564"); planets.put("Mars", "687"); planets.put("Jupiter", "4,332.59"); planets.put("Saturn", "10,759"); planets.put("Uranus", "30,688.5"); planets.put("Neptune", "60,182"); // 下边这个例子是一个没有参数，使用了java.util.function.Supplier中的Supplier功能接口的Lambda // 实际的lambda表达式是在numPlanets =之后出现的内容 Supplier&lt;String&gt; numPlanets = () -&gt; Integer.toString(planets.size()); System.out.format("Number of Planets: %s\n\n", numPlanets.get()); // 一下例子是具有一个参数并使用java.util.function.Consumer中的Consumer功能接口的Lambda // 这是因为行星是一个Map，它实现了Collection和Iterable // 此处使用的forEach（可以在Iterable中找到）将lambda表达式应用于Collection的每个成员 // forEach的默认实现表现如下： /* for (T t : this) action.accept(t); */ // 实际上lambda表达式是传给forEach的参数 planets.keySet().forEach((p) -&gt; System.out.format("%s\n", p)); // 如果你只有一个参数，也可以写成 (注意p周围的括号没了): planets.keySet().forEach(p -&gt; System.out.format("%s\n", p)); // 在以上内容中，我们可以看到planets是一个HashMap，keySet()方法返回一个它的键集，forEach将每个元素应用于lambda表达式:(parameter p) -&gt; System.out.format("%s\n", p) // 每次，该元素被称为“消耗”，并且应用lambda体中引用的语句 // lambda体是在-&gt;之后出现的部分 // 上边的语句如果不用lambda写的话会看起来更加传统 for (String planet : planets.keySet()) &#123; System.out.format("%s\n", planet); &#125; // 这个例子与上面的不同之处在于使用了不同的forEach实现：在实现Map接口的HashMap类中找到的forEach // 这个forEach接受一个BiConsumer，一般来说这是一种奇特的方式，也就是说它处理的是每个Key -&gt; Value对的Set // 此默认实现表现如下： /* for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) action.accept(entry.getKey(), entry.getValue()); */ // 实际的lambda表达式是传给forEach的参数 String orbits = "%s orbits the Sun in %s Earth days.\n"; planets.forEach((K, V) -&gt; System.out.format(orbits, K, V)); // 上边的语句如果不用lambda写的话会看起来更加传统 for (String planet : planets.keySet()) &#123; System.out.format(orbits, planet, planets.get(planet)); &#125; // 或者，如果更严格地遵循默认实现提供的规范 for (Map.Entry&lt;String, String&gt; planet : planets.entrySet()) &#123; System.out.format(orbits, planet.getKey(), planet.getValue()); &#125; // 这些例子仅涵盖了lambda的基本用法 // 它可能看起来不是非常有用，但请记住，lambda可以创建为一个对象，以后可以作为参数传递给其他方法 &#125;&#125;]]></content>
      <categories>
        <category>Learn X in Y minutes</category>
        <category>Learn Java in Y minutes</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lambda演算精简教程]]></title>
    <url>%2F2019%2F04%2F24%2FLambda%E6%BC%94%E7%AE%97%E7%B2%BE%E7%AE%80%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言这篇文章译自：https://learnxinyminutes.com/docs/lambda-calculus/，写的精简了点，理解起来可能有些困难 建议配合让我们谈谈 $\lambda$ 演算.pdf一起食用（出自https://github.com/txyyss/Lambda-Calculus/releases）。这篇不算长，深入浅出，写的也极好。 整体介绍Lambda演算( $\lambda$ 演算)由Alonzo Church提出，是世界上最简洁的变成语言。尽管没有数字、字符串、布尔值等非函数数据类型，lambda演算还是可以表达任何图灵机。 Lambda演算由三种元素组成：变量（variables），函数（functions），以及应用（applications）。 名称 语法 例子 解释 Variable &lt;name> x 一个名为“x”的变量 Function $\lambda$ &lt;parameters>.&lt;body> $\lambda$ x.x 一个拥有参数“x”以及函数体x的函数 Application &lt;function> ( $\lambda$ x.x).a 调用函数“ $\lambda$ x.x”且参数值为“a” 最基础的函数就是恒等函数： $\lambda$ x.x（即f(x)=x）。第一个“x”代表函数的参数，第二个“x”代表函数体。 自由变量vs约束变量 在 $\lambda$ x.x函数中，x被称为约束变量，因为它同时位于函数体和参数中。 在 $\lambda$ x.y函数中，y被称为自由变量，因为它从未被事先声明过。 计算通过 $\beta$ 规约进行计算，其基本上是词法范围的替代。 在计算表达式( $\lambda$ x.x)a时，我们用“a”替换函数体中出现的所有“x”。 ( $\lambda$ x.x)a 计算结果为：a ( $\lambda$ x.y)a 计算结果为：y 也可以创建高阶函数： ( $\lambda$ x.( $\lambda$ y.x))a 计算结果为： $\lambda$ y.a 虽然lambda演算传统上只支持单参数函数，但是我们可以使用一种称为currying的技术创建多参数函数。 ( $\lambda$ x. $\lambda$ y. $\lambda$ z.xyz) 即 f(x, y, z) = ((x y) z) 有时 $\lambda$ xy.&lt;body>可与 $\lambda$ x. $\lambda$ y.&lt;body>交替使用。 重要的是要认识到传统的lambda演算没有数字，字符或任何非函数数据类型！ 布尔逻辑在lambda演算中没有“True”或“False”。甚至没有1或0。 取而代之的是： T表示为： $\lambda$ x. $\lambda$ y.x F表示为： $\lambda$ x. $\lambda$ y.y 首先，我们可以定义一个“if”函数 $\lambda$ btf，如果b为True则返回t，如果b为False则返回f IF 也等同于 $\lambda$ b. $\lambda$ t. $\lambda$ f.b t f 通过使用IF，我们可以定义基础的布尔逻辑运算： a AND b 等同于: $\lambda$ ab.IF a b F a OR b 等同于: $\lambda$ ab.IF a T b NOT a 等同于: $\lambda$ a.IF a F T 注意: IF a b c 本质上是: IF((a b) c) 数字尽管lambda演算中没有数字，我们可以通过邱奇数编码数字。 任意数字n都可以编码为： $n = \lambda f.f^n$ 。因此： 0 = $\lambda$ f. $\lambda$ x.x 1 = $\lambda$ f. $\lambda$ x.f x 2 = $\lambda$ f. $\lambda$ x.f(f x) 3 = $\lambda$ f. $\lambda$ x.f(f(f x)) 为了增加邱奇数，我们使用继承函数s(n)=n+1，即 S = $\lambda$ n. $\lambda$ f. $\lambda$ x.f((n f) x) 通过继承，我们可以定义add： ADD = $\lambda$ ab.(a S)b 挑战：试着定义你自己的乘法函数！ 变得更精致：SKI，SK以及IotaSKI组合子演算使S, K, I，分别为以下函数： I x = x K x y = x S x y z = x z (y z) 我们可以将lambda演算中的表达式转换为SKI组合子演算中的表达式： $\lambda$ x.x = I $\lambda$ x.c = Kc $\lambda$ x.(y z) = S ( $\lambda$ x.y) ( $\lambda$ x.z) 以邱奇数2为例子： 2 = $\lambda$ f. $\lambda$ x.f(f x) 对于内部部分 $\lambda$ x.f(f x): $$\begin{split}\lambda x.f(f x) &amp;=&amp; S ( \lambda x.f) ( \lambda x.(f x)) (case 3) \\&amp;=&amp; S (K f) (S ( \lambda x.f) ( \lambda x.x)) (case 2, 3) \\&amp;=&amp; S (K f) (S (K f) I) (case 2, 1)\end{split}$$ 因此： $$\begin{split}2&amp;=&amp; \lambda f. \lambda x.f(f x) \\&amp;=&amp; \lambda f.(S (K f) (S (K f) I)) \\&amp;=&amp; \lambda f.((S (K f)) (S (K f) I)) \\&amp;=&amp; S ( \lambda f.(S (K f))) ( \lambda f.(S (K f) I)) (case 3)\end{split}$$ 对于第一个参数 \lambda f.(S (K f))： $$\begin{split}\lambda f.(S (K f))&amp;=&amp; S ( \lambda f.S) ( \lambda f.(K f)) (case 3)\\&amp;=&amp; S (K S) (S ( \lambda f.K) ( \lambda f.f)) (case 2, 3)\\&amp;=&amp; S (K S) (S (K K) I) (case 2, 3)\end{split}$$ 对于第二个参数 \lambda f.(S (K f) I)： $$\begin{split} \lambda f.(S (K f) I)&amp;=&amp; \lambda f.((S (K f)) I)\\&amp;=&amp; S ( \lambda f.(S (K f))) ( \lambda f.I) (case 3)\\&amp;=&amp; S (S ( \lambda f.S) ( \lambda f.(K f))) (K I) (case 2, 3)\\&amp;=&amp; S (S (K S) (S ( \lambda f.K) ( \lambda f.f))) (K I) (case 1, 3)\\&amp;=&amp; S (S (K S) (S (K K) I)) (K I) (case 1, 2)\end{split}$$ 合到一起： $$\begin{split} 2&amp;=&amp; S ( \lambda f.(S (K f))) ( \lambda f.(S (K f) I))\\&amp;=&amp; S (S (K S) (S (K K) I)) (S (S (K S) (S (K K) I)) (K I))\end{split}$$ SK 组合子运算SKI组合子运算仍可进一步简化。我们可以通过注意I = SKK来移除I组合子。我们可以用SKK替换所有I。 Iota组合子SK组合子运算依然不是最简洁的。定义： $$\begin{split}ι = \lambda f.((f S) K)\end{split}$$ 我们就有： $$\begin{split}I &amp;=&amp; ιι\\K &amp;=&amp; ι(ιI) = ι(ι(ιι))\\S &amp;=&amp; ι(K) = ι(ι(ι(ιι)))\end{split}$$]]></content>
      <tags>
        <tag>lambda</tag>
        <tag>lambda演算</tag>
        <tag>lambda calculus</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Reading Notes] Business process management (BPM) standards: a survey]]></title>
    <url>%2F2019%2F04%2F22%2FReading-Notes-Business-process-management-BPM-standards-a-survey%2F</url>
    <content type="text"><![CDATA[AbstractpurposeThis paper seeks to make sense of the myriad BPM standards, organizing them in a classification framework, and to identify key industry trends. Design/methodology/approachProposed BPM Standards Classification Framework to list each standard’s distinct features, strengths and weaknesses. FindingsAn attempt is made to classify BPM languages, standards and notations into four main groups: execution, interchange, graphical, and diagnosis(lack) standards. Practical implicationsResearchers and practitioners may wish to position their work around this review. Originality/valueNo body did before. KeywordsProcess management, Standards, Work flow Paper typeLiterature review IntroductionThe growth of business process managementSome factors: the rise in frequency of goods ordered; the need for fast information transfer; quick decision making; the need to adapt to change in demand; more international competitors; and demands for shorter cycle times Software tools supporting the management of such operational processes became known as business process management systems (BPMS). The proliferation of BPM languages, standards and software systemsNaturally, interest in BPM from practitioners and researchers grew rapidly. Many new BPM terminologies and technologies are often not well defined and understood by many practitioners and researchers using them.New languages and notations proposed often contain duplicating features for similar concepts, and loosely claim to be based on theoretical formalisms such as Pi-calculus and Petri nets. Most of them have also not been validated, especially in a real business and office environment. Motivation of this paperThis paper’s goal is to leave the reader with some semblance of order out of a disparate collection of specifications, white papers, journal publications, conference publications and workshop notes to be consolidated as a single paper. discuss and rationalize the terminologies associated with BPM and its standards; systematically categorize/classify BPM standards; discuss the current strengths and limitations of each standard; clarify, the differences of theoretical underpinnings of prominent BPM standards; and explore the gaps of knowledge of current BPM standards and how these may be bridged. BPM basicsThe BPM life cycle Term Explanation Process design In this stage, fax- or paper-based as-is business processes are electronically modeled into BPMS. Graphical standards are dominant in this stage. System configuration This stage configures the BPMS and the underlying system infrastructure. This stage is hard to standardize due to the differing IT architectures of different enterprises. Process enactment Electronically modeled business processes are deployed in BPMS engines. Execution standards dominate this stage. Diagnosis Given appropriate analysis and monitoring tools, the BPM analyst can identify and improve on bottlenecks and potential fraudulent loopholes in the business processes. The tools to do this are embodied in diagnosis standards. BPM vs BPR vs WfM BPM: Business Process Management BPR: Business Process Reengineering WfM: Workflow Management BPM vs BPRBPR calls for a radical obliteration of existing business processes, its descendant BPM is more practical, iterative and incremental in fine-tuning business processes. BPM vs WfM One viewpoint by Gartner research views BPM as a management discipline with WfM supporting it as a technology. Another viewpoint from academics is that the features stated in WfM according to Georgakopoulos et al. is a subset of BPM defined by van der Aalst et al., with the diagnosis stage of the BPM life cycle as the main difference. BPM theory vs BPM standards and languages vs BPMSBPMS/BPMSs: Business Process Management Suites BPM vs service oriented architectureSOA: Service Oriented Architecture BPM is a process-oriented management discipline aided by IT while SOA is an IT architectural paradigm. According to Gartner (Hill et al., 2006), BPM “organizes people for greater agility” while SOA “organizes technology for greater agility”. Categorising the BPM standardsB2B: business-to-business Graphical standards. This allows users to express business processes and their possible flows and transitions in a diagrammatic way. Execution standards. It computerizes the deployment and automation of business processes. Interchange standards. It facilitates portability of data, e.g. the portability of business process designs in different graphical standards across BPMS; different execution standards across disparate BPMS, and the context-less translation of graphical standards to execution standards and vice versa. Diagnosis standards. It provides administrative and monitoring (such as runtime and post-modeling) capabilities. These standards can identify bottlenecks, audit and query real-time the business processes in a company.]]></content>
      <tags>
        <tag>Reading Notes</tag>
        <tag>BPM</tag>
        <tag>survey</tag>
        <tag>business process management</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyton快速入门：6小时精通python(六-完结)]]></title>
    <url>%2F2019%2F04%2F19%2F6%E5%B0%8F%E6%97%B6%E7%B2%BE%E9%80%9Apython-%E5%85%AD-%E5%AE%8C%E7%BB%93%2F</url>
    <content type="text"><![CDATA[译自：https://learnxinyminutes.com/docs/python3/ 阅前须知： “#”后边的是注释 带行号的是python代码 不带行号的是代码的输出 把下边的语句对着敲一边自然就会了，博主用的是jupyter notebook 123###################################################### 6. Classes#################################################### 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 通过class声明，来创建一个类# 类内方法中，self为一个保留字，代表类实例化后instance自身# 类内方法中，cls也是一个保留字，代表类class自身# 通过self.***可以给类内属性赋值，或调用类内方法class Human: # 直接定义的变量，是这个类的共享属性，所有实例都可以访问 species = "H. sapiens" # __init__是一个保留方法，用于类的实例化（生成实例时自动调用） # 注意：名称前后有双下划线__，代表这个对象或者属性是python调用、用户定义的 # 这类方法（对象、属性）包括: __init__, __str__, __repr__ etc. # 这类特殊方法，也被称作（dunder method） # 不要自己创造这类方法 def __init__(self, name): # 将参数分配给实例的name属性 self.name = name # 初始化属性 self._age = 0 # 这是类的一个内建方法，所有内建的方法都需要把self作为其第一个形式参数 def say(self, msg): print("&#123;name&#125;: &#123;message&#125;".format(name=self.name, message=msg)) # 另一个方法 def sing(self): return 'yo... yo... microphone check... one two... one two...' # @classmethod是一个声明，声明接下来定义的方法是该类所有实例的共享方法 # 这种方法被调用时，必须有cls作为第一个参数 # 类方法的特点在于，可以被类自身调用，如Human.get_species() @classmethod def get_species(cls): return cls.species # @staticmethod声明接下来定义的是一个静态方法 # 静态方法可以被类单独调用 @staticmethod def grunt(): return "*grunt*" # @property就是一个getter，声明该方法用于访问内部属性 # @property这个声明，将age()方法转换为同名的只读属性。 # 但是，不需要在Python中编写琐碎的getter和setter。 @property def age(self): return self._age # 如果还想要让该属性可更改，可以这么写 @age.setter def age(self, age): self._age = age # deleter可以让该属性可删除 @age.deleter def age(self): del self._age 123456789101112131415161718192021222324252627282930313233# __name__代表的是运行进程的名称# __name__ == '__main__'，判断用户是否是将该python文件当作主要脚本运行# 简单来说，if __name__ == '__main__':代码块中的内容# 只有在运行该python文件时才会生效，如果该python文件是以import形式被调用，则不会运行# 而写在if __name__ == '__main__':代码块外的内容，被import时，也会运行if __name__ == '__main__': # 生成Human类的实例 # 类名加括号，直接调用__init__方法 i = Human(name="Ian") i.say("hi") # "Ian: hi" j = Human("Joel") j.say("hello") # "Joel: hello" # i and j 是Human类的两个实例 # 调用类方法 i.say(Human.get_species()) # "Ian: H. sapiens" # 共享属性改了之后，大家都改了 Human.species = "H. neanderthalensis" i.say(i.get_species()) # =&gt; "Ian: H. neanderthalensis" j.say(j.get_species()) # =&gt; "Joel: H. neanderthalensis" # 类可以调用静态函数 print(Human.grunt()) # =&gt; "*grunt*" # 有些版本中实例是不能调用静态函数的 print(i.grunt()) # 更新实例的属性 i.age = 42 # 获取property i.say(i.age) # =&gt; "Ian: 42" j.say(j.age) # =&gt; "Joel: 0" # 删除i的age属性 del i.age Ian: hi Joel: hello Ian: H. sapiens Ian: H. neanderthalensis Joel: H. neanderthalensis *grunt* *grunt* Ian: 42 Joel: 0 12# 再访问i的年龄就会报错i.age --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-207-993258cc61d3&gt; in &lt;module&gt;() 1 # 再访问i的年龄就会报错 ----&gt; 2 i.age &lt;ipython-input-186-b3205f030117&gt; in age(self) 44 @property 45 def age(self): ---&gt; 46 return self._age 47 48 # 如果还想要让该属性可更改，可以这么写 AttributeError: &apos;Human&apos; object has no attribute &apos;_age&apos; 12# 不仅仅是age()没了，_age这个属性是真的没了i._age --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-208-4ea879b64970&gt; in &lt;module&gt;() 1 # 不仅仅是age()没了，_age这个属性是真的没了 ----&gt; 2 i._age AttributeError: &apos;Human&apos; object has no attribute &apos;_age&apos; 123###################################################### 6.1 继承#################################################### 1# 继承允许定义新的子类，这些子类从父类继承方法和变量 12345678910# 使用上面定义的Human类作为基类或父类，我们可以定义一个子类Superhero# 它继承了类的变量如“species”，“name”和“age”，# 以及“sing”和“grunt”等方法# 但superhero也可以拥有自己的属性# 如果要将文件模块化，您可以将上面的类放在自己的文件中，命名为human.py# 要从其他文件导入功能，请使用以下格式# from “filename（不加扩展名.py）” import “函数名或类名”from human import Human 123456789101112131415161718192021222324252627282930313233343536373839# 将父类当作参数写进子类定义作为声明# 如：class child(parent):class Superhero(Human): # 如果您想让子类继承父类的所有定义且没有任何修改 # 您可以只使用“pass”关键字（而不使用其他关键字） # 如 # class Human2(Human): # pass # 子类可以重写其父类的属性 species = 'Superhuman' # 子类自动继承其父类的构造函数（__init__），包括它的参数 # 但也可以定义其他参数或定义并重写其方法 # 此构造函数从“human”类继承“name”参数 # 并且添加“superpower”和“movie”参数： def __init__(self, name, movie=False, superpowers=["super strength", "bulletproofing"]): # 增加新的属性 self.fictional = True self.movie = movie # 注意可变的默认值，因为默认值是共享的 self.superpowers = superpowers # “super”是一个保留函数，该函数允许您访问父类的方法 # 下面的语句将调用父类构造函数： super().__init__(name) # 覆盖sing方法 def sing(self): return 'Dun, dun, DUN!' # 增加实例方法 def boast(self): for power in self.superpowers: print("I wield the power of &#123;pwr&#125;!".format(pwr=power)) 1234567891011121314151617181920212223242526272829303132if __name__ == '__main__': sup = Superhero(name="Tick") # 通过isinstance方法，可以判断，实例和类的关系 if isinstance(sup, Human): print('I am human') # 通过type(instance)可以得到实例的class对象 if type(sup) is Superhero: print('I am a superhero') # 通过__mro__方法，可以获取类的继承链（super方法或者getattr方法） print(Superhero.__mro__) # =&gt; (&lt;class '__main__.Superhero'&gt;, &lt;class '__main__.Human'&gt;, &lt;class 'object'&gt;) # 使用父类方法，访问子类属性 print(sup.get_species()) # =&gt; Superhuman # 调用覆盖了的方法 print(sup.sing()) # =&gt; Dun, dun, DUN! # 调用父类的方法 sup.say('Spoon') # =&gt; Tick: Spoon # 调用子类独有的方法 sup.boast() # =&gt; I wield the power of super strength! # =&gt; I wield the power of bulletproofing! # 继承了的类属性 sup.age = 31 print(sup.age) # =&gt; 31 # 子类独有的属性 print('Am I Oscar eligible? ' + str(sup.movie)) I am human I am a superhero (&lt;class &apos;__main__.Superhero&apos;&gt;, &lt;class &apos;__main__.Human&apos;&gt;, &lt;class &apos;object&apos;&gt;) Superhuman Dun, dun, DUN! Tick: Spoon I wield the power of super strength! I wield the power of bulletproofing! 31 Am I Oscar eligible? False 123###################################################### 6.2 多重继承#################################################### 12345678910111213141516# 定义一个蝙蝠类class Bat: species = 'Baty' def __init__(self, can_fly=True): self.fly = can_fly # 这个类页游say的方法 def say(self, msg): msg = '... ... ...' return msg # 还有独有的方法 def sonar(self): return '))) ... (((' 1234if __name__ == '__main__': b = Bat() print(b.say('hello')) print(b.fly) ... ... ... True 123# 如果您写了多个文件，就需要导入一下from superhero import Superherofrom bat import Bat 123456789101112131415161718# 定义蝙蝠侠，继承自超级英雄和蝙蝠两个类class Batman(Superhero, Bat): def __init__(self, *args, **kwargs): # 通常，要继承属性，必须调用super # 然而，我们在这里处理多个继承 # 而super（）只适用于MRO列表中的下一个基类。 # 因此，我们明确地为所有祖先(父类)调用__init__ # 使用“*args”和“*kwargs”可以以一种干净的方式传递参数 # 每个父类“剥一层洋葱皮” Superhero.__init__(self, 'anonymous', movie=True, superpowers=['Wealthy'], *args, **kwargs) Bat.__init__(self, *args, can_fly=False, **kwargs) # override the value for the name attribute self.name = 'Sad Affleck' def sing(self): return 'nan nan nan nan nan batman!' 12345678910111213141516171819202122232425262728if __name__ == '__main__': sup = Batman() # 通过__mro__方法，可以获取类的继承链（super方法或者getattr方法） print(Batman.__mro__) # =&gt; (&lt;class '__main__.Batman'&gt;, # =&gt; &lt;class 'superhero.Superhero'&gt;, # =&gt; &lt;class 'human.Human'&gt;, # =&gt; &lt;class 'bat.Bat'&gt;, &lt;class 'object'&gt;) # 调用父类方法获取子类属性 print(sup.get_species()) # =&gt; Superhuman # 调用覆盖后的方法 print(sup.sing()) # =&gt; nan nan nan nan nan batman! # 两个父类有重名方法时，顺序在前的优先级更高 sup.say('I agree') # =&gt; Sad Affleck: I agree # 调用第二父类方法 print(sup.sonar()) # =&gt; ))) ... ((( # 继承类属性 sup.age = 100 print(sup.age) # =&gt; 100 # 输出从第二父类继承的属性，该属性已被覆盖 print('Can I fly? ' + str(sup.fly)) # =&gt; Can I fly? False (&lt;class &apos;__main__.Batman&apos;&gt;, &lt;class &apos;__main__.Superhero&apos;&gt;, &lt;class &apos;__main__.Human&apos;&gt;, &lt;class &apos;__main__.Bat&apos;&gt;, &lt;class &apos;object&apos;&gt;) Superhuman nan nan nan nan nan batman! Sad Affleck: I agree ))) ... ((( 100 Can I fly? False 123###################################################### 7. Advanced#################################################### 1234# 生成器可以帮你偷很多懒def double_numbers(iterable): for i in iterable: yield i + i 123456789# 生成器可以节省很多内存# 因为它们只加载所需处理iterable中的下一个值的数据(边生成边处理)# 普通方法需要 先生成后处理# 这使其可以进行大范围的数据操作（其他方法可能不行）# 注意：python 3中，“range”替换了“xrange”for i in double_numbers(range(1, 900000000)): # `range` is a generator. print(i) if i &gt;= 30: break 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 123456# 正如可以创建列表理解一样，也可以创建生成器理解# 这里，圆括号是关键，你以为是tuples，实际上是生成器values = (-x for x in [1,2,3,4,5])print(values)for x in values: print(x) # prints -1 -2 -3 -4 -5 to console/terminal &lt;generator object &lt;genexpr&gt; at 0x102e9c990&gt; -1 -2 -3 -4 -5 1234# 也可以直接把一个生成器理解投射到list上values = (-x for x in [1,2,3,4,5])gen_to_list = list(values)print(gen_to_list) # =&gt; [-1, -2, -3, -4, -5] [-1, -2, -3, -4, -5] 123456789101112131415161718192021# 修饰器from functools import wrapsdef beg(target_function): @wraps(target_function) def wrapper(*args, **kwargs): msg, say_please = target_function(*args, **kwargs) if say_please: return "&#123;&#125; &#123;&#125;".format(msg, "Please! I am poor :(") return msg return wrapper# 这里通过beg修饰say# 可以改变say的输出@begdef say(say_please=False): msg = "Can you buy me a beer?" return msg, say_please 12print(say()) # Can you buy me a beer?print(say(say_please=True)) # Can you buy me a beer? Please! I am poor :( Can you buy me a beer? Can you buy me a beer? Please! I am poor :(]]></content>
      <categories>
        <category>Learn X in Y minutes</category>
        <category>Learn Python in Y minutes</category>
      </categories>
      <tags>
        <tag>6小时精通python</tag>
        <tag>python</tag>
        <tag>python3</tag>
        <tag>python精通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyton快速入门：6小时精通python(五)]]></title>
    <url>%2F2019%2F04%2F19%2F6%E5%B0%8F%E6%97%B6%E7%B2%BE%E9%80%9Apython-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[译自：https://learnxinyminutes.com/docs/python3/ 阅前须知： “#”后边的是注释 带行号的是python代码 不带行号的是代码的输出 把下边的语句对着敲一边自然就会了，博主用的是jupyter notebook 123###################################################### 5. 模块#################################################### 123# 可以通过import语句导入模块（包）import mathprint(math.sqrt(16)) # =&gt; 4.0 4.0 1234# 也可以通过from import语句，从包中调用特定函数from math import ceil, floorprint(ceil(3.7)) # =&gt; 4.0print(floor(3.7)) # =&gt; 3.0 4 3 123# 也可以通过*，导入包中所有函数# 不建议这样做，命名空间容易冲突（重名）from math import * 123# 也可以通过import as语句来对包名进行缩写import math as mmath.sqrt(16) == m.sqrt(16) # =&gt; True True 12345# Python包都是提前写好普通的python文件# 也可以自己写，import名称为文件名# 通过dir方法，可以看包中所有方法的directoryimport mathdir(math) [&apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;acos&apos;, &apos;acosh&apos;, &apos;asin&apos;, &apos;asinh&apos;, &apos;atan&apos;, &apos;atan2&apos;, &apos;atanh&apos;, &apos;ceil&apos;, &apos;copysign&apos;, &apos;cos&apos;, &apos;cosh&apos;, &apos;degrees&apos;, &apos;e&apos;, &apos;erf&apos;, &apos;erfc&apos;, &apos;exp&apos;, &apos;expm1&apos;, &apos;fabs&apos;, &apos;factorial&apos;, &apos;floor&apos;, &apos;fmod&apos;, &apos;frexp&apos;, &apos;fsum&apos;, &apos;gamma&apos;, &apos;gcd&apos;, &apos;hypot&apos;, &apos;inf&apos;, &apos;isclose&apos;, &apos;isfinite&apos;, &apos;isinf&apos;, &apos;isnan&apos;, &apos;ldexp&apos;, &apos;lgamma&apos;, &apos;log&apos;, &apos;log10&apos;, &apos;log1p&apos;, &apos;log2&apos;, &apos;modf&apos;, &apos;nan&apos;, &apos;pi&apos;, &apos;pow&apos;, &apos;radians&apos;, &apos;sin&apos;, &apos;sinh&apos;, &apos;sqrt&apos;, &apos;tan&apos;, &apos;tanh&apos;, &apos;tau&apos;, &apos;trunc&apos;] 123# 如果你调用了一个自己写的包# 其名称和内建包重复# 则默认调用自己写的]]></content>
      <categories>
        <category>Learn X in Y minutes</category>
        <category>Learn Python in Y minutes</category>
      </categories>
      <tags>
        <tag>6小时精通python</tag>
        <tag>python</tag>
        <tag>python3</tag>
        <tag>python精通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyton快速入门：6小时精通python(四)]]></title>
    <url>%2F2019%2F04%2F19%2F6%E5%B0%8F%E6%97%B6%E7%B2%BE%E9%80%9Apython-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[译自：https://learnxinyminutes.com/docs/python3/ 阅前须知： “#”后边的是注释 带行号的是python代码 不带行号的是代码的输出 把下边的语句对着敲一边自然就会了，博主用的是jupyter notebook 123###################################################### 4. Functions#################################################### 12345# 通过def保留字来定义函数def add(x, y): print("x is &#123;&#125; and y is &#123;&#125;".format(x, y)) # return语句用来返回处理结果 return x + y 123# 定义之后可以带参调用c = add(5, 6)print(c) x is 5 and y is 6 11 123# 如果不按照顺序输入参数，需要添加形式参数名称c = add(y=6, x=5)print(c) x is 5 and y is 6 11 1234# 也可以传入参数列表（positional arguments）def varargs(*args): print(type(args)) return args 12c = varargs(1, 2, 3)print(c) &lt;class &apos;tuple&apos;&gt; (1, 2, 3) 1234# 可以通过keyword arguments来传入多个变量def keyword_args(**kwargs): print(type(kwargs)) return kwargs 12c = keyword_args(one='1', two='2')print(c) &lt;class &apos;dict&apos;&gt; {&apos;one&apos;: &apos;1&apos;, &apos;two&apos;: &apos;2&apos;} 12345678910# 也可以混合使用def all_the_args(*args, **kwargs): print(args) print(kwargs)"""all_the_args(1, 2, a=3, b=4) prints: (1, 2) &#123;"a": 3, "b": 4&#125;""" 123456# 调用函数的时候，*和**也可以反过来使用args_call = (1, 2, 3, 4)kwargs_call = &#123;"a": 3, "b": 4&#125;all_the_args(*args_call) # equivalent to all_the_args(1, 2, 3, 4)all_the_args(**kwargs_call) # equivalent to all_the_args(a=3, b=4)all_the_args(*args_call, **kwargs_call) # equivalent to all_the_args(1, 2, 3, 4, a=3, b=4) (1, 2, 3, 4) {} () {&apos;a&apos;: 3, &apos;b&apos;: 4} (1, 2, 3, 4) {&apos;a&apos;: 3, &apos;b&apos;: 4} 12345# 一个函数可以同时返回多个值# 多个值是以不带括号的tuple的形式返回的# 但是加了括号也没关系def swap(x, y): return y, x 1234x = 1y = 2x, y = swap(x, y) # =&gt; x = 2, y = 1(x, y) = swap(x, y) # 这一句和上一句一样 123456789101112131415161718192021# 函数范围 # 这里x是一个全局变量（global）x = 5def get_x(num): # 函数内部可以访问外部全局变量 print(num) print(x) # =&gt; 5def set_x(num): # 但是不能在函数内部改变全局变量 # 这里的x是一个新生成的，只在函数内生效的局部变量 x = num # =&gt; 43 print(x) # =&gt; 43def set_global_x(num): # 如果想要在函数内部改变全局变量，需要通过global声明 global x print(x) # =&gt; 5 x = num # global var x is now set to num print(x) # =&gt; num 1get_x(6) 6 5 12set_x(6)print(x) 6 5 12set_global_x(6)print(x) 5 6 6 1234567891011# python支持头等函数# 简单来讲，return的函数就是上层函数的头等函数def create_adder(x): # suber就是简单的嵌套定义了一个函数 def suber(z): return x - z n = suber(5) # adder参与返回值，是头等函数 def adder(y): return n + y return adder 1add_10_minus_5 = create_adder(10) 1add_10_minus_5(3) 8 123# python也支持匿名函数# (lambda &lt;形式参数（列表）&gt;: &lt;return语句&gt;)(&lt;实参&gt;)(lambda x: x &gt; 2)(3) # =&gt; True True 1(lambda x, y: x ** 2 + y ** 2)(2, 1) # =&gt; 5 5 12# 匿名函数，实际上也是可以命名的check_greater_than_2 = lambda x: x &gt; 2 1check_greater_than_2(4) True 1234# 还有内建的高阶函数# 通过map将[1, 2, 3]分别装入add_10_minus_5进行运算# 返回结果包装成listlist(map(add_10_minus_5, [1, 2, 3])) [6, 7, 8] 12# max是python的内建方法，求参数中的最大值max(1,2,3) 3 123# 下面的写法就是就是对位结合，进行计算# 相当于list(max(1,4), max(2,2), max(3,1))list(map(max, [1, 2, 3], [4, 2, 1])) [4, 2, 3] 12# filter 可以把返回值为true的参数，返回出来list(filter(lambda x: x &gt; 5, [3, 4, 5, 6, 7])) # =&gt; [6, 7] [6, 7] 12# 也可以根据对列表的理解，写出漂亮的map和filter[add_10_minus_5(i) for i in [1, 2, 3]] [6, 7, 8] 1[x for x in [3, 4, 5, 6, 7] if x &gt; 5] # =&gt; [6, 7] [6, 7] 12# 也可以写出漂亮的字典或者集合&#123;x for x in 'abcddeef' if x not in 'abc'&#125; # =&gt; &#123;'d', 'e', 'f'&#125; {&apos;d&apos;, &apos;e&apos;, &apos;f&apos;} 1&#123;x: x**2 for x in range(5)&#125; # =&gt; &#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16&#125; {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}]]></content>
      <categories>
        <category>Learn X in Y minutes</category>
        <category>Learn Python in Y minutes</category>
      </categories>
      <tags>
        <tag>6小时精通python</tag>
        <tag>python</tag>
        <tag>python3</tag>
        <tag>python精通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyton快速入门：6小时精通python(三)]]></title>
    <url>%2F2019%2F04%2F19%2F6%E5%B0%8F%E6%97%B6%E7%B2%BE%E9%80%9Apython-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[译自：https://learnxinyminutes.com/docs/python3/ 阅前须知： “#”后边的是注释 带行号的是python代码 不带行号的是代码的输出 把下边的语句对着敲一边自然就会了，博主用的是jupyter notebook 123###################################################### 3. 控制流和迭代器#################################################### 123456789some_var = 5# python通过缩进来对代码进行分段（连续同缩进量的代码可以看作在一个大括号里，空行、注释行自动忽略）# 一个缩进应该是4个空格，不是制表符if some_var &gt; 10: print("some_var is totally bigger than 10.")elif some_var &lt; 10: # 可选 print("some_var is smaller than 10.")else: # 可选 print("some_var is indeed 10.") some_var is smaller than 10. 12345# for item in list# 迭代取出list中的所有item进行计算for animal in ["dog", "cat", "mouse"]: # You can use format() to interpolate formatted strings print("&#123;&#125; is a mammal".format(animal)) dog is a mammal cat is a mammal mouse is a mammal 123# range(n)方法返回一个list,[0,1,2,...,n-1]for i in range(4): print(i) 0 1 2 3 123# range(start,end)返回一个list，[start, start+1, ..., end-1]for i in range(4, 8): print(i) 4 5 6 7 123# range(start,end,step)返回一个list，[start, start+step, ..., (直到&gt;=end)]for i in range(4, 8, 2): print(i) 4 6 12345# while循环，持续迭代知道不满足判断条件x = 0while x &lt; 4: print(x) x += 1 # Shorthand for x = x + 1 0 1 2 3 12345678910111213141516# 可以通过try except来处理异常（避免报错直接退出）try: # raise方法，可以手动报错 raise IndexError("This is an index error")except IndexError as e: # pass保留字代表这一行啥不也干 passexcept (TypeError, NameError): # 如果有多个except，可以同时执行 pass# 可选，如果try的代码块没有问题，则执行else: print("All good!")# 可选，不管有没有问题，都会执行finally中的代码块finally: print("We can clean up resources here") We can clean up resources here 12345678910# 通常open(fileName)之后，需要调用close方法来释放内存# 为了避免代码出错，产生内存垃圾，需要# try:# open# finally:# close# 也可以通过with open() as name:来进行声明，该声明块结束后会自动closewith open("myfile.txt") as f: for line in f: print(line) 123456# Python提供一种基础抽象方法叫做Iterable（可迭代的）# 一个iterable对象，可以被当作sequence对待# range函数返回的对象其实就是iterablefilled_dict = &#123;"one": 1, "two": 2, "three": 3&#125;our_iterable = filled_dict.keys()print(our_iterable) # =&gt; dict_keys(['one', 'two', 'three']). This is an object that implements our Iterable interface. dict_keys([&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]) 123# iterable 可迭代，比如放到for循环中for i in our_iterable: print(i) one two three 123# 但是无法通过index取出其中的数值# 会报错our_iterable[0] --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-114-138f56ebc699&gt; in &lt;module&gt;() 1 # 但是无法通过index取出其中的数值 2 # 会报错 ----&gt; 3 our_iterable[0] TypeError: &apos;dict_keys&apos; object does not support indexing 12# iterable对象可以通过iter方法生成迭代器our_iterator = iter(our_iterable) 1our_iterator &lt;dict_keyiterator at 0x102e49db8&gt; 123# 迭代器可以在遍历过程中记录当前状态（位置）# 我们可以通过next函数取出迭代器中的下一个itemnext(our_iterator) # =&gt; "one" &apos;one&apos; 123# 当前迭代的位置会被存储下来next(our_iterator) # =&gt; "two"next(our_iterator) # =&gt; "three" &apos;three&apos; 12# 超出迭代范围，就报错next(our_iterator) --------------------------------------------------------------------------- StopIteration Traceback (most recent call last) &lt;ipython-input-119-228a51d4a8ec&gt; in &lt;module&gt;() ----&gt; 1 next(our_iterator) StopIteration: 12# 通过list方法把iterable转化为list，就可以访问所有对象了list(filled_dict.keys()) # =&gt; Returns ["one", "two", "three"] [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;]]]></content>
      <categories>
        <category>Learn X in Y minutes</category>
        <category>Learn Python in Y minutes</category>
      </categories>
      <tags>
        <tag>6小时精通python</tag>
        <tag>python</tag>
        <tag>python3</tag>
        <tag>python精通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyton快速入门：6小时精通python(二)]]></title>
    <url>%2F2019%2F04%2F19%2F6%E5%B0%8F%E6%97%B6%E7%B2%BE%E9%80%9Apython-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[译自：https://learnxinyminutes.com/docs/python3/ 阅前须知： “#”后边的是注释 带行号的是python代码 不带行号的是代码的输出 把下边的语句对着敲一边自然就会了，博主用的是jupyter notebook 123###################################################### 2. 变量和集合#################################################### 123# 输出用print()print("I'm Python. Nice to meet you!")print("I'm Python. Nice to meet you!") I&apos;m Python. Nice to meet you! I&apos;m Python. Nice to meet you! 1234# print函数默认在结束时插入换行符# 可以通过end参数改变print("Hello, World", end="!")print("Hello, World", end="!") Hello, World!Hello, World! 123# 在console命令行中获得输入，可以使用input，参数会作为提示进行输出# Note: 在python早期版本中，input函数名称为raw_inputinput_string_var = input("Enter some data: ") Enter some data: 123 1input_string_var &apos;123&apos; 1234# python中没有变量声明，只有赋值# 变量的命名惯例为小写字母，多个单词通过_连接： lower_case_with_underscoressome_var = 5some_var # =&gt; 5 5 123# 访问一个没有赋值过的变量名，会抛出异常# 直接看console中的输出来了解异常原因some_unknown_var --------------------------------------------------------------------------- NameError Traceback (most recent call last) &lt;ipython-input-48-17aa7cb5f29d&gt; in &lt;module&gt;() 1 # 访问一个没有赋值过的变量名，会抛出异常 2 # 直接看console中的输出来了解异常原因 ----&gt; 3 some_unknown_var NameError: name &apos;some_unknown_var&apos; is not defined 1234# if 可以用来作为一种表达式 # a if b else c 意为 b为True取a，b为False取choo = "yahoo!" if 3 &gt; 2 else 2 # =&gt; "yahoo!"hoo &apos;yahoo!&apos; 1234# 生成一个空的listli = []# 也可以跳过声明直接赋值other_li = [4, 5, 6] 123456789# list有append函数，可以在末尾添加itemli.append(1) # li is now [1]li.append(2) # li is now [1, 2]li.append(4) # li is now [1, 2, 4]li.append(3) # li is now [1, 2, 4, 3]# pop函数可以删除list中的最后一个元素li.pop() # =&gt; 3 and li is now [1, 2, 4]# 还是把3放回去吧li.append(3) # li is now [1, 2, 4, 3] again. 1234# 通过item的index可以访问对应位置item的值li[0] # =&gt; 1# 可以通过负数来倒着数，-1代表最后一个li[-1] # =&gt; 3 3 12# 如果index访问的item超出list长度，会抛出异常li[4] # IndexError --------------------------------------------------------------------------- IndexError Traceback (most recent call last) &lt;ipython-input-53-9bf3eba2f737&gt; in &lt;module&gt;() 1 # 如果index访问的item超出list长度，会抛出异常 ----&gt; 2 li[4] # Raises an IndexError IndexError: list index out of range 12345678910# li[start:end:step]，你可以通过分片来对list进行部分访问# li[a:b]，意为取出li中index为a的item至index为b-1的item（含头不含尾）li[1:3] # =&gt; [2, 4]# 省略头/尾的参数，则代表 从头开始/到尾结束li[:3] # =&gt; [1, 2, 4]li[2:] # =&gt; [4, 3]# li[a:b:c]意为从li中index为a开始，index每次+c取item，直至所取item的index&gt;=bli[::2] # =&gt;[1, 4]# li[a:b:c]c为负值的时候则倒着取li[::-1] # =&gt; [3, 4, 2, 1] [3, 4, 2, 1] 12345# 如果要对list进行deep copy（复制object所有内容但不是同一对象）# 使用如下语句li2 = li[:]li2 == li # =&gt; Trueli2 is li # =&gt; False False 12# del[index]方法可以删除list中index位置的元素del li[2] # li is now [1, 2, 3] 12# remove(value)方法会删除list中第一个值等于value的itemli.remove(2) 12# remove方法调用时，如果没有对应value的item，则会报错li.remove(100) --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-58-0f5f01941ba3&gt; in &lt;module&gt;() 1 # remove方法调用时，如果没有对应value的item，则会报错 ----&gt; 2 li.remove(100) ValueError: list.remove(x): x not in list 123# insert(index, value)可以在list中的index处插入值为value的itemli.insert(1, 2) # li is now [1, 2, 3] againli [1, 2, 3] 1234# index(value)方法可以在list中进行查询,返回值为value的item的indexli.index(2) # =&gt; 1# 没有的话就报错li.index(4) # Raises a ValueError as 4 is not in the list --------------------------------------------------------------------------- ValueError Traceback (most recent call last) &lt;ipython-input-60-4520a794cb71&gt; in &lt;module&gt;() 2 li.index(2) # =&gt; 1 3 # 没有的话就报错 ----&gt; 4 li.index(4) # Raises a ValueError as 4 is not in the list ValueError: 4 is not in list 123# 可以用+直接连接两个list# 这里没有进行赋值，所以li和other_li都没变li + other_li # =&gt; [1, 2, 3, 4, 5, 6] [1, 2, 3, 4, 5, 6] 123# 如果调用list内部方法，extend进行连接，则调用方法的list会默认被赋值li.extend(other_li)li [1, 2, 3, 4, 5, 6] 12# 通过in关键字，判断value是否存在在list中1 in li # =&gt; True True 12# len方法可以返回list长度len(li) # =&gt; 6 6 1234# Tuple和list相似，但是不可变tup = (1, 2, 3)tup[0] # =&gt; 1tup[0] = 3 # 赋值就报错 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-65-4b7af0c6f896&gt; in &lt;module&gt;() 2 tup = (1, 2, 3) 3 tup[0] # =&gt; 1 ----&gt; 4 tup[0] = 3 # 赋值就报错 TypeError: &apos;tuple&apos; object does not support item assignment 12345# 如果长度为1的tuple，需要在唯一的item后添加逗号','来声明自己是tuple# 否则python会把它的类型解析成唯一item的类型type((1)) # =&gt; &lt;class 'int'&gt;type((1,)) # =&gt; &lt;class 'tuple'&gt;type(()) # =&gt; &lt;class 'tuple'&gt; tuple 12345# 大部分list操作都可以应用到tuple上len(tup) # =&gt; 3tup + (4, 5, 6) # =&gt; (1, 2, 3, 4, 5, 6)tup[:2] # =&gt; (1, 2)2 in tup # =&gt; True True 12345678# 可以对tuple进行解压，分别赋值给变量a, b, c = (1, 2, 3) # a = 1, b = 2 and c = 3# 还可以进行扩展拆包a, *b, c = (1, 2, 3, 4) # a = 1, b = [2, 3] and c = 4# 如果你不写括号，tuple也会自动生成d, e, f = 4, 5, 6# 交换两个变量的值e, d = d, e # d is now 5 and e is now 4 12345# Dictionary存储的是key到value的映射# 生成空的dictempty_dict = &#123;&#125;# 也可以直接赋值filled_dict = &#123;"one": 1, "two": 2, "three": 3&#125; 12# 可以通过方括号dict[key] = value 查询对应key的值filled_dict['one'] 1 1234# dictionary中的key必须是不可变类型量（immutable type）# Immutable types 包括 ints, floats, strings, tuples.# value是啥都行invalid_dict = &#123;[1,2,3]: "123"&#125; # =&gt; TypeError: unhashable type: 'list' --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-71-b260036dbc7a&gt; in &lt;module&gt;() 2 # Immutable types 包括 ints, floats, strings, tuples. 3 # value是啥都行 ----&gt; 4 invalid_dict = {[1,2,3]: &quot;123&quot;} # =&gt; TypeError: unhashable type: &apos;list&apos; TypeError: unhashable type: &apos;list&apos; 123456# 通过dictionary中的keys()方法，可以迭代取出字典中的key# 通过list()可以将该方法的结果转化为list# python3.7之前的版本，不保证key的取出顺序# python3.7之后，key会按照在字典中的顺序取出list(filled_dict.keys()) # =&gt; ["three", "two", "one"] in Python &lt;3.7list(filled_dict.keys()) # =&gt; ["one", "two", "three"] in Python 3.7+ [&apos;one&apos;, &apos;two&apos;, &apos;three&apos;] 123# 同理，通过values方法可以取出valueslist(filled_dict.values()) # =&gt; [3, 2, 1] in Python &lt;3.7list(filled_dict.values()) # =&gt; [1, 2, 3] in Python 3.7+ [1, 2, 3, 5] 123# 通过in保留字，来检查dictionary中是否包含该key（而非value）"one" in filled_dict # =&gt; True1 in filled_dict # =&gt; False False 12# 取一个字典中不存在的key的value会报错filled_dict["four"] # KeyError --------------------------------------------------------------------------- KeyError Traceback (most recent call last) &lt;ipython-input-75-6e19dabe2a92&gt; in &lt;module&gt;() 1 # 取一个字典中不存在的key的value会报错 ----&gt; 2 filled_dict[&quot;four&quot;] # KeyError KeyError: &apos;four&apos; 123456# 通过get方法，可以避免报错，如果没有，返回Nonefilled_dict.get("one") # =&gt; 1filled_dict.get("four") # =&gt; None# 也可以在get方法中增加第二个参数，来代替查询不到时，默认返回的Nonefilled_dict.get("one", 4) # =&gt; 1filled_dict.get("four", 4) # =&gt; 4 4 1234# setdefault方法可以给不存在的key赋值# 如果该键值对（key:value）已存在，则不生效filled_dict.setdefault("five", 5) # filled_dict["five"] is set to 5filled_dict.setdefault("five", 6) # filled_dict["five"] is still 5 5 1234# 在dictionary中增加键值对，可以使用update方法filled_dict.update(&#123;"four":4&#125;) # =&gt; &#123;"one": 1, "two": 2, "three": 3, "four": 4&#125;# 直接对不存在的key 进行赋值，也可以实现键值对的增加filled_dict["four"] = 4 # another way to add to dict 12# 通过del方法可以删除对应key的键值对del filled_dict["one"] # Removes the key "one" from filled dict 123# 在python3.5之后，也可以通过**&#123;&#125;来完成补充扩展操作&#123;'a': 1, **&#123;'b': 2&#125;&#125; # =&gt; &#123;'a': 1, 'b': 2&#125;&#123;'a': 1, **&#123;'a': 2&#125;&#125; # =&gt; &#123;'a': 2&#125; {&apos;a&apos;: 2} 1234# set也是通过&#123;&#125;进行包装的，定义空set时，需要调用set方法empty_set = set()# set中的值不能重复（重复值会自动合并）some_set = &#123;1, 1, 2, 2, 3, 4&#125; # some_set is now &#123;1, 2, 3, 4&#125; 123# 和dictionary中的key相似，set的item必须是不可变类型量（也就是list不行）# set可以看作是一个只有key的dictionaryinvalid_set = &#123;[1], 1&#125; # =&gt; Raises a TypeError: unhashable type: 'list' --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-85-c6f31d84eee9&gt; in &lt;module&gt;() 1 # 和dictionary中的key相似，set的item必须是不可变类型量（也就是list不行） 2 # set可以看作是一个只有key的dictionary ----&gt; 3 invalid_set = {[1], 1} # =&gt; Raises a TypeError: unhashable type: &apos;list&apos; 4 # tuple就可以 5 valid_set = {(1,), 1} TypeError: unhashable type: &apos;list&apos; 12345# 通过add方法向set中添加itemfilled_set = some_setfilled_set.add(5) # filled_set is now &#123;1, 2, 3, 4, 5&#125;# 重复添加无效filled_set.add(5) # it remains as before &#123;1, 2, 3, 4, 5&#125; 123# 可以通过&amp;运算，来取交集other_set = &#123;3, 4, 5, 6&#125;filled_set &amp; other_set # =&gt; &#123;3, 4, 5&#125; {3, 4, 5} 12# 可以通过|取并集filled_set | other_set # =&gt; &#123;1, 2, 3, 4, 5, 6&#125; {1, 2, 3, 4, 5, 6} 12# 也可以通过-做集合减法（第一个有第二个没有的）&#123;1, 2, 3, 4&#125; - &#123;2, 3, 5&#125; # =&gt; &#123;1, 4&#125; {1, 4} 12# 可以通过^做对称减法（相当于并集减交集）&#123;1, 2, 3, 4&#125; ^ &#123;2, 3, 5&#125; # =&gt; &#123;1, 4, 5&#125; {1, 4, 5} 123# 通过大于小于号检查包含关系&#123;1, 2&#125; &gt;= &#123;1, 2, 3&#125; # =&gt; False&#123;1, 2&#125; &lt;= &#123;1, 2, 3&#125; # =&gt; True True 123# 通过in检查set中是否存在该item2 in filled_set # =&gt; True10 in filled_set # =&gt; False False]]></content>
      <categories>
        <category>Learn X in Y minutes</category>
        <category>Learn Python in Y minutes</category>
      </categories>
      <tags>
        <tag>6小时精通python</tag>
        <tag>python</tag>
        <tag>python3</tag>
        <tag>python精通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyton快速入门：6小时精通python(一)]]></title>
    <url>%2F2019%2F04%2F19%2F6%E5%B0%8F%E6%97%B6%E7%B2%BE%E9%80%9Apython-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[译自：https://learnxinyminutes.com/docs/python3/ 阅前须知： “#”后边的是注释 带行号的是python代码 不带行号的是代码的输出 把下边的语句对着敲一边自然就会了，博主用的是jupyter notebook 123###################################################### 1. 简单数据类型和运算#################################################### 12# 数学运算1 + 1 2 12# 除法默认会返回float（与python2不同）10 / 2 5.0 12# 除法取整(乡下取整)5 // 3 1 1-5 // 3 -2 12# 如果需要返回float，至少需要有一个参与运算的数字是float5 // 3.0 1.0 12# 余数运算7 % 3 1 12# 幂运算2 ** 3 8 123456789101112131415# # &amp; | ^ ~是按位运算符，这里不讲了# # &lt;&lt; &gt;&gt; 是移位运算符，这里就不展示了# a = 0011 1100# b = 0000 1101# -----------------# a&amp;b = 0000 1100# a|b = 0011 1101# a^b = 0011 0001# ~a = 1100 0011 12# 使用括号强制优先(1 + 3) * 2 8 123# Boolean值有保留字TrueFalse 123# 取反用关键字notnot Truenot False 12# 逻辑运算 and orTrue and False False 1True or False True 1234# 参与数字运算的时候 True默认为1 False为0True + True # =&gt; 2True * 8 # =&gt; 8False - 5 # =&gt; -5 12345# 与数字进行比较运算时，也按照1 0 来进行比较0 == False # =&gt; True1 == True # =&gt; True2 == True # =&gt; False-5 != False # =&gt; True 12345# 可以通过bool()，将int数值投射到bool值上# 出了0是False，其他都是Truebool(0) # =&gt; Falsebool(4) # =&gt; Truebool(-6) # =&gt; True 123# 用boolean运算符直接对int数值进行计算，计算过程按照bool，返回的值依然是int0 and 2 # =&gt; 0-5 or 0 # =&gt; -5 123# 赋值是单等号 =，相等判断是双等号 ==1 == 1 # =&gt; True2 == 1 # =&gt; False 123# 不相等判断 !=1 != 1 # =&gt; False2 != 1 # =&gt; True 12345# 数学比较1 &lt; 10 # =&gt; True1 &gt; 10 # =&gt; False2 &lt;= 2 # =&gt; True2 &gt;= 2 # =&gt; True 123456# 判断2是否在一个范围内1 &lt; 2 and 2 &lt; 3 # =&gt; True4 &lt; 2 and 2 &lt; 5 # =&gt; False# 也可以通过链式写法1 &lt; 2 &lt; 3 # =&gt; True4 &lt; 2 &lt; 5 # =&gt; False 1234567891011# 赋值是单等号 =，相等判断是双等号 ==# 还有一个相等判断保留字 is# is 判断前后两者是否指向同一个对象（如果是两个对象，就算值相同，也会返回False）# == 只判断值是否相同a = [1, 2, 3, 4] # Point a at a new list, [1, 2, 3, 4]b = a # Point b at what a is pointing tob is a # =&gt; True, a and b refer to the same objectb == a # =&gt; True, a's and b's objects are equalb = [1, 2, 3, 4] # Point b at a new list, [1, 2, 3, 4]b is a # =&gt; False, a and b do not refer to the same objectb == a # =&gt; True, a's and b's objects are equal 123# 通过‘或者“可以创建string"This is a string."'This is also a string.' 1234# String也可以通过+连接，但是尽量不要"Hello " + "world!" # =&gt; "Hello world!"# 中间不写，也会自动连接"Hello " "world!" # =&gt; "Hello world!" &apos;Hello world!&apos; 12# 一个string可以看作是一个char的list"This is a string"[0] # =&gt; 'T' &apos;T&apos; 12# len()是一个保留函数，可以计算list的长度len("This is a string") # =&gt; 16 16 12# python中的string对象，有.format方法，可以用来对该string进行格式化操作"&#123;&#125; can be &#123;&#125;".format("Strings", "interpolated") # =&gt; "Strings can be interpolated" &apos;Strings can be interpolated&apos; 12# 可以通过在大括号&#123;&#125;中添加format参数的index来进行填充指定"&#123;0&#125; be nimble, &#123;0&#125; be quick, &#123;0&#125; jump over the &#123;1&#125;".format("Jack", "candle stick") &apos;Jack be nimble, Jack be quick, Jack jump over the candle stick&apos; 12# 也可以给format中的参数命名，来代替index."&#123;name&#125; wants to eat &#123;food&#125;".format(name="Bob", food="lasagna") &apos;Bob wants to eat lasagna&apos; 12# 如果需要兼容python2，老版的format写法如下"%s can be %s the %s way" % ("Strings", "interpolated", "old") &apos;Strings can be interpolated the old way&apos; 12345# 在python3.6之后的版本中，可以在string前加f来进行format操作name = "Reiko"f"She said her name is &#123;name&#125;." # =&gt; "She said her name is Reiko"# 在大括号中，也可以调用python的方法f"&#123;name&#125; is &#123;len(name)&#125; characters long." &apos;Reiko is 5 characters long.&apos; 12345# None也是一个对象，不是一个值Nonea1 = Falseb1 = Nonea1 is b1 False 1234# 不要用==来和None进行比较# 要通过is来判断变量是不是None"etc" is None # =&gt; FalseNone is None # =&gt; True True 1234567# None, 0, 以及空的 strings/lists/dicts/tuples 都等于 False.# All other values are Truebool(0) # =&gt; Falsebool("") # =&gt; Falsebool([]) # =&gt; Falsebool(&#123;&#125;) # =&gt; Falsebool(()) # =&gt; False False]]></content>
      <categories>
        <category>Learn X in Y minutes</category>
        <category>Learn Python in Y minutes</category>
      </categories>
      <tags>
        <tag>6小时精通python</tag>
        <tag>python</tag>
        <tag>python3</tag>
        <tag>python精通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过python进行数据分析(二)]]></title>
    <url>%2F2019%2F04%2F15%2F%E9%80%9A%E8%BF%87python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[Counting time zones with pandas1234# %matplotlib主要是在使用jupyter notebook 或者 jupyter qtconsole的时候才会用到# 具体作用是当你调用matplotlib.pyplot的绘图函数plot()进行绘图的时候，可以直接在你的python console里面生成图像# 默认是弹出一个绘图窗口%matplotlib inline 123456789101112131415161718# python有多个版本，Python 2.7到Python 3.x，Python提供了__future__模块，把3.x新版本的特性导入到当前版本# 这一句的意思是除法按照python3来：# 区别就是python2里边10/3=3，python3里边10/3=3.3333333333333335from __future__ import division# 导入numpy中的随机函数randnfrom numpy.random import randn# 到处numpy包，并命名为npimport numpy as np# 导入os包import os# 导入matplotlib.pyplot，并命名为plt，主要用于绘图import matplotlib.pyplot as plt# 导入pandas包，并命名为pdimport pandas as pd# 利用rc方法，plt.rc('figure',figsize=(10,6))全局默认图像大小为10X6plt.rc('figure', figsize=(10, 6))# numpy set print options 小数点后4位np.set_printoptions(precision=4) 1234567# 导入json包import json# 赋值path = 'ch02/usagov_bitly_data2012-03-16-1331923249.txt'# 逐行遍历path文件中的数据，通过按照json格式读取，然后每一行的作为一个item组成listlines = open(path).readlines()records = [json.loads(line) for line in lines] 123456789# 导入pandas的两个方法from pandas import DataFrame, Series# 导入pandas包，并命名为pdimport pandas as pd# 建立DataFrame对象，把key作为列名，value作为值填到一张表中，没有的键值对会用NaN（空值）填充# 并自动生成索引，就是左边的0 1 2 3...frame = DataFrame(records)# 打印出来看一下（这是一个pandas对象）print(frame) _heartbeat_ a \ 0 NaN Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... 1 NaN GoogleMaps/RochesterNY 2 NaN Mozilla/4.0 (compatible; MSIE 8.0; Windows NT ... 3 NaN Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8)... 4 NaN Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... 5 NaN Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... 6 NaN Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1... 7 NaN Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/2... 8 NaN Opera/9.80 (X11; Linux zbov; U; en) Presto/2.1... 9 NaN Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... 10 NaN Mozilla/5.0 (Windows NT 6.1; WOW64; rv:10.0.2)... 11 NaN Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.4... 12 NaN Mozilla/5.0 (Windows NT 6.1; WOW64; rv:10.0.2)... 13 1.331923e+09 NaN 14 NaN Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US... 15 NaN Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1... 16 NaN Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1... 17 NaN Mozilla/5.0 (Macintosh; Intel Mac OS X 10.5; r... 18 NaN GoogleMaps/RochesterNY 19 NaN Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... 20 NaN Mozilla/5.0 (compatible; MSIE 9.0; Windows NT ... 21 NaN Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.6... 22 NaN Mozilla/4.0 (compatible; MSIE 8.0; Windows NT ... 23 NaN Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3)... 24 NaN Mozilla/5.0 (Windows; U; Windows NT 5.1; es-ES... 25 NaN Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1... 26 NaN Mozilla/5.0 (Windows NT 6.1) AppleWebKit/535.1... 27 NaN Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8)... 28 NaN Mozilla/5.0 (iPad; CPU OS 5_0_1 like Mac OS X)... 29 NaN Mozilla/5.0 (iPad; U; CPU OS 3_2 like Mac OS X... ... ... ... 3530 NaN Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1... 3531 NaN Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6... 3532 NaN Mozilla/5.0 (Windows NT 6.1; WOW64; rv:10.0.2)... 3533 NaN Mozilla/5.0 (iPad; CPU OS 5_1 like Mac OS X) A... 3534 NaN Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8)... 3535 NaN Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/... 3536 NaN Mozilla/5.0 (BlackBerry; U; BlackBerry 9800; e... 3537 NaN Mozilla/5.0 (Windows NT 6.1; WOW64; rv:10.0.2)... 3538 NaN Mozilla/5.0 (iPhone; CPU iPhone OS 5_1 like Ma... 3539 NaN Mozilla/5.0 (compatible; Fedora Core 3) FC3 KDE 3540 NaN Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... 3541 NaN Mozilla/5.0 (X11; U; OpenVMS AlphaServer_ES40;... 3542 NaN Mozilla/5.0 (compatible; MSIE 9.0; Windows NT ... 3543 1.331927e+09 NaN 3544 NaN Mozilla/5.0 (Windows NT 6.1; WOW64; rv:5.0.1) ... 3545 NaN Mozilla/5.0 (Windows NT 6.1; WOW64; rv:10.0.2)... 3546 NaN Mozilla/5.0 (iPhone; CPU iPhone OS 5_1 like Ma... 3547 NaN Mozilla/5.0 (Macintosh; Intel Mac OS X 10_6_8)... 3548 NaN Mozilla/5.0 (iPhone; CPU iPhone OS 5_1 like Ma... 3549 NaN Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... 3550 NaN Mozilla/4.0 (compatible; MSIE 8.0; Windows NT ... 3551 NaN Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKi... 3552 NaN Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US... 3553 NaN Mozilla/4.0 (compatible; MSIE 7.0; Windows NT ... 3554 NaN Mozilla/4.0 (compatible; MSIE 7.0; Windows NT ... 3555 NaN Mozilla/4.0 (compatible; MSIE 9.0; Windows NT ... 3556 NaN Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.1... 3557 NaN GoogleMaps/RochesterNY 3558 NaN GoogleProducer 3559 NaN Mozilla/4.0 (compatible; MSIE 8.0; Windows NT ... al c cy g \ 0 en-US,en;q=0.8 US Danvers A6qOVH 1 NaN US Provo mwszkS 2 en-US US Washington xxr3Qb 3 pt-br BR Braz zCaLwp 4 en-US,en;q=0.8 US Shrewsbury 9b6kNl 5 en-US,en;q=0.8 US Shrewsbury axNK8c 6 pl-PL,pl;q=0.8,en-US;q=0.6,en;q=0.4 PL Luban wcndER 7 bg,en-us;q=0.7,en;q=0.3 None NaN wcndER 8 en-US, en None NaN wcndER 9 pt-BR,pt;q=0.8,en-US;q=0.6,en;q=0.4 None NaN zCaLwp 10 en-us,en;q=0.5 US Seattle vNJS4H 11 en-us,en;q=0.5 US Washington wG7OIH 12 en-us,en;q=0.5 US Alexandria vNJS4H 13 NaN NaN NaN NaN 14 en-us,en;q=0.5 US Marietta 2rOUYc 15 zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4 HK Central District nQvgJp 16 zh-TW,zh;q=0.8,en-US;q=0.6,en;q=0.4 HK Central District XdUNr 17 en-us,en;q=0.5 US Buckfield zH1BFf 18 NaN US Provo mwszkS 19 it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4 IT Venice wcndER 20 es-ES ES Alcal zQ95Hi 21 en-us,en;q=0.5 US Davidsonville wcndER 22 en-us US Hockessin y3ZImz 23 en-us US Lititz wWiOiD 24 es-es,es;q=0.8,en-us;q=0.5,en;q=0.3 ES Bilbao wcndER 25 en-GB,en;q=0.8,en-US;q=0.6,en-AU;q=0.4 MY Kuala Lumpur wcndER 26 ro-RO,ro;q=0.8,en-US;q=0.6,en;q=0.4 CY Nicosia wcndER 27 en-US,en;q=0.8 BR SPaulo zCaLwp 28 en-us None NaN vNJS4H 29 en-us None NaN FPX0IM ... ... ... ... ... 3530 en-US,en;q=0.8 US San Francisco xVZg4P 3531 en-US None NaN wcndER 3532 en-us,en;q=0.5 US Washington Au3aUS 3533 en-us US Jacksonville b2UtUJ 3534 en-us US Frisco vNJS4H 3535 en-us US Houston zIgLx8 3536 en-US,en;q=0.5 None NaN xIcyim 3537 es-es,es;q=0.8,en-us;q=0.5,en;q=0.3 HN Tegucigalpa zCaLwp 3538 en-us US Los Angeles qMac9k 3539 NaN US Bellevue zu2M5o 3540 en-US,en;q=0.8 US Payson wcndER 3541 NaN US Bellevue zu2M5o 3542 en-us US Pittsburg y3reI1 3543 NaN NaN NaN NaN 3544 en-us,en;q=0.5 US Wentzville vNJS4H 3545 en-us,en;q=0.5 US Saint Charles vNJS4H 3546 en-us US Los Angeles qMac9k 3547 en-us US Silver Spring y0jYkg 3548 en-us US Mcgehee y5rMac 3549 sv-SE,sv;q=0.8,en-US;q=0.6,en;q=0.4 SE Sollefte eH8wu 3550 en-us US Conshohocken A00b72 3551 en-US,en;q=0.8 None NaN wcndER 3552 NaN US Decatur rqgJuE 3553 en-us US Shrewsbury 9b6kNl 3554 en-us US Shrewsbury axNK8c 3555 en US Paramus e5SvKE 3556 en-US,en;q=0.8 US Oklahoma City jQLtP4 3557 NaN US Provo mwszkS 3558 NaN US Mountain View zjtI4X 3559 en-US US Mc Lean qxKrTK gr h hc hh kw l \ 0 MA wfLQtf 1.331823e+09 1.usa.gov NaN orofrog 1 UT mwszkS 1.308262e+09 j.mp NaN bitly 2 DC xxr3Qb 1.331920e+09 1.usa.gov NaN bitly 3 27 zUtuOu 1.331923e+09 1.usa.gov NaN alelex88 4 MA 9b6kNl 1.273672e+09 bit.ly NaN bitly 5 MA axNK8c 1.273673e+09 bit.ly NaN bitly 6 77 zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 7 NaN zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 8 NaN zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 9 NaN zUtuOu 1.331923e+09 1.usa.gov NaN alelex88 10 WA u0uD9q 1.319564e+09 1.usa.gov NaN o_4us71ccioa 11 DC A0nRz4 1.331816e+09 1.usa.gov NaN darrellissa 12 VA u0uD9q 1.319564e+09 1.usa.gov NaN o_4us71ccioa 13 NaN NaN NaN NaN NaN NaN 14 GA 2rOUYc 1.255770e+09 1.usa.gov NaN bitly 15 00 rtrrth 1.317318e+09 j.mp NaN walkeryuen 16 00 qWkgbq 1.317318e+09 j.mp NaN walkeryuen 17 ME x3jOIv 1.331840e+09 1.usa.gov NaN andyzieminski 18 UT mwszkS 1.308262e+09 1.usa.gov NaN bitly 19 20 zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 20 51 ytZYWR 1.331671e+09 bitly.com NaN jplnews 21 MD zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 22 DE y3ZImz 1.331064e+09 1.usa.gov NaN bitly 23 PA wWiOiD 1.330218e+09 1.usa.gov NaN bitly 24 59 zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 25 14 zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 26 04 zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 27 27 zUtuOu 1.331923e+09 1.usa.gov NaN alelex88 28 NaN u0uD9q 1.319564e+09 1.usa.gov NaN o_4us71ccioa 29 NaN FPX0IL 1.331923e+09 1.usa.gov NaN twittershare ... ... ... ... ... ... ... 3530 CA wqUkTo 1.331908e+09 go.nasa.gov NaN nasatwitter 3531 NaN zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 3532 DC A9ct6C 1.331926e+09 1.usa.gov NaN ncsha 3533 FL ieCdgH 1.301393e+09 go.nasa.gov NaN nasatwitter 3534 TX u0uD9q 1.319564e+09 1.usa.gov NaN o_4us71ccioa 3535 TX yrPaLt 1.331903e+09 aash.to NaN aashto 3536 NaN yG1TTf 1.331728e+09 go.nasa.gov NaN nasatwitter 3537 08 w63FZW 1.331547e+09 1.usa.gov NaN bufferapp 3538 CA qds1Ge 1.310474e+09 1.usa.gov NaN healthypeople 3539 WA zDhdro 1.331586e+09 bit.ly NaN glimtwin 3540 UT zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 3541 WA zDhdro 1.331586e+09 1.usa.gov NaN glimtwin 3542 CA y3reI1 1.331926e+09 1.usa.gov NaN bitly 3543 NaN NaN NaN NaN NaN NaN 3544 MO u0uD9q 1.319564e+09 1.usa.gov NaN o_4us71ccioa 3545 IL u0uD9q 1.319564e+09 1.usa.gov NaN o_4us71ccioa 3546 CA qds1Ge 1.310474e+09 1.usa.gov NaN healthypeople 3547 MD y0jYkg 1.331852e+09 1.usa.gov NaN bitly 3548 AR xANY6O 1.331916e+09 1.usa.gov NaN twitterfeed 3549 24 7dtjei 1.260316e+09 1.usa.gov NaN tweetdeckapi 3550 PA yGSwzn 1.331918e+09 1.usa.gov NaN addthis 3551 NaN zkpJBR 1.331923e+09 1.usa.gov NaN bnjacobs 3552 AL xcz8vt 1.331227e+09 1.usa.gov NaN bootsnall 3553 MA 9b6kNl 1.273672e+09 bit.ly NaN bitly 3554 MA axNK8c 1.273673e+09 bit.ly NaN bitly 3555 NJ fqPSr9 1.301298e+09 1.usa.gov NaN tweetdeckapi 3556 OK jQLtP4 1.307530e+09 1.usa.gov NaN bitly 3557 UT mwszkS 1.308262e+09 j.mp NaN bitly 3558 CA zjtI4X 1.327529e+09 1.usa.gov NaN bitly 3559 VA qxKrTK 1.312898e+09 1.usa.gov NaN bitly ll nk \ 0 [42.576698, -70.954903] 1.0 1 [40.218102, -111.613297] 0.0 2 [38.9007, -77.043098] 1.0 3 [-23.549999, -46.616699] 0.0 4 [42.286499, -71.714699] 0.0 5 [42.286499, -71.714699] 0.0 6 [51.116699, 15.2833] 0.0 7 NaN 0.0 8 NaN 0.0 9 NaN 0.0 10 [47.5951, -122.332603] 1.0 11 [38.937599, -77.092796] 0.0 12 [38.790901, -77.094704] 1.0 13 NaN NaN 14 [33.953201, -84.5177] 1.0 15 [22.2833, 114.150002] 1.0 16 [22.2833, 114.150002] 1.0 17 [44.299702, -70.369797] 0.0 18 [40.218102, -111.613297] 0.0 19 [45.438599, 12.3267] 0.0 20 [37.516701, -5.9833] 0.0 21 [38.939201, -76.635002] 0.0 22 [39.785, -75.682297] 0.0 23 [40.174999, -76.3078] 0.0 24 [43.25, -2.9667] 0.0 25 [3.1667, 101.699997] 0.0 26 [35.166698, 33.366699] 0.0 27 [-23.5333, -46.616699] 0.0 28 NaN 0.0 29 NaN 1.0 ... ... ... 3530 [37.7645, -122.429398] 0.0 3531 NaN 0.0 3532 [38.904202, -77.031998] 1.0 3533 [30.279301, -81.585098] 1.0 3534 [33.149899, -96.855499] 1.0 3535 [29.775499, -95.415199] 1.0 3536 NaN 0.0 3537 [14.1, -87.216698] 0.0 3538 [34.041599, -118.298798] 0.0 3539 [47.615398, -122.210297] 0.0 3540 [40.014198, -111.738899] 0.0 3541 [47.615398, -122.210297] 0.0 3542 [38.0051, -121.838699] 0.0 3543 NaN NaN 3544 [38.790001, -90.854897] 1.0 3545 [41.9352, -88.290901] 1.0 3546 [34.041599, -118.298798] 1.0 3547 [39.052101, -77.014999] 1.0 3548 [33.628399, -91.356903] 1.0 3549 [63.166698, 17.266701] 1.0 3550 [40.0798, -75.2855] 0.0 3551 NaN 0.0 3552 [34.572701, -86.940598] 0.0 3553 [42.286499, -71.714699] 0.0 3554 [42.286499, -71.714699] 0.0 3555 [40.9445, -74.07] 1.0 3556 [35.4715, -97.518997] 0.0 3557 [40.218102, -111.613297] 0.0 3558 [37.419201, -122.057404] 0.0 3559 [38.935799, -77.162102] 0.0 r t \ 0 http://www.facebook.com/l/7AQEFzjSi/1.usa.gov/... 1.331923e+09 1 http://www.AwareMap.com/ 1.331923e+09 2 http://t.co/03elZC4Q 1.331923e+09 3 direct 1.331923e+09 4 http://www.shrewsbury-ma.gov/selco/ 1.331923e+09 5 http://www.shrewsbury-ma.gov/selco/ 1.331923e+09 6 http://plus.url.google.com/url?sa=z&amp;n=13319232... 1.331923e+09 7 http://www.facebook.com/ 1.331923e+09 8 http://www.facebook.com/l.php?u=http%3A%2F%2F1... 1.331923e+09 9 http://t.co/o1Pd0WeV 1.331923e+09 10 direct 1.331923e+09 11 http://t.co/ND7SoPyo 1.331923e+09 12 direct 1.331923e+09 13 NaN NaN 14 direct 1.331923e+09 15 http://forum2.hkgolden.com/view.aspx?type=BW&amp;m... 1.331923e+09 16 http://forum2.hkgolden.com/view.aspx?type=BW&amp;m... 1.331923e+09 17 http://t.co/6Cx4ROLs 1.331923e+09 18 http://www.AwareMap.com/ 1.331923e+09 19 http://www.facebook.com/ 1.331923e+09 20 http://www.facebook.com/ 1.331923e+09 21 http://www.facebook.com/ 1.331923e+09 22 direct 1.331923e+09 23 http://www.facebook.com/l.php?u=http%3A%2F%2F1... 1.331923e+09 24 http://www.facebook.com/ 1.331923e+09 25 http://www.facebook.com/ 1.331923e+09 26 http://www.facebook.com/?ref=tn_tnmn 1.331923e+09 27 direct 1.331923e+09 28 direct 1.331923e+09 29 http://t.co/5xlp0B34 1.331923e+09 ... ... ... 3530 http://www.facebook.com/l.php?u=http%3A%2F%2Fg... 1.331927e+09 3531 direct 1.331927e+09 3532 http://www.ncsha.org/ 1.331927e+09 3533 direct 1.331927e+09 3534 direct 1.331927e+09 3535 direct 1.331927e+09 3536 http://t.co/g1VKE8zS 1.331927e+09 3537 http://t.co/A8TJyibE 1.331927e+09 3538 direct 1.331927e+09 3539 direct 1.331927e+09 3540 http://www.facebook.com/l.php?u=http%3A%2F%2F1... 1.331927e+09 3541 direct 1.331927e+09 3542 http://www.facebook.com/l.php?u=http%3A%2F%2F1... 1.331927e+09 3543 NaN NaN 3544 direct 1.331927e+09 3545 direct 1.331927e+09 3546 direct 1.331927e+09 3547 direct 1.331927e+09 3548 https://twitter.com/fdarecalls/status/18069759... 1.331927e+09 3549 direct 1.331927e+09 3550 http://www.linkedin.com/home?trk=hb_tab_home_top 1.331927e+09 3551 http://plus.url.google.com/url?sa=z&amp;n=13319268... 1.331927e+09 3552 direct 1.331927e+09 3553 http://www.shrewsbury-ma.gov/selco/ 1.331927e+09 3554 http://www.shrewsbury-ma.gov/selco/ 1.331927e+09 3555 direct 1.331927e+09 3556 http://www.facebook.com/l.php?u=http%3A%2F%2F1... 1.331927e+09 3557 http://www.AwareMap.com/ 1.331927e+09 3558 direct 1.331927e+09 3559 http://t.co/OEEEvwjU 1.331927e+09 tz u 0 America/New_York http://www.ncbi.nlm.nih.gov/pubmed/22415991 1 America/Denver http://www.monroecounty.gov/etc/911/rss.php 2 America/New_York http://boxer.senate.gov/en/press/releases/0316... 3 America/Sao_Paulo http://apod.nasa.gov/apod/ap120312.html 4 America/New_York http://www.shrewsbury-ma.gov/egov/gallery/1341... 5 America/New_York http://www.shrewsbury-ma.gov/egov/gallery/1341... 6 Europe/Warsaw http://www.nasa.gov/mission_pages/nustar/main/... 7 http://www.nasa.gov/mission_pages/nustar/main/... 8 http://www.nasa.gov/mission_pages/nustar/main/... 9 http://apod.nasa.gov/apod/ap120312.html 10 America/Los_Angeles https://www.nysdot.gov/rexdesign/design/commun... 11 America/New_York http://oversight.house.gov/wp-content/uploads/... 12 America/New_York https://www.nysdot.gov/rexdesign/design/commun... 13 NaN NaN 14 America/New_York http://toxtown.nlm.nih.gov/index.php 15 Asia/Hong_Kong http://www.ssd.noaa.gov/PS/TROP/TCFP/data/curr... 16 Asia/Hong_Kong http://www.usno.navy.mil/NOOC/nmfc-ph/RSS/jtwc... 17 America/New_York http://www.usda.gov/wps/portal/usda/usdahome?c... 18 America/Denver http://www.monroecounty.gov/etc/911/rss.php 19 Europe/Rome http://www.nasa.gov/mission_pages/nustar/main/... 20 Africa/Ceuta http://voyager.jpl.nasa.gov/imagesvideo/uranus... 21 America/New_York http://www.nasa.gov/mission_pages/nustar/main/... 22 America/New_York http://portal.hud.gov/hudportal/documents/hudd... 23 America/New_York http://www.tricare.mil/mybenefit/ProfileFilter... 24 Europe/Madrid http://www.nasa.gov/mission_pages/nustar/main/... 25 Asia/Kuala_Lumpur http://www.nasa.gov/mission_pages/nustar/main/... 26 Asia/Nicosia http://www.nasa.gov/mission_pages/nustar/main/... 27 America/Sao_Paulo http://apod.nasa.gov/apod/ap120312.html 28 https://www.nysdot.gov/rexdesign/design/commun... 29 http://www.ed.gov/news/media-advisories/us-dep... ... ... ... 3530 America/Los_Angeles http://www.nasa.gov/multimedia/imagegallery/im... 3531 http://www.nasa.gov/mission_pages/nustar/main/... 3532 America/New_York http://portal.hud.gov/hudportal/HUD?src=/press... 3533 America/New_York http://apod.nasa.gov/apod/ 3534 America/Chicago https://www.nysdot.gov/rexdesign/design/commun... 3535 America/Chicago http://ntl.bts.gov/lib/44000/44300/44374/FHWA-... 3536 http://www.nasa.gov/mission_pages/hurricanes/a... 3537 America/Tegucigalpa http://apod.nasa.gov/apod/ap120312.html 3538 America/Los_Angeles http://healthypeople.gov/2020/connect/webinars... 3539 America/Los_Angeles http://www.federalreserve.gov/newsevents/press... 3540 America/Denver http://www.nasa.gov/mission_pages/nustar/main/... 3541 America/Los_Angeles http://www.federalreserve.gov/newsevents/press... 3542 America/Los_Angeles http://www.sba.gov/community/blogs/community-b... 3543 NaN NaN 3544 America/Chicago https://www.nysdot.gov/rexdesign/design/commun... 3545 America/Chicago https://www.nysdot.gov/rexdesign/design/commun... 3546 America/Los_Angeles http://healthypeople.gov/2020/connect/webinars... 3547 America/New_York http://www.epa.gov/otaq/regs/fuels/additive/e1... 3548 America/Chicago http://www.fda.gov/Safety/Recalls/ucm296326.htm 3549 Europe/Stockholm http://www.nasa.gov/mission_pages/WISE/main/in... 3550 America/New_York http://www.nlm.nih.gov/medlineplus/news/fullst... 3551 http://www.nasa.gov/mission_pages/nustar/main/... 3552 America/Chicago http://travel.state.gov/passport/passport_5535... 3553 America/New_York http://www.shrewsbury-ma.gov/egov/gallery/1341... 3554 America/New_York http://www.shrewsbury-ma.gov/egov/gallery/1341... 3555 America/New_York http://www.fda.gov/AdvisoryCommittees/Committe... 3556 America/Chicago http://www.okc.gov/PublicNotificationSystem/Fo... 3557 America/Denver http://www.monroecounty.gov/etc/911/rss.php 3558 America/Los_Angeles http://www.ahrq.gov/qual/qitoolkit/ 3559 America/New_York http://herndon-va.gov/Content/public_safety/Pu... [3560 rows x 18 columns] 123# 打印frame这个表中的‘tz’列的前10行# 注意，这还是一个pandas对象，出了索引，还有Name：tz，dtype（数据类型）：objectprint(frame['tz'][:10]) 0 America/New_York 1 America/Denver 2 America/New_York 3 America/Sao_Paulo 4 America/New_York 5 America/New_York 6 Europe/Warsaw 7 8 9 Name: tz, dtype: object 12345# 统计frame表格中‘tz’列的值的出现次数tz_counts = frame['tz'].value_counts()# 输出前10个看看# 空值出现了521次print(tz_counts[:10]) America/New_York 1251 521 America/Chicago 400 America/Los_Angeles 382 America/Denver 191 Europe/London 74 Asia/Tokyo 37 Pacific/Honolulu 36 Europe/Madrid 35 America/Sao_Paulo 33 Name: tz, dtype: int64 123456789# 空值处理起来会比较麻烦（直接进行操作容易报错）# fillna（str）方法可以直接用str替代所有的空值clean_tz = frame['tz'].fillna('Missing')# 上边替代的不存在key的空值，但是还有另一种空值，key是存在的，但是value是空的（可以看作长度是0的字符串）# 这里把所有value是‘’的替代成'Unknown'clean_tz[clean_tz == ''] = 'Unknown'# 我们再重新统计一遍看看tz_counts = clean_tz.value_counts()print(tz_counts[:10]) America/New_York 1251 Unknown 521 America/Chicago 400 America/Los_Angeles 382 America/Denver 191 Missing 120 Europe/London 74 Asia/Tokyo 37 Pacific/Honolulu 36 Europe/Madrid 35 Name: tz, dtype: int64 12# 定义画布尺寸为10*4 单位是英寸plt.figure(figsize=(10, 4)) &lt;matplotlib.figure.Figure at 0x10d7ae940&gt; &lt;matplotlib.figure.Figure at 0x10d7ae940&gt; 123456789101112131415# 把tz_counts的统计结果绘制成图，类型为柱状图bar，横向h（horizontal）# kind : str# ‘line’ : line plot (default)# ‘bar’ : vertical bar plot# ‘barh’ : horizontal bar plot# ‘hist’ : histogram# ‘box’ : boxplot# ‘kde’ : Kernel Density Estimation plot# ‘density’ : same as ‘kde’# ‘area’ : area plot# ‘pie’ : pie plot# ‘scatter’ : scatter plot# ‘hexbin’ : hexbin plot# rot : int, default None. Rotation for ticks (xticks for vertical, yticks for horizontal plots)tz_counts[:10].plot(kind='barh', rot=0) &lt;matplotlib.axes._subplots.AxesSubplot at 0x10d784eb8&gt; 12# 看看frame这个表格里‘a’列的第二行（index是1）是什么print(frame['a'][1]) GoogleMaps/RochesterNY 12# 在jupyter里边直接写变量名会自动print出来，是一种不标准的简化写法frame['a'][50] &apos;Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2&apos; 12# 在jupyter里边直接写变量名会自动print出来，是一种不标准的简化写法frame['a'][51] &apos;Mozilla/5.0 (Linux; U; Android 2.2.2; en-us; LG-P925/V10e Build/FRG83G) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&apos; 12345678# dropna()函数可以去掉包含有NaN值得item# frame.a.drapna()就是提取frame表格里列表为a的那一列，去除掉NA值得那些行的值# x.split(str) 通过指定分隔符str对字符串x进行切片，默认分隔符为空格，x.split(str)[0]意在取切完片的第一个值# [x.split()[0] for x in frame.a.dropna()]就是提取frame表格里列表为a的那一列，去除掉NA值得那些行的值，并用split进行分割，并且最后保存分割后的第一个值，构成一个list# Series是Pandas包中的方法，构建Series对象，添加索引results = Series([x.split()[0] for x in frame.a.dropna()])# 打印出来看看，后边的乱七八糟的信息已经没有了results[:5] 0 Mozilla/5.0 1 GoogleMaps/RochesterNY 2 Mozilla/4.0 3 Mozilla/5.0 4 Mozilla/5.0 dtype: object 12# Pandas对象又可以直接通过value_counts方法做统计了，取出前8个看看results.value_counts()[:8] Mozilla/5.0 2594 Mozilla/4.0 601 GoogleMaps/RochesterNY 121 Opera/9.80 34 TEST_INTERNET_AGENT 24 GoogleProducer 21 Mozilla/6.0 5 BlackBerry8520/5.0.0.681 4 dtype: int64 12345# frame.a.notnull()：frame表格的a列中，不是NaN就是true，是NaN就是False# frame[frame.a.notnull()]：取出frame这个表格中所有a列不为NaN的行cframe = frame[frame.a.notnull()]# 随便打几行看看，a列没有NaN（其他列暂时不管）cframe[:10] （表格太大了，略） 1234# cframe['a'].str 意思是将cframe表格中的‘a’列取出来，转化为padas 中string方法组成的列表，可以调用string相关的方法# .contains('Windows') string中包含Windows返回True，不包含返回False# 顺便输出前10行看看cframe['a'].str.contains('Windows')[:10] 0 True 1 False 2 True 3 False 4 True 5 True 6 True 7 True 8 False 9 True Name: a, dtype: bool 1234567891011# 要理解np.where()这个函数，先看下边几行# &gt;&gt;&gt; a# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])# &gt;&gt;&gt; np.where(a &lt; 5, 0, 1)# array([ 0, 0, 0, 0, 0, 1, 1, 1, 1, 1])# 也就是说，对于array a，满足&lt;5的项，用0代替，不满足&lt;5的项用1代替# np.where(cframe['a'].str.contains('Windows'), 'Windows', 'Not Windows')，返回True的用Windows替代，返回False的用Not Windows替代operating_system = np.where(cframe['a'].str.contains('Windows'), 'Windows', 'Not Windows')# 打印前五行，因通过numpy方法得到的结果，所以是一个numpy arrayoperating_system[:5] array([&apos;Windows&apos;, &apos;Not Windows&apos;, &apos;Windows&apos;, &apos;Not Windows&apos;, &apos;Windows&apos;], dtype=&apos;&lt;U11&apos;) 123456789101112# cframe.groupby([key1, key2, ...])为将cframe表格中的数据按照key进行分组# key可以是2种：1. cframe表格中的列名，2.长度和cframe表格相同的数组# cframe.groupby(['tz', operating_system])的意思就是：# 第一个分组维度为‘tz’列，改列值相同的为一组# 第二个分组维度为operating_system数组，也就是Windows的一组，Not Windows的一组# .size()为统计每个小组的数据量# .unstack()为把堆叠的分组表格展开（把这个函数去掉试一下就知道区别了）# .fillna(0)之前说了，把不存在值的格子填充上0agg_counts = cframe.groupby(['tz', operating_system]).size().unstack().fillna(0)# 打出前10行看看# 第一行不是总数，tz的值为空字符串‘’而已agg_counts[:10] .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; }Not WindowsWindowstz245.0276.0Africa/Cairo0.03.0Africa/Casablanca0.01.0Africa/Ceuta0.02.0Africa/Johannesburg0.01.0Africa/Lusaka0.01.0America/Anchorage4.01.0America/Argentina/Buenos_Aires1.00.0America/Argentina/Cordoba0.01.0America/Argentina/Mendoza0.01.0 1234# agg_counts.sum(1) 意思是按照第二维方向相加，也就是把Windows和Not Windows加到一起# 这里打印10行agg_counts_sum = agg_counts.sum(1)agg_counts_sum[:10] tz 521.0 Africa/Cairo 3.0 Africa/Casablanca 1.0 Africa/Ceuta 2.0 Africa/Johannesburg 1.0 Africa/Lusaka 1.0 America/Anchorage 5.0 America/Argentina/Buenos_Aires 1.0 America/Argentina/Cordoba 1.0 America/Argentina/Mendoza 1.0 dtype: float64 1234567# .argsort()：按照从小到大的顺序排列，返回排列后item在原数组中对应的indexindexer = agg_counts_sum.argsort()# 打出前10个，这个时候左边的tz和右边的数字已经没有对应关系了# 第一个24表示，按照从小到大排序，排在第一位的应该是原本数组中排在第25个（index为24）的那个item# 第二个20表示，按照从小到大排序，排在第二位的应该是原本数组中排在第21个（index为20）的那个item# 以此类推indexer[:10] tz 24 Africa/Cairo 20 Africa/Casablanca 21 Africa/Ceuta 92 Africa/Johannesburg 87 Africa/Lusaka 53 America/Anchorage 54 America/Argentina/Buenos_Aires 57 America/Argentina/Cordoba 26 America/Argentina/Mendoza 55 dtype: int64 12# 让原本的数字按照这个排好的indexer输出，我们就可以得到排序后的数据了agg_counts_sum[indexer] tz America/Mazatlan 1.0 America/La_Paz 1.0 America/Lima 1.0 Europe/Volgograd 1.0 Europe/Sofia 1.0 Asia/Manila 1.0 Asia/Nicosia 1.0 Asia/Riyadh 1.0 America/Monterrey 1.0 Asia/Novosibirsk 1.0 Australia/Queensland 1.0 America/Santo_Domingo 1.0 Asia/Yekaterinburg 1.0 America/St_Kitts 1.0 America/Tegucigalpa 1.0 America/Montevideo 1.0 Europe/Ljubljana 1.0 Asia/Pontianak 1.0 Europe/Uzhgorod 1.0 Africa/Casablanca 1.0 Africa/Johannesburg 1.0 Africa/Lusaka 1.0 America/Argentina/Buenos_Aires 1.0 America/Argentina/Cordoba 1.0 America/Argentina/Mendoza 1.0 Europe/Skopje 1.0 America/Caracas 1.0 America/Costa_Rica 1.0 Asia/Kuching 1.0 Europe/Riga 2.0 ... America/Montreal 9.0 Asia/Calcutta 9.0 America/Puerto_Rico 10.0 Asia/Hong_Kong 10.0 Europe/Helsinki 10.0 Europe/Prague 10.0 Europe/Oslo 10.0 Europe/Moscow 10.0 Pacific/Auckland 11.0 America/Vancouver 12.0 Europe/Stockholm 14.0 Europe/Paris 14.0 America/Mexico_City 15.0 Europe/Warsaw 16.0 America/Phoenix 20.0 America/Indianapolis 20.0 Europe/Amsterdam 22.0 America/Rainy_River 25.0 Europe/Rome 27.0 Europe/Berlin 28.0 America/Sao_Paulo 33.0 Europe/Madrid 35.0 Pacific/Honolulu 36.0 Asia/Tokyo 37.0 Europe/London 74.0 America/Denver 191.0 America/Los_Angeles 382.0 America/Chicago 400.0 521.0 America/New_York 1251.0 Length: 97, dtype: float64 123456# agg_counts.take([index1, index2, ...], axis=0)：在axis维度（0为行，1为列）上，按照index顺序取出数据# 这里没有输入axis的值，默认为0，按行取# 顺序为按照indexer# [-10:]：把最后10个取出来count_subset = agg_counts.take(indexer)[-10:]count_subset .dataframe thead tr:only-child th { text-align: right; } .dataframe thead th { text-align: left; } .dataframe tbody tr th { vertical-align: top; }Not WindowsWindowstzAmerica/Sao_Paulo13.020.0Europe/Madrid16.019.0Pacific/Honolulu0.036.0Asia/Tokyo2.035.0Europe/London43.031.0America/Denver132.059.0America/Los_Angeles130.0252.0America/Chicago115.0285.0245.0276.0America/New_York339.0912.0 12# 设置一块自定义大小的画布，生成画布对象（这里没写残书就是默认）plt.figure() &lt;matplotlib.figure.Figure at 0x112f87e10&gt; &lt;matplotlib.figure.Figure at 0x112f87e10&gt; 123# 把count_subset这个表格中的数据绘制成图，类型为柱状图bar，横向h（horizontal）# stacked=True表示多个维度的数据堆叠显示（不明白的话改成False看看就知道了）count_subset.plot(kind='barh', stacked=True) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1134d2630&gt; 12# 设置一块自定义大小的画布，生成画布对象（这里没写残书就是默认）plt.figure() &lt;matplotlib.figure.Figure at 0x1136fd2e8&gt; &lt;matplotlib.figure.Figure at 0x1136fd2e8&gt; 123456# count_subset.sum(1)：把count_subset按照第一维的方向相加# count_subset.div(count_subset.sum(1),axis=0)：按行除以相加的结果# 相当于把每一行所有数值变成了在当前行占的百分比normed_subset = count_subset.div(count_subset.sum(1), axis=0)# stacked=True表示多个维度的数据堆叠显示（不明白的话改成False看看就知道了）normed_subset.plot(kind='barh', stacked=True) &lt;matplotlib.axes._subplots.AxesSubplot at 0x1138b6fd0&gt;]]></content>
      <tags>
        <tag>python</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过python进行数据分析(一)]]></title>
    <url>%2F2019%2F04%2F14%2F%E9%80%9A%E8%BF%87python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Introductory examples1.usa.gov data from bit.ly12# 显示当前路径%pwd &apos;/Users/imonce/OneDrive/learning/dataAnalyze/pydata-book-master&apos; 12# 回到上一层（..）又回到当前文件夹（pydata-book-master）%cd ../pydata-book-master /Users/imonce/OneDrive/learning/dataAnalyze/pydata-book-master 12# 创建变量并赋值，这里path是数据所在路径path = 'ch02/usagov_bitly_data2012-03-16-1331923249.txt' 123# open：打开path路径代表的文件# open().readline()：读取文件的第一行，并把指针下移一行（再执行一次读取的就是文件的第二行了，以此类推）open(path).readline() &apos;{ &quot;a&quot;: &quot;Mozilla\\/5.0 (Windows NT 6.1; WOW64) AppleWebKit\\/535.11 (KHTML, like Gecko) Chrome\\/17.0.963.78 Safari\\/535.11&quot;, &quot;c&quot;: &quot;US&quot;, &quot;nk&quot;: 1, &quot;tz&quot;: &quot;America\\/New_York&quot;, &quot;gr&quot;: &quot;MA&quot;, &quot;g&quot;: &quot;A6qOVH&quot;, &quot;h&quot;: &quot;wfLQtf&quot;, &quot;l&quot;: &quot;orofrog&quot;, &quot;al&quot;: &quot;en-US,en;q=0.8&quot;, &quot;hh&quot;: &quot;1.usa.gov&quot;, &quot;r&quot;: &quot;http:\\/\\/www.facebook.com\\/l\\/7AQEFzjSi\\/1.usa.gov\\/wfLQtf&quot;, &quot;u&quot;: &quot;http:\\/\\/www.ncbi.nlm.nih.gov\\/pubmed\\/22415991&quot;, &quot;t&quot;: 1331923247, &quot;hc&quot;: 1331822918, &quot;cy&quot;: &quot;Danvers&quot;, &quot;ll&quot;: [ 42.576698, -70.954903 ] }\n&apos; 12345678# 导入json包import json# 创建变量并赋值，这里path是数据所在路径path = 'ch02/usagov_bitly_data2012-03-16-1331923249.txt'# json.loads()：以json格式读取数据，读取出来是key：value对，可以像字典一样查询# for line in open(path)：逐行遍历path文件中的数据# [json.loads(line) for line in open(path)]：逐行遍历path文件中的数据，通过按照json格式读取，然后每一行的作为一个item组成list（就是外边那个方括号的作用）records = [json.loads(line) for line in open(path)] 1234# 取出第一个item（第一行读取的内容）看一下# 这个语句本身没有打印作用，但是在jupyter里边直接放变量会给你打印出来# 标准写法应该为print(records[0])records[0] {&apos;a&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.78 Safari/535.11&apos;, &apos;al&apos;: &apos;en-US,en;q=0.8&apos;, &apos;c&apos;: &apos;US&apos;, &apos;cy&apos;: &apos;Danvers&apos;, &apos;g&apos;: &apos;A6qOVH&apos;, &apos;gr&apos;: &apos;MA&apos;, &apos;h&apos;: &apos;wfLQtf&apos;, &apos;hc&apos;: 1331822918, &apos;hh&apos;: &apos;1.usa.gov&apos;, &apos;l&apos;: &apos;orofrog&apos;, &apos;ll&apos;: [42.576698, -70.954903], &apos;nk&apos;: 1, &apos;r&apos;: &apos;http://www.facebook.com/l/7AQEFzjSi/1.usa.gov/wfLQtf&apos;, &apos;t&apos;: 1331923247, &apos;tz&apos;: &apos;America/New_York&apos;, &apos;u&apos;: &apos;http://www.ncbi.nlm.nih.gov/pubmed/22415991&apos;} 12# 查询第一个item中，key为'a'的valuerecords[0]['a'] &apos;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.78 Safari/535.11&apos; Counting time zones in pure Python12# 如果查询不存在的key的话会报错records[0]['cc'] --------------------------------------------------------------------------- KeyError Traceback (most recent call last) &lt;ipython-input-8-992e1ec28c8d&gt; in &lt;module&gt;() 1 # 如果查询不存在的key的话会报错 ----&gt; 2 records[0][&apos;cc&apos;] KeyError: &apos;cc&apos; 1234# for rec in records：吧records这个list里边的item逐个取出，每次取出都用rec命名# [rec['tz'] for rec in records]：把rec中key为‘tz’的value取出来，作为item构建list# 直接运行会报错，因为有的行里边是没有‘tz’这个key的time_zones = [rec['tz'] for rec in records] --------------------------------------------------------------------------- KeyError Traceback (most recent call last) &lt;ipython-input-9-abb6a4fa53e3&gt; in &lt;module&gt;() 2 # [rec[&apos;tz&apos;] for rec in records]：把rec中key为‘tz’的value取出来，作为item构建list 3 # 直接运行会报错，因为有的行里边是没有‘tz’这个key的 ----&gt; 4 time_zones = [rec[&apos;tz&apos;] for rec in records] &lt;ipython-input-9-abb6a4fa53e3&gt; in &lt;listcomp&gt;(.0) 2 # [rec[&apos;tz&apos;] for rec in records]：把rec中key为‘tz’的value取出来，作为item构建list 3 # 直接运行会报错，因为有的行里边是没有‘tz’这个key的 ----&gt; 4 time_zones = [rec[&apos;tz&apos;] for rec in records] KeyError: &apos;tz&apos; 123# 因此这一句在上一句的基础上，增加if 'tz' in rec，意为只把tz的rec中的value构成list# 因此time_zones的长度小于recordstime_zones = [rec['tz'] for rec in records if 'tz' in rec] 123# 输出两个list的长度看一下# records中有120个item是没有‘tz’这个key的print(len(records),len(time_zones)) 3560 3440 1234567891011121314151617# 这个函数的参数sequence应该是一个list# 这个函数的输出是一个dict，其中key是sequence中的item，value是item出现的次数def get_counts(sequence): # 创建空字典counts counts = &#123;&#125; # 遍历sequence中的item，命名为x for x in sequence: # 如果x在counts中作为key出现过 if x in counts: # 将当前x对应的value的值+1 counts[x] += 1 # counts的key中没有x else: # 创建x这个key，并将其对应的value设置为1 counts[x] = 1 # 返回counts这个字典 return counts 12345678910111213141516# 从collections这个包里导入defaultdict这个函数from collections import defaultdict# 这个函数的参数sequence应该是一个list# 这个函数的输出是一个dict，其中key是sequence中的item，value是item出现的次数def get_counts2(sequence): # 创建空字典，字典中的value默认为int类型的变量 # 意义在于，每次插入一个新的key时，对应的value会自动设置为0，不需要先赋值一次 counts = defaultdict(int) # values will initialize to 0 # 遍历sequence中的item，命名为x for x in sequence: # counts的key中有x就直接+1 # 没有就插入x这个key，（自动初始化value为0），然后+1 counts[x] += 1 # 返回counts这个字典 return counts 12# 调用刚刚定义的函数，统计一下time_zones这个list中每个时区出现的次数counts = get_counts(time_zones) 123# counts是一个dict，因此可以直接通过key查询value的值# 看看'America/New_York'这个key对应的value时多少counts['America/New_York'] 1251 123# counts.items()：把counts这个字典中的key和value成对取出# [(count, tz) for tz, count in counts.items()]：把键值对以二元组的形式构成list[(count, tz) for tz, count in counts.items()] [(1251, &apos;America/New_York&apos;), (191, &apos;America/Denver&apos;), (33, &apos;America/Sao_Paulo&apos;), (16, &apos;Europe/Warsaw&apos;), (521, &apos;&apos;), (382, &apos;America/Los_Angeles&apos;), (10, &apos;Asia/Hong_Kong&apos;), (27, &apos;Europe/Rome&apos;), (2, &apos;Africa/Ceuta&apos;), (35, &apos;Europe/Madrid&apos;), (3, &apos;Asia/Kuala_Lumpur&apos;), (1, &apos;Asia/Nicosia&apos;), (74, &apos;Europe/London&apos;), (36, &apos;Pacific/Honolulu&apos;), (400, &apos;America/Chicago&apos;), (2, &apos;Europe/Malta&apos;), (8, &apos;Europe/Lisbon&apos;), (14, &apos;Europe/Paris&apos;), (5, &apos;Europe/Copenhagen&apos;), (1, &apos;America/Mazatlan&apos;), (3, &apos;Europe/Dublin&apos;), (4, &apos;Europe/Brussels&apos;), (12, &apos;America/Vancouver&apos;), (22, &apos;Europe/Amsterdam&apos;), (10, &apos;Europe/Prague&apos;), (14, &apos;Europe/Stockholm&apos;), (5, &apos;America/Anchorage&apos;), (6, &apos;Asia/Bangkok&apos;), (28, &apos;Europe/Berlin&apos;), (25, &apos;America/Rainy_River&apos;), (5, &apos;Europe/Budapest&apos;), (37, &apos;Asia/Tokyo&apos;), (6, &apos;Europe/Vienna&apos;), (20, &apos;America/Phoenix&apos;), (3, &apos;Asia/Jerusalem&apos;), (3, &apos;Asia/Karachi&apos;), (3, &apos;America/Bogota&apos;), (20, &apos;America/Indianapolis&apos;), (9, &apos;America/Montreal&apos;), (9, &apos;Asia/Calcutta&apos;), (1, &apos;Europe/Skopje&apos;), (4, &apos;Asia/Beirut&apos;), (6, &apos;Australia/NSW&apos;), (6, &apos;Chile/Continental&apos;), (4, &apos;America/Halifax&apos;), (6, &apos;America/Edmonton&apos;), (3, &apos;Europe/Bratislava&apos;), (2, &apos;America/Recife&apos;), (3, &apos;Africa/Cairo&apos;), (9, &apos;Asia/Istanbul&apos;), (1, &apos;Asia/Novosibirsk&apos;), (10, &apos;Europe/Moscow&apos;), (1, &apos;Europe/Sofia&apos;), (1, &apos;Europe/Ljubljana&apos;), (15, &apos;America/Mexico_City&apos;), (10, &apos;Europe/Helsinki&apos;), (4, &apos;Europe/Bucharest&apos;), (4, &apos;Europe/Zurich&apos;), (10, &apos;America/Puerto_Rico&apos;), (1, &apos;America/Monterrey&apos;), (6, &apos;Europe/Athens&apos;), (4, &apos;America/Winnipeg&apos;), (2, &apos;Europe/Riga&apos;), (1, &apos;America/Argentina/Buenos_Aires&apos;), (4, &apos;Asia/Dubai&apos;), (10, &apos;Europe/Oslo&apos;), (1, &apos;Asia/Yekaterinburg&apos;), (1, &apos;Asia/Manila&apos;), (1, &apos;America/Caracas&apos;), (1, &apos;Asia/Riyadh&apos;), (1, &apos;America/Montevideo&apos;), (1, &apos;America/Argentina/Mendoza&apos;), (5, &apos;Asia/Seoul&apos;), (1, &apos;Europe/Uzhgorod&apos;), (1, &apos;Australia/Queensland&apos;), (2, &apos;Europe/Belgrade&apos;), (1, &apos;America/Costa_Rica&apos;), (1, &apos;America/Lima&apos;), (1, &apos;Asia/Pontianak&apos;), (2, &apos;America/Chihuahua&apos;), (2, &apos;Europe/Vilnius&apos;), (3, &apos;America/Managua&apos;), (1, &apos;Africa/Lusaka&apos;), (2, &apos;America/Guayaquil&apos;), (3, &apos;Asia/Harbin&apos;), (2, &apos;Asia/Amman&apos;), (1, &apos;Africa/Johannesburg&apos;), (1, &apos;America/St_Kitts&apos;), (11, &apos;Pacific/Auckland&apos;), (1, &apos;America/Santo_Domingo&apos;), (1, &apos;America/Argentina/Cordoba&apos;), (1, &apos;Asia/Kuching&apos;), (1, &apos;Europe/Volgograd&apos;), (1, &apos;America/La_Paz&apos;), (1, &apos;Africa/Casablanca&apos;), (3, &apos;Asia/Jakarta&apos;), (1, &apos;America/Tegucigalpa&apos;)] 123456789# count_dict是待统计的字典，n是要取出n项，默认为10def top_counts(count_dict, n=10): # counts.items()：把counts这个字典中的key和value成对取出 # [(count, tz) for tz, count in counts.items()]：把键值对以二元组的形式构成list value_key_pairs = [(count, tz) for tz, count in count_dict.items()] # 调用python中的list自带的sort()方法，默认按照第一维从小到达排序 value_key_pairs.sort() # [-n:]意思为从倒数第n项一直取到最后一项，也就是说返回的是最大的n个 return value_key_pairs[-n:] 12# 看看counts中出现最多的时区top_counts(counts) [(33, &apos;America/Sao_Paulo&apos;), (35, &apos;Europe/Madrid&apos;), (36, &apos;Pacific/Honolulu&apos;), (37, &apos;Asia/Tokyo&apos;), (74, &apos;Europe/London&apos;), (191, &apos;America/Denver&apos;), (382, &apos;America/Los_Angeles&apos;), (400, &apos;America/Chicago&apos;), (521, &apos;&apos;), (1251, &apos;America/New_York&apos;)] 123# 其实有现成的包可以用# 导入collections包中的Counter函数from collections import Counter 12# 通过Counter对time_zones这个list进行统计counts = Counter(time_zones) 12# 调用Counter对象的方法most_common(n)可以直接调出最多的n项counts.most_common(10) [(&apos;America/New_York&apos;, 1251), (&apos;&apos;, 521), (&apos;America/Chicago&apos;, 400), (&apos;America/Los_Angeles&apos;, 382), (&apos;America/Denver&apos;, 191), (&apos;Europe/London&apos;, 74), (&apos;Asia/Tokyo&apos;, 37), (&apos;Pacific/Honolulu&apos;, 36), (&apos;Europe/Madrid&apos;, 35), (&apos;America/Sao_Paulo&apos;, 33)]]]></content>
      <tags>
        <tag>python</tag>
        <tag>学习笔记</tag>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[latex数学符号表]]></title>
    <url>%2F2019%2F04%2F02%2Flatex%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[reference:一份不太简短的 LATEX 2ε 介绍]]></content>
      <tags>
        <tag>latex</tag>
        <tag>数学符号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MECE分析法学习(Mutually Exclusive Collectively Exhaustive)]]></title>
    <url>%2F2019%2F04%2F02%2FMECE%E5%88%86%E6%9E%90%E6%B3%95%E5%AD%A6%E4%B9%A0-Mutually-Exclusive-Collectively-Exhaustive%2F</url>
    <content type="text"><![CDATA[本文摘自：MECE分析法 MECE分析法MECE，是Mutually Exclusive Collectively Exhaustive，中文意思是“相互独立，完全穷尽”。 也就是对于一个重大的议题，能够做到不重叠、不遗漏的分类，而且能够藉此有效把握问题的核心，并解决问题的方法。 所谓的不遗漏、不重叠指在将某个整体（不论是客观存在的还是概念性的整体）划分为不同的部分时，必须保证划分后的各部门符合以下要求： 各部分之间相互独立 （Mutually Exclusive） 所有部分完全穷尽 （Collectively Exhaustive） 通常的做法分两种： 一是在确立问题的时候，通过类似鱼刺图的方法，在确立主要问题的基础上，再逐个往下层层分解，直至所有的疑问都找到，通过问题的层层分解，可以分析出关键问题和初步的解决问题的思路； 另一种方法是结合头脑风暴法找到主要问题，然后在不考虑现有资源的限制基础上，考虑解决该问题的所有可能方法，在这个过程中，要特别注意多种方法的结合有可能是个新的解决方法，然后再往下分析，每种解决方法所需要的各种资源，并通过分析比较，从上述多种方案中找到目前状况下最现实最令人满意的答案。 分析步骤对于分析问题的标准程序: 收集信息=&gt;描述发现=&gt;得出结论=&gt;提出方案 MECE分析法主要有两个步骤 步骤一、确认问题是什么？步骤二、寻找MECE的切入点。 栗子]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>MECE</tag>
        <tag>分类方法</tag>
        <tag>分析法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WS-BPEL 2.0 xml schema 详解(1+2+3全，方便检索)]]></title>
    <url>%2F2019%2F03%2F22%2FWS-BPEL-2-0-xml-schema-%E8%AF%A6%E8%A7%A3-%E5%85%A8%2F</url>
    <content type="text"><![CDATA[这篇文章将一行一行的解读wsbpel2.0的源码。 相关xsd语法问题，请参见XSD学习笔记完整版 wsbpel2.0源码：ws-bpel_executable.xsd schema声明1234&lt;xsd:schema xmlns=&quot;http://docs.oasis-open.org/wsbpel/2.0/process/executable&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://docs.oasis-open.org/wsbpel/2.0/process/executable&quot; elementFormDefault=&quot;qualified&quot; blockDefault=&quot;#all&quot;&gt; ...&lt;\xsd&gt; 声明命名空间http://docs.oasis-open.org/wsbpel/2.0/process/executable，没有前缀。 引入http://www.w3.org/2001/XMLSchema的语素并以xsd为前缀。 elementFormDefault=&quot;qualified&quot;表示所有元素都必须加上前缀以表明其命名空间。 blockDefault=&quot;#all&quot;表示默认情况下不能通过派生类代替原类型。 annotation12345&lt;xsd:annotation&gt; &lt;xsd:documentation&gt;Schema for Executable Process for WS-BPEL 2.0 OASIS Standard 11th April, 2007 &lt;/xsd:documentation&gt;&lt;/xsd:annotation&gt; 赠送了一个简单的文档说明。 import1&lt;xsd:import namespace=&quot;http://www.w3.org/XML/1998/namespace&quot; schemaLocation=&quot;http://www.w3.org/2001/xml.xsd&quot;/&gt; 引入http://www.w3.org/2001/xml.xsd的xml语素，前缀默认为xml。 element：process1234567&lt;xsd:element name=&quot;process&quot; type=&quot;tProcess&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This is the root element for a WS-BPEL 2.0 process. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt; BPEL的根元素，此处没有定义任何内容，内部元素属性通过type=”tProcess”引入。 complexType：tProcess1234567891011121314151617181920212223&lt;xsd:complexType name=&quot;tProcess&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;extensions&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;import&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;partnerLinks&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;messageExchanges&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;variables&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;correlationSets&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;faultHandlers&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;eventHandlers&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;targetNamespace&quot; type=&quot;xsd:anyURI&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;queryLanguage&quot; type=&quot;xsd:anyURI&quot; default=&quot;urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0&quot;/&gt; &lt;xsd:attribute name=&quot;expressionLanguage&quot; type=&quot;xsd:anyURI&quot; default=&quot;urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0&quot;/&gt; &lt;xsd:attribute name=&quot;suppressJoinFailure&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;xsd:attribute name=&quot;exitOnStandardFault&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 首先是一个名为tExtensibleElements的扩展，先放一下往后看。 一个sequence，包括extensions，import，partnerLinks，messageExchanges，variables，correlationSets，faultHandlers，eventHandlers，还有一个activity的group，这里全部是ref，我们知道大概有些啥就行了，后边肯定会有详细的定义，先往后看吧。 接着是一堆attribute，包括process的 名称name 目标命名空间targetNamespace 查询语言queryLanguage，默认是urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0 表达语言expressionLanguage，默认是：urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0 抑制链接失败suppressJoinFailure，默认是否 标准错误退出exitOnStandardFault，默认是否 complexType：tExtensibleElement123456789101112&lt;xsd:complexType name=&quot;tExtensibleElements&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This type is extended by other component types to allow elements and attributes from other namespaces to be added at the modeled places. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;documentation&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; tExtensibleElements这个扩展马上就来了，可以看到，扩展除了0至多个documentation（后边再讲），还有 element：来自该元素的父元素的目标命名空间之外的任何命名空间的元素，且即使不能获取该命名空间架构，也不会发生任何错误。 attribute：同上 element：documentation123456789&lt;xsd:element name=&quot;documentation&quot; type=&quot;tDocumentation&quot;/&gt;&lt;xsd:complexType name=&quot;tDocumentation&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;source&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:attribute ref=&quot;xml:lang&quot;/&gt;&lt;/xsd:complexType&gt; documentation中： element：一个字符元素可混合出现的，元素可随意引入，不在此命名空间也没关系 attribute： source：通过URI表明来源 xml:lang: 文档语言，如en、CN等 group：activity123456789101112131415161718192021222324252627282930&lt;xsd:group name=&quot;activity&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;All standard WS-BPEL 2.0 activities in alphabetical order. Basic activities and structured activities. Addtional constraints: - rethrow activity can be used ONLY within a fault handler (i.e. &quot;catch&quot; and &quot;catchAll&quot; element) - compensate or compensateScope activity can be used ONLY within a fault handler, a compensation handler or a termination handler &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:choice&gt; &lt;xsd:element ref=&quot;assign&quot;/&gt; &lt;xsd:element ref=&quot;compensate&quot;/&gt; &lt;xsd:element ref=&quot;compensateScope&quot;/&gt; &lt;xsd:element ref=&quot;empty&quot;/&gt; &lt;xsd:element ref=&quot;exit&quot;/&gt; &lt;xsd:element ref=&quot;extensionActivity&quot;/&gt; &lt;xsd:element ref=&quot;flow&quot;/&gt; &lt;xsd:element ref=&quot;forEach&quot;/&gt; &lt;xsd:element ref=&quot;if&quot;/&gt; &lt;xsd:element ref=&quot;invoke&quot;/&gt; &lt;xsd:element ref=&quot;pick&quot;/&gt; &lt;xsd:element ref=&quot;receive&quot;/&gt; &lt;xsd:element ref=&quot;repeatUntil&quot;/&gt; &lt;xsd:element ref=&quot;reply&quot;/&gt; &lt;xsd:element ref=&quot;rethrow&quot;/&gt; &lt;xsd:element ref=&quot;scope&quot;/&gt; &lt;xsd:element ref=&quot;sequence&quot;/&gt; &lt;xsd:element ref=&quot;throw&quot;/&gt; &lt;xsd:element ref=&quot;validate&quot;/&gt; &lt;xsd:element ref=&quot;wait&quot;/&gt; &lt;xsd:element ref=&quot;while&quot;/&gt; &lt;/xsd:choice&gt;&lt;/xsd:group&gt; 定义了一个activity的group，用于在其他地方引用，比如说通过tProcess引用到process里边。 一个activity可以是以下元素中的一个，没写到的看后边源码解读好了： 活动名称 释义 assign 活动的作用是用新的数据来更新变量的值。Assign活动可以包括任意数量的基本复制操作。 compensate 通过该活动做一些补偿动作，通常需要和scope联合使用。只能从故障处理程序或另一个补偿处理活动中调用这个活动。补偿处理程序只能被调用一次。 compensateScope empty 无所事事，比如在一个错误发生后可以不做反应来消除这个错误 exit 该活动用于立刻终止业务流程实例。所有当前运行的活动必须被立刻终止。不用引用任何终点处理、错误处理或者补偿行为。 extensionActivity flow 可以描述更为复杂的活动执行顺序。我们可以利用flow指定一个或多个并行执行的活动。为了定义任意的控制结构，可以在并行的活动中使用链接。 forEach if invoke 活动允许业务流程同步或异步调用由合作伙伴提供的服务，服务实现可以是单向或请求-响应操作。Invoke活动使用“partnerLink”来引用伙伴服务。同过“portType”和“operation”指定相应的WSDL接口和操作。 pick 活动会等待一组相互排斥事件中的一个事件的发生，然后执行与发生的事件相关联的活动。它会阻塞业务流程执行，以等待某一特定的事件发生，比如接收到一个合适的消息或超时警报响起。当其中任何一个事件被触发后，业务流程就会继续执行，pick也随即完成了，不会再等待其他事件的发生。 receive 活动从流程的外部伙伴那获取数据，并将其保存到流程变量。通常一个Receive是一个流程的初始点，它会阻塞执行直到匹配的消息的到达。 repeatUntil reply 活动发送消息给伙伴来应答通过receive活动所接收到的消息。receive和reply的组合对应着WSDL portType上定义的一个请求-响应操作。如果receive活动对应着一个单向(one-way)操作，则不能在流程中定义对应的reply活动。 rethrow scope 使用这个结构可以将一组活动组织在一起作为一个处理单位。通过这个组织方法多个活动可以使用同一个故障处理、事故处理和补偿处理。通过补偿处理BPEL可以处理长时间的处理。 sequence 定义一组按顺序先后执行的活动。执行顺序是sequence活动中嵌套活动的先后顺序。当sequence中的最后一个活动完成后，该sequence活动也就完成了。 throw 提示一个错误，一个故障处理可以处理这样的错误。假如一个错误不被处理的话它最终到达最高层后导致过程的终止 validate wait 活动会暂停流程执行，等待一段给定的时间或等到某一时刻才继续运行。在WebSphere Process Server 6.0中，开发者可以非常灵活地指定wait中的到期条件，比如等待多少秒，等到特定的一个日期，或是使用内置的日期表现法。也可以使用Java代码来动态指定等待时间。 while 继承于传统的结构化编程思想，提供了while-do循环结构的支持。它可以包含一个或多个活动。它指定反复执行其内部活动，直到成功条件不被满足为止。在WPS中允许其使用Java代码来描述条件表达式。 element：extensions12345678910111213141516171819202122&lt;xsd:element name=&quot;extensions&quot; type=&quot;tExtensions&quot;/&gt;&lt;xsd:complexType name=&quot;tExtensions&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;extension&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;extension&quot; type=&quot;tExtension&quot;/&gt;&lt;xsd:complexType name=&quot;tExtension&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;namespace&quot; type=&quot;xsd:anyURI&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;mustUnderstand&quot; type=&quot;tBoolean&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 一个extensions由1到多个extension组成。 extension扩展自tExtensibleElements，增加了namespace和mustUnderstand两个属性。 element：import1234567891011&lt;xsd:element name=&quot;import&quot; type=&quot;tImport&quot;/&gt;&lt;xsd:complexType name=&quot;tImport&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;namespace&quot; type=&quot;xsd:anyURI&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;location&quot; type=&quot;xsd:anyURI&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;importType&quot; type=&quot;xsd:anyURI&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; BPEL允许import，import元素在tExtensibleElements的基础上，增加namespace、location、importType三个属性，和xsd的import类似。 element：partnerLinks12345678910111213141516171819202122232425&lt;xsd:element name=&quot;partnerLinks&quot; type=&quot;tPartnerLinks&quot;/&gt;&lt;xsd:complexType name=&quot;tPartnerLinks&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;partnerLink&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;partnerLink&quot; type=&quot;tPartnerLink&quot;/&gt;&lt;xsd:complexType name=&quot;tPartnerLink&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;partnerLinkType&quot; type=&quot;xsd:QName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;myRole&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;partnerRole&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;initializePartnerRole&quot; type=&quot;tBoolean&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 和extensions相似，partnerLinks由1到多个partnerLink组成，同时支持tExtensibleElements扩展。 partnerLink在tExtensibleElements的基础上，增加了以下5个属性 name partnerLinkType myRole partnerRole initializaPartnerRole element：messageExchanges123456789101112131415161718192021&lt;xsd:element name=&quot;messageExchanges&quot; type=&quot;tMessageExchanges&quot;/&gt;&lt;xsd:complexType name=&quot;tMessageExchanges&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;messageExchange&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;messageExchange&quot; type=&quot;tMessageExchange&quot;/&gt;&lt;xsd:complexType name=&quot;tMessageExchange&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 和extensions相似，messageExchanges由1到多个messageExchange组成，同时支持tExtensibleElements扩展。 messageExchange在tExtensibleElements的基础上，增加了一个属性 name element：variables123456789101112131415161718192021222324252627&lt;xsd:element name=&quot;variables&quot; type=&quot;tVariables&quot;/&gt;&lt;xsd:complexType name=&quot;tVariables&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;variable&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;variable&quot; type=&quot;tVariable&quot;/&gt;&lt;xsd:complexType name=&quot;tVariable&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;from&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;BPELVariableName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;messageType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;element&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 和extensions相似，variables由1到多个variable组成，同时支持tExtensibleElements扩展。 variable在tExtensibleElements的基础上，增加了一个元素 from 增加了四个属性 name messageType type element simpleType：BPELVariableName12345&lt;xsd:simpleType name=&quot;BPELVariableName&quot;&gt; &lt;xsd:restriction base=&quot;xsd:NCName&quot;&gt; &lt;xsd:pattern value=&quot;[^\.]+&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; bpel变量的一个限制，BPELVariableName需要满足xsd:NCName限制，不能以.开头，且长度大于等于一个字符。 element：correlationSets12345678910111213141516171819202122&lt;xsd:element name=&quot;correlationSets&quot; type=&quot;tCorrelationSets&quot;/&gt;&lt;xsd:complexType name=&quot;tCorrelationSets&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;correlationSet&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;correlationSet&quot; type=&quot;tCorrelationSet&quot;/&gt;&lt;xsd:complexType name=&quot;tCorrelationSet&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;properties&quot; type=&quot;QNames&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 和extensions相似，correlationSets由1到多个correlationSet组成，同时支持tExtensibleElements扩展。 correlationSet在tExtensibleElements的基础上，增加了2个属性 properties name simpleType：QNames12345678&lt;xsd:simpleType name=&quot;QNames&quot;&gt; &lt;xsd:restriction&gt; &lt;xsd:simpleType&gt; &lt;xsd:list itemType=&quot;xsd:QName&quot;/&gt; &lt;/xsd:simpleType&gt; &lt;xsd:minLength value=&quot;1&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; QNames就是一个QName的list，最少1个，默认空格分割。 element：faultHandlers123456789101112&lt;xsd:element name=&quot;faultHandlers&quot; type=&quot;tFaultHandlers&quot;/&gt;&lt;xsd:complexType name=&quot;tFaultHandlers&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;catch&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;catchAll&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; faultHandlers，听名字就知道是干啥的了，同样支持tExtensibleElements扩展，由2种元素的sequence组成： catch catchAll element：catch123456789101112131415161718&lt;xsd:element name=&quot;catch&quot; type=&quot;tCatch&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This element can contain all activities including the activities compensate, compensateScope and rethrow. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt;&lt;xsd:complexType name=&quot;tCatch&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivityContainer&quot;&gt; &lt;xsd:attribute name=&quot;faultName&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;faultVariable&quot; type=&quot;BPELVariableName&quot;/&gt; &lt;xsd:attribute name=&quot;faultMessageType&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;faultElement&quot; type=&quot;xsd:QName&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; catch扩展自tActivityContainer，包含4个属性，对catch做了限定： faultName faultVariable faultMessageType faultElement element：catchAll1234567891011121314151617&lt;xsd:element name=&quot;catchAll&quot; type=&quot;tActivityContainer&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This element can contain all activities including the activities compensate, compensateScope and rethrow. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt;&lt;xsd:complexType name=&quot;tActivityContainer&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 不同于catch，catchAll没有那么多属性（我全都要），就是tActivityContainer本尊，扩展自tExtensibleElements，同时包含一个activity的sequence。 element：eventHandlers1234567891011121314151617&lt;xsd:element name=&quot;eventHandlers&quot; type=&quot;tEventHandlers&quot;/&gt;&lt;xsd:complexType name=&quot;tEventHandlers&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element onAlarm needs to be a Local Element Declaration, because there is another onAlarm element defined for the pick activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;onEvent&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element name=&quot;onAlarm&quot; type=&quot;tOnAlarmEvent&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; eventHandlers基于tExtensibleElements扩展，由2种元素的sequence组成： onEvent：见element：onEvent onAlarm：见complexType：tOnAlarmEvent element：onEvent12345678910111213&lt;xsd:element name=&quot;onEvent&quot; type=&quot;tOnEvent&quot;/&gt;&lt;xsd:complexType name=&quot;tOnEvent&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tOnMsgCommon&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;scope&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;messageType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;element&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; onEvent元素基于tOnMsgCommon进行扩展，包含一个element sequence： scope：用于表明作用范围 2个attribute： messageType element complexType：tOnMsgCommon1234567891011121314151617181920&lt;xsd:complexType name=&quot;tOnMsgCommon&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlations needs to be a Local Element Declaration, because there is another correlations element defined for the invoke activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlations&quot; type=&quot;tCorrelations&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;fromParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;portType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;operation&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;messageExchange&quot; type=&quot;xsd:NCName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; tOnMsgCommon这个complexType同样支持tExtensibleElements扩展，包含由两类element组成的sequence： correlations：type为tCorrelations fromParts 同时还引入了5种属性： partnerLink：必填的链接名 portType：选填的端口类型 operation：必填的操作 messageExchange：选填的操作信息 variable：选填的变量 complexType：tCorrelations12345678910111213141516171819202122232425262728293031&lt;xsd:complexType name=&quot;tCorrelations&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlation needs to be a Local Element Declaration, because there is another correlation element defined for the invoke activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlation&quot; type=&quot;tCorrelation&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:complexType name=&quot;tCorrelation&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;set&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;initiate&quot; type=&quot;tInitiate&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:simpleType name=&quot;tInitiate&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;yes&quot;/&gt; &lt;xsd:enumeration value=&quot;join&quot;/&gt; &lt;xsd:enumeration value=&quot;no&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; tCorrelations基于tExtensibleElements扩展，由1至多个correlation的sequence组成。 tCorrelation同样基于tExtensibleElements扩展，在此之上还定义了两个属性： set initiate：yes | join | no complexType：tOnAlarmEvent12345678910111213141516&lt;xsd:complexType name=&quot;tOnAlarmEvent&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:choice&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;forOrUntilGroup&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;repeatEvery&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:element ref=&quot;repeatEvery&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt; &lt;xsd:element ref=&quot;scope&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; tOnAlarmEvent基于tExtensibleElements扩展，由1个group：forOrUntilGroup 和 0或1个element：repeatEvery组成的sequence，或者1个element：repeatEvery，再加上一个scope组成的sequence组成。 三个元素都通过ref引用，可以继续往后看定义。 group：forOrUntilGroup123456789101112&lt;xsd:group name=&quot;forOrUntilGroup&quot;&gt; &lt;xsd:choice&gt; &lt;xsd:element ref=&quot;for&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;until&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt;&lt;/xsd:group&gt;&lt;xsd:element name=&quot;for&quot; type=&quot;tDuration-expr&quot;/&gt;&lt;xsd:element name=&quot;until&quot; type=&quot;tDeadline-expr&quot;/&gt;&lt;xsd:element name=&quot;repeatEvery&quot; type=&quot;tDuration-expr&quot;/&gt; 可以看到，forOrUntilGroup还真就是for或者until两个元素中选一个。这两个东西又分别通过tDuration-expr，tDeadline-expr来定义。 刚好element：repeatEvery也在这后边，一起讲了吧，同样通过tDuration-expr来定义。 complexType：tActivity123456789101112&lt;xsd:complexType name=&quot;tActivity&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;targets&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;sources&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;suppressJoinFailure&quot; type=&quot;tBoolean&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 一看是activity的type，感觉应该出现过，其实并没有，大概是后边会用到吧。 同样基于tExtensibleElements扩展（啥都要tExtensibleElements扩展一下，这兼容性也太强了吧），包含两个元素组成的sequence targets：出现0或1次 sources：出现0或1次 另外还有俩属性： name suppressJoinFailure：有一种故障叫joinFailure，在连接条件求值为 false 时抛出。通过将流程或活动属性 suppressJoinFailure 设置为 yes，可以禁止此故障。 element：targets123456789101112&lt;xsd:element name=&quot;targets&quot; type=&quot;tTargets&quot;/&gt;&lt;xsd:complexType name=&quot;tTargets&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;joinCondition&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;target&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; targets基于tExtensibleElements进行扩展，包含两个元素组成的sequence： joinCondition：0或1个 target：1到多个 element：joinCondition1&lt;xsd:element name=&quot;joinCondition&quot; type=&quot;tCondition&quot;/&gt; 这玩意儿的定义在tCondition里边，其实装的就是几乎啥都可以写的混合内容。 element：target123456789&lt;xsd:element name=&quot;target&quot; type=&quot;tTarget&quot;/&gt;&lt;xsd:complexType name=&quot;tTarget&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;linkName&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; tTarget这个东西是一个机遇tExtensibleElements扩展的元素，就增加了一个元素 linkName：NCName，必填，写上你的目标 element：sources1234567891011121314151617181920212223242526&lt;xsd:element name=&quot;sources&quot; type=&quot;tSources&quot;/&gt;&lt;xsd:complexType name=&quot;tSources&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;source&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;source&quot; type=&quot;tSource&quot;/&gt;&lt;xsd:complexType name=&quot;tSource&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;transitionCondition&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;linkName&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;transitionCondition&quot; type=&quot;tCondition&quot;/&gt; sources：tExtensibleElements，以及1到多个source source：tExtensibleElements扩展，还有一个元素的sequence transitionCondition：转移条件，可以不出现，也可以出现一次 还有一个属性 linkName：NCName，必填，写上你的来源 element：assign123456789101112131415&lt;xsd:element name=&quot;assign&quot; type=&quot;tAssign&quot;/&gt;&lt;xsd:complexType name=&quot;tAssign&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:choice maxOccurs=&quot;unbounded&quot;&gt; &lt;xsd:element ref=&quot;copy&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;extensionAssignOperation&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;validate&quot; type=&quot;tBoolean&quot; use=&quot;optional&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; Assign，基于tActivity扩展，增加了两个属性，二选一只猴构成sequence copy：出现1至多次 extensionAssignOperation：出现1至多次 还增加了一个属性 validate：bool值，默认是no，可选 element：copy1234567891011121314&lt;xsd:element name=&quot;copy&quot; type=&quot;tCopy&quot;/&gt;&lt;xsd:complexType name=&quot;tCopy&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;from&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;to&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;keepSrcElementName&quot; type=&quot;tBoolean&quot; use=&quot;optional&quot; default=&quot;no&quot;/&gt; &lt;xsd:attribute name=&quot;ignoreMissingFromData&quot; type=&quot;tBoolean&quot; use=&quot;optional&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; copy，基于tExtensibleElements扩展，两个元素比较好理解 from：从哪里copy to：copy到哪里 还有两个属性： keepSrcElementName：bool值，可选，默认no，是否保存源元素的属性名 ignoreMissingFromData：bool值，可选，默认no，是否忽略数据中的遗失部分 element：from12345678910111213141516171819&lt;xsd:element name=&quot;from&quot; type=&quot;tFrom&quot;/&gt;&lt;xsd:complexType name=&quot;tFrom&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;documentation&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:choice minOccurs=&quot;0&quot;&gt; &lt;xsd:element ref=&quot;literal&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;query&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;expressionLanguage&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot;/&gt; &lt;xsd:attribute name=&quot;part&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;property&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;endpointReference&quot; type=&quot;tRoles&quot;/&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; 然而这个from并不简单，我们先看看这个sequence里边装了什么 documentation：element，0至多个，前边定义过了，基本上就是一个mixed的啥都可以写的东西，属性里边指明source和language就可以了 any：0至多个来自其他命名空间的任意元素 literal/query：这俩二选一，具体是啥看后边定义 还有几个属性 expressionLanguage：表达语言 variable：BPELVariableName part：来自哪一部分 property：属性是什么 partnerLink endpointReference：通过tRoles定义 anyAttribute：还可以随便加其他属性 element：literal1234567&lt;xsd:element name=&quot;literal&quot; type=&quot;tLiteral&quot;/&gt;&lt;xsd:complexType name=&quot;tLiteral&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any namespace=&quot;##any&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt;&lt;/xsd:complexType&gt; literal就是一个mixed描述段落，里边可以有一个任意元素。 element：query123456789&lt;xsd:element name=&quot;query&quot; type=&quot;tQuery&quot;/&gt;&lt;xsd:complexType name=&quot;tQuery&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;queryLanguage&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; Query和literal相似，是一个mixed描述段落，里边可以有任意个任意元素。同时它还有属性 queryLanguage：表明查询语言 anyAttribute：看似随便加属性，实际上根据查询语言不通增加其他属性 simpleType：tRoles123456&lt;xsd:simpleType name=&quot;tRoles&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;myRole&quot;/&gt; &lt;xsd:enumeration value=&quot;partnerRole&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; myRole和partnerRole两个值二选一 element：to123456789101112131415&lt;xsd:element name=&quot;to&quot; type=&quot;tTo&quot;/&gt;&lt;xsd:complexType name=&quot;tTo&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;documentation&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;query&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;expressionLanguage&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot;/&gt; &lt;xsd:attribute name=&quot;part&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;property&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; 这个to也不简单，我们看看这个sequence里边装了什么 documentation：element，0至多个，前边定义过了，基本上就是一个mixed的啥都可以写的东西，属性里边指明source和language就可以了 any：0至多个来自其他命名空间的任意元素 query：查询到对应写入的部分 还有几个属性 expressionLanguage：表达语言 variable：BPELVariableName part：去哪一部分 property：属性是什么 partnerLink anyAttribute：还可以根据表达语言随便加其他属性 element：extensionAssignOperation1234567&lt;xsd:element name=&quot;extensionAssignOperation&quot; type=&quot;tExtensionAssignOperation&quot;/&gt;&lt;xsd:complexType name=&quot;tExtensionAssignOperation&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 这个东西是assign中的一个element，怪不得assign没有基于tExtensibleElements扩展，放在里边了。 element：compensate1234567&lt;xsd:element name=&quot;compensate&quot; type=&quot;tCompensate&quot;/&gt;&lt;xsd:complexType name=&quot;tCompensate&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 就是tActivity的一个元素化，可以看作是一个最原始，最纯粹的activity。 element：compensateScope123456789&lt;xsd:element name=&quot;compensateScope&quot; type=&quot;tCompensateScope&quot;/&gt;&lt;xsd:complexType name=&quot;tCompensateScope&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:attribute name=&quot;target&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 在compensate之上增加了一个属性： target：相当于给补偿增加了一个范围 element：empty1234567&lt;xsd:element name=&quot;empty&quot; type=&quot;tEmpty&quot;/&gt;&lt;xsd:complexType name=&quot;tEmpty&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 就是tActivity的一个元素化，可以看作是一个最原始，最纯粹的activity。 和compensate是一样的，在语义上和用法上不一样。 element：exit1234567&lt;xsd:element name=&quot;exit&quot; type=&quot;tExit&quot;/&gt;&lt;xsd:complexType name=&quot;tExit&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 就是tActivity的一个元素化，可以看作是一个最原始，最纯粹的activity。 和compensate、empty定义是一样的，在语义上和用法上不一样。 element：extensionActivity1234567&lt;xsd:element name=&quot;extensionActivity&quot; type=&quot;tExtensionActivity&quot;/&gt;&lt;xsd:complexType name=&quot;tExtensionActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt; &lt;/xsd:sequence&gt;&lt;/xsd:complexType&gt; 允许从其他命名空间增加元素当作activity装进来 element：flow123456789101112&lt;xsd:element name=&quot;flow&quot; type=&quot;tFlow&quot;/&gt;&lt;xsd:complexType name=&quot;tFlow&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;links&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 基于tActivity进行扩展，sequence中包含： element links：可以没有，在后边定义 group activity：1到多个activity的group，算是一个嵌套的定义 element：links123456789101112131415161718192021&lt;xsd:element name=&quot;links&quot; type=&quot;tLinks&quot;/&gt;&lt;xsd:complexType name=&quot;tLinks&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;link&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;link&quot; type=&quot;tLink&quot;/&gt;&lt;xsd:complexType name=&quot;tLink&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; links基于tExtensibleElements进行扩展（辣个男人又回来了），包含1至多个link link同样基于tExtensibleElements进行扩展，增加了一个属性 name：NCName，这就是link的真相了 element：forEach1234567891011121314151617181920&lt;xsd:element name=&quot;forEach&quot; type=&quot;tForEach&quot;/&gt;&lt;xsd:complexType name=&quot;tForEach&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;startCounterValue&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;finalCounterValue&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;completionCondition&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;scope&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;counterName&quot; type=&quot;BPELVariableName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;parallel&quot; type=&quot;tBoolean&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;startCounterValue&quot; type=&quot;tExpression&quot;/&gt;&lt;xsd:element name=&quot;finalCounterValue&quot; type=&quot;tExpression&quot;/&gt; 看名字就知道是一个forEach循环了，element包括 startCounterValue finalCounterValue completionCondition scope 这四个应该不用解释了吧，for循环要素 然后还有两个属性 counterName：计数器的名称 parallel：是否并行 element：completionCondition1234567891011&lt;xsd:element name=&quot;completionCondition&quot; type=&quot;tCompletionCondition&quot;/&gt;&lt;xsd:complexType name=&quot;tCompletionCondition&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;branches&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 这个condition由一组branches构成 element：branches123456789&lt;xsd:element name=&quot;branches&quot; type=&quot;tBranches&quot;/&gt;&lt;xsd:complexType name=&quot;tBranches&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExpression&quot;&gt; &lt;xsd:attribute name=&quot;successfulBranchesOnly&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; branches基于tExpression进行扩展，还有一个属性 successfulBranchesOnly：默认是no element：if1234567891011121314&lt;xsd:element name=&quot;if&quot; type=&quot;tIf&quot;/&gt;&lt;xsd:complexType name=&quot;tIf&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;condition&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;elseif&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;else&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; if也是一类activity，基于tAcitivity进行扩展，sequence中包括 condition：element，至少一个 activity：group，至少一个 elseif：element，0到多个 else：element，可以没有 element：elseif1234567891011121314&lt;xsd:element name=&quot;elseif&quot; type=&quot;tElseif&quot;/&gt;&lt;xsd:complexType name=&quot;tElseif&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;condition&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;else&quot; type=&quot;tActivityContainer&quot;/&gt; elseif基于tExtensibleElements扩展，sequence中包括 condition：element，数量1 activity：group，数量1 Else就直接是tActivityContainer了，condition都不用。 element：invoke1234567891011121314151617181920212223242526&lt;xsd:element name=&quot;invoke&quot; type=&quot;tInvoke&quot;/&gt;&lt;xsd:complexType name=&quot;tInvoke&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlations needs to be a Local Element Declaration, because there is another correlations element defined for the non-invoke activities. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlations&quot; type=&quot;tCorrelationsWithPattern&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;catch&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;catchAll&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;compensationHandler&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;toParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;fromParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;portType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;operation&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;inputVariable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;outputVariable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; annotation说明就不讲了 基于tActivity扩展，用调用其他 Web 服务，element有6个 correlations：本地的元素声明 catch catchAll compensationHandler toParts fromParts attribute有5个 partnerLink portType operation inputVariable outputVariable 感觉看名字就懂了，没啥好讲的 complexType：tCorrelationsWithPattern123456789101112131415161718192021222324252627282930&lt;xsd:complexType name=&quot;tCorrelationsWithPattern&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlation needs to be a Local Element Declaration, because there is another correlation element defined for the non-invoke activities. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlation&quot; type=&quot;tCorrelationWithPattern&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:complexType name=&quot;tCorrelationWithPattern&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tCorrelation&quot;&gt; &lt;xsd:attribute name=&quot;pattern&quot; type=&quot;tPattern&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:simpleType name=&quot;tPattern&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;request&quot;/&gt; &lt;xsd:enumeration value=&quot;response&quot;/&gt; &lt;xsd:enumeration value=&quot;request-response&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; 一通定义，实际上这个tCorrelationsWithPattern就是1至多个tCorrelationWithPattern 这个tCorrelationWithPattern从tCorrelation进行扩展，增加了属性pattern 这个pattern就是request、response、request-response三选一 element：fromParts12345678910111213141516171819202122&lt;xsd:element name=&quot;fromParts&quot; type=&quot;tFromParts&quot;/&gt;&lt;xsd:complexType name=&quot;tFromParts&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;fromPart&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;fromPart&quot; type=&quot;tFromPart&quot;/&gt;&lt;xsd:complexType name=&quot;tFromPart&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;part&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;toVariable&quot; type=&quot;BPELVariableName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; fromParts扩展自tExtensibleElements，由1到多个fromPart组成 fromPart同样扩展自tExtensibleElements，包含两个attribute part toVariable element：toParts12345678910111213141516171819202122&lt;xsd:element name=&quot;toParts&quot; type=&quot;tToParts&quot;/&gt;&lt;xsd:complexType name=&quot;tToParts&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;toPart&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;toPart&quot; type=&quot;tToPart&quot;/&gt;&lt;xsd:complexType name=&quot;tToPart&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;part&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;fromVariable&quot; type=&quot;BPELVariableName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; toParts扩展自tExtensibleElements，由1到多个toPart组成 toPart同样扩展自tExtensibleElements，包含两个attribute part fromVariable element：pick123456789101112131415161718&lt;xsd:element name=&quot;pick&quot; type=&quot;tPick&quot;/&gt;&lt;xsd:complexType name=&quot;tPick&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element onAlarm needs to be a Local Element Declaration, because there is another onAlarm element defined for event handlers. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;onMessage&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element name=&quot;onAlarm&quot; type=&quot;tOnAlarmPick&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;createInstance&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; pick扩展自tActivity 两个属性都在后边定义： onMessage onAlarm 一个属性： createInstance element：onMessage1234567891011&lt;xsd:element name=&quot;onMessage&quot; type=&quot;tOnMessage&quot;/&gt;&lt;xsd:complexType name=&quot;tOnMessage&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tOnMsgCommon&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tOnMsgCommon sequence中是一个activity的group complexType：tOnAlarmPick12345678910&lt;xsd:complexType name=&quot;tOnAlarmPick&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;forOrUntilGroup&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tExtensibleElements sequence中有两个group forOrUntilGroup activity 都是出现一次 element：receive1234567891011121314151617181920212223&lt;xsd:element name=&quot;receive&quot; type=&quot;tReceive&quot;/&gt;&lt;xsd:complexType name=&quot;tReceive&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlations needs to be a Local Element Declaration, because there is another correlations element defined for the invoke activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlations&quot; type=&quot;tCorrelations&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;fromParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;portType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;operation&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;createInstance&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;xsd:attribute name=&quot;messageExchange&quot; type=&quot;xsd:NCName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，用于（接收请求）等待客户端通过发送消息调用业务流程 2个element correlations fromParts 6个attribute partnerLink portType operation variable createInstance messageExchange element：repeatUntil123456789101112&lt;xsd:element name=&quot;repeatUntil&quot; type=&quot;tRepeatUntil&quot;/&gt;&lt;xsd:complexType name=&quot;tRepeatUntil&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;condition&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity sequence中包含 activity：group，数量为1 condition：element，数量也是1 element：reply1234567891011121314151617181920212223&lt;xsd:element name=&quot;reply&quot; type=&quot;tReply&quot;/&gt;&lt;xsd:complexType name=&quot;tReply&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlations needs to be a Local Element Declaration, because there is another correlations element defined for the invoke activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlations&quot; type=&quot;tCorrelations&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;toParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;portType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;operation&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;faultName&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;messageExchange&quot; type=&quot;xsd:NCName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，用于生成同步操作的响应 2个element correlations toParts 6个attribute partnerLink portType operation variable faultName messageExchange element：rethrow1234567&lt;xsd:element name=&quot;rethrow&quot; type=&quot;tRethrow&quot;/&gt;&lt;xsd:complexType name=&quot;tRethrow&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 就是tActivity的一个元素化，可以看作是一个最原始，最纯粹的activity。 和compensate、empty，exit定义是一样的，就是在语义上和用法上不一样。 element：scope1234567891011121314151617181920212223242526&lt;xsd:element name=&quot;scope&quot; type=&quot;tScope&quot;/&gt;&lt;xsd:complexType name=&quot;tScope&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;There is no schema-level default for &quot;exitOnStandardFault&quot; at &quot;scope&quot;. Because, it will inherit default from enclosing scope or process. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;partnerLinks&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;messageExchanges&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;variables&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;correlationSets&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;faultHandlers&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;compensationHandler&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;terminationHandler&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;eventHandlers&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;isolated&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;xsd:attribute name=&quot;exitOnStandardFault&quot; type=&quot;tBoolean&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，用于以分层方式将复杂流程划分为多个组织部分。scope为活动提供了行为上下文。换言之，scope可以为不同的活动（或在 或 ) 等通用的结构化活动下收集的活动集）定义不同的故障处理程序。除了定义故障处理程序以外，scope还可以声明只在作用域中可见的变量。scope还可以定义本地关联集、补偿处理程序和事件处理程序。 sequence中有： partnerLinks messageExchanges variables correlationSets faultHandlers compensationHandler terminationHandler eventHandlers activity 还有两个属性 isolated exitOnStandardFault element：compensationHandler1234567&lt;xsd:element name=&quot;compensationHandler&quot; type=&quot;tActivityContainer&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This element can contain all activities including the activities compensate and compensateScope. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt; 实际上就是一个tActivityContainer element：terminationHandler1234567&lt;xsd:element name=&quot;terminationHandler&quot; type=&quot;tActivityContainer&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This element can contain all activities including the activities compensate and compensateScope. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt; 实际上就是一个tActivityContainer element：sequence1234567891011&lt;xsd:element name=&quot;sequence&quot; type=&quot;tSequence&quot;/&gt;&lt;xsd:complexType name=&quot;tSequence&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，但是里边还可以装很多的activity的group的序列 element：throw12345678910&lt;xsd:element name=&quot;throw&quot; type=&quot;tThrow&quot;/&gt;&lt;xsd:complexType name=&quot;tThrow&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:attribute name=&quot;faultName&quot; type=&quot;xsd:QName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;faultVariable&quot; type=&quot;BPELVariableName&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，增加了两个属性 faultName faultVariable element：validate123456789&lt;xsd:element name=&quot;validate&quot; type=&quot;tValidate&quot;/&gt;&lt;xsd:complexType name=&quot;tValidate&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:attribute name=&quot;variables&quot; use=&quot;required&quot; type=&quot;BPELVariableNames&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，增加了1个属性 variables：BPELVariableNames simpleType：BPELVariableNames12345678&lt;xsd:simpleType name=&quot;BPELVariableNames&quot;&gt; &lt;xsd:restriction&gt; &lt;xsd:simpleType&gt; &lt;xsd:list itemType=&quot;BPELVariableName&quot;/&gt; &lt;/xsd:simpleType&gt; &lt;xsd:minLength value=&quot;1&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; 一个BPELVariableName的list，默认空格分割，最短一个 element：wait123456789101112&lt;xsd:element name=&quot;wait&quot; type=&quot;tWait&quot;/&gt;&lt;xsd:complexType name=&quot;tWait&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:choice&gt; &lt;xsd:element ref=&quot;for&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;until&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，增加了元素，从for和until中二选一 element：while123456789101112&lt;xsd:element name=&quot;while&quot; type=&quot;tWhile&quot;/&gt;&lt;xsd:complexType name=&quot;tWhile&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;condition&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，增加了一个sequence，里边有 condition activity complexType：tExpression1234567&lt;xsd:complexType name=&quot;tExpression&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; processContents=&quot;lax&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;expressionLanguage&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; tExpression的内容基本就是随便写 属性有一个expressionLanguage，然后还可以再增加其他属性 看起来是any，实际上要看expressionLanguage的 complexType：tCondition12345&lt;xsd:complexType name=&quot;tCondition&quot;&gt; &lt;xsd:complexContent mixed=&quot;true&quot;&gt; &lt;xsd:extension base=&quot;tExpression&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; tCondition就是在tExpression的基础上随便写 element：condition1234567&lt;xsd:element name=&quot;condition&quot; type=&quot;tBoolean-expr&quot;/&gt;&lt;xsd:complexType name=&quot;tBoolean-expr&quot;&gt; &lt;xsd:complexContent mixed=&quot;true&quot;&gt; &lt;xsd:extension base=&quot;tExpression&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; condition也是在tExpression的基础上随便写 complexType：tDuration-expr12345&lt;xsd:complexType name=&quot;tDuration-expr&quot;&gt; &lt;xsd:complexContent mixed=&quot;true&quot;&gt; &lt;xsd:extension base=&quot;tExpression&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 在tExpression的基础上随便写 complexType：tDeadline-expr12345&lt;xsd:complexType name=&quot;tDeadline-expr&quot;&gt; &lt;xsd:complexContent mixed=&quot;true&quot;&gt; &lt;xsd:extension base=&quot;tExpression&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 在tExpression的基础上随便写 simpleType：tBoolean123456&lt;xsd:simpleType name=&quot;tBoolean&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;yes&quot;/&gt; &lt;xsd:enumeration value=&quot;no&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; yes or no，二选一]]></content>
      <tags>
        <tag>bpel</tag>
        <tag>wsbpel</tag>
        <tag>ws-bpel</tag>
        <tag>bpel2.0</tag>
        <tag>schema</tag>
        <tag>xsd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WS-BPEL 2.0 xml schema 详解(三)]]></title>
    <url>%2F2019%2F03%2F22%2FWS-BPEL-2-0-xml-schema-%E8%AF%A6%E8%A7%A3-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[element：exit1234567&lt;xsd:element name=&quot;exit&quot; type=&quot;tExit&quot;/&gt;&lt;xsd:complexType name=&quot;tExit&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 就是tActivity的一个元素化，可以看作是一个最原始，最纯粹的activity。 和compensate、empty定义是一样的，在语义上和用法上不一样。 element：extensionActivity1234567&lt;xsd:element name=&quot;extensionActivity&quot; type=&quot;tExtensionActivity&quot;/&gt;&lt;xsd:complexType name=&quot;tExtensionActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt; &lt;/xsd:sequence&gt;&lt;/xsd:complexType&gt; 允许从其他命名空间增加元素当作activity装进来 element：flow123456789101112&lt;xsd:element name=&quot;flow&quot; type=&quot;tFlow&quot;/&gt;&lt;xsd:complexType name=&quot;tFlow&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;links&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 基于tActivity进行扩展，sequence中包含： element links：可以没有，在后边定义 group activity：1到多个activity的group，算是一个嵌套的定义 element：links123456789101112131415161718192021&lt;xsd:element name=&quot;links&quot; type=&quot;tLinks&quot;/&gt;&lt;xsd:complexType name=&quot;tLinks&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;link&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;link&quot; type=&quot;tLink&quot;/&gt;&lt;xsd:complexType name=&quot;tLink&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; links基于tExtensibleElements进行扩展（辣个男人又回来了），包含1至多个link link同样基于tExtensibleElements进行扩展，增加了一个属性 name：NCName，这就是link的真相了 element：forEach1234567891011121314151617181920&lt;xsd:element name=&quot;forEach&quot; type=&quot;tForEach&quot;/&gt;&lt;xsd:complexType name=&quot;tForEach&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;startCounterValue&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;finalCounterValue&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;completionCondition&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;scope&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;counterName&quot; type=&quot;BPELVariableName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;parallel&quot; type=&quot;tBoolean&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;startCounterValue&quot; type=&quot;tExpression&quot;/&gt;&lt;xsd:element name=&quot;finalCounterValue&quot; type=&quot;tExpression&quot;/&gt; 看名字就知道是一个forEach循环了，element包括 startCounterValue finalCounterValue completionCondition scope 这四个应该不用解释了吧，for循环要素 然后还有两个属性 counterName：计数器的名称 parallel：是否并行 element：completionCondition1234567891011&lt;xsd:element name=&quot;completionCondition&quot; type=&quot;tCompletionCondition&quot;/&gt;&lt;xsd:complexType name=&quot;tCompletionCondition&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;branches&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 这个condition由一组branches构成 element：branches123456789&lt;xsd:element name=&quot;branches&quot; type=&quot;tBranches&quot;/&gt;&lt;xsd:complexType name=&quot;tBranches&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExpression&quot;&gt; &lt;xsd:attribute name=&quot;successfulBranchesOnly&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; branches基于tExpression进行扩展，还有一个属性 successfulBranchesOnly：默认是no element：if1234567891011121314&lt;xsd:element name=&quot;if&quot; type=&quot;tIf&quot;/&gt;&lt;xsd:complexType name=&quot;tIf&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;condition&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;elseif&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;else&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; if也是一类activity，基于tAcitivity进行扩展，sequence中包括 condition：element，至少一个 activity：group，至少一个 elseif：element，0到多个 else：element，可以没有 element：elseif1234567891011121314&lt;xsd:element name=&quot;elseif&quot; type=&quot;tElseif&quot;/&gt;&lt;xsd:complexType name=&quot;tElseif&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;condition&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;else&quot; type=&quot;tActivityContainer&quot;/&gt; elseif基于tExtensibleElements扩展，sequence中包括 condition：element，数量1 activity：group，数量1 Else就直接是tActivityContainer了，condition都不用。 element：invoke1234567891011121314151617181920212223242526&lt;xsd:element name=&quot;invoke&quot; type=&quot;tInvoke&quot;/&gt;&lt;xsd:complexType name=&quot;tInvoke&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlations needs to be a Local Element Declaration, because there is another correlations element defined for the non-invoke activities. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlations&quot; type=&quot;tCorrelationsWithPattern&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;catch&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;catchAll&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;compensationHandler&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;toParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;fromParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;portType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;operation&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;inputVariable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;outputVariable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; annotation说明就不讲了 基于tActivity扩展，用调用其他 Web 服务，element有6个 correlations：本地的元素声明 catch catchAll compensationHandler toParts fromParts attribute有5个 partnerLink portType operation inputVariable outputVariable 感觉看名字就懂了，没啥好讲的 complexType：tCorrelationsWithPattern123456789101112131415161718192021222324252627282930&lt;xsd:complexType name=&quot;tCorrelationsWithPattern&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlation needs to be a Local Element Declaration, because there is another correlation element defined for the non-invoke activities. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlation&quot; type=&quot;tCorrelationWithPattern&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:complexType name=&quot;tCorrelationWithPattern&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tCorrelation&quot;&gt; &lt;xsd:attribute name=&quot;pattern&quot; type=&quot;tPattern&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:simpleType name=&quot;tPattern&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;request&quot;/&gt; &lt;xsd:enumeration value=&quot;response&quot;/&gt; &lt;xsd:enumeration value=&quot;request-response&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; 一通定义，实际上这个tCorrelationsWithPattern就是1至多个tCorrelationWithPattern 这个tCorrelationWithPattern从tCorrelation进行扩展，增加了属性pattern 这个pattern就是request、response、request-response三选一 element：fromParts12345678910111213141516171819202122&lt;xsd:element name=&quot;fromParts&quot; type=&quot;tFromParts&quot;/&gt;&lt;xsd:complexType name=&quot;tFromParts&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;fromPart&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;fromPart&quot; type=&quot;tFromPart&quot;/&gt;&lt;xsd:complexType name=&quot;tFromPart&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;part&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;toVariable&quot; type=&quot;BPELVariableName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; fromParts扩展自tExtensibleElements，由1到多个fromPart组成 fromPart同样扩展自tExtensibleElements，包含两个attribute part toVariable element：toParts12345678910111213141516171819202122&lt;xsd:element name=&quot;toParts&quot; type=&quot;tToParts&quot;/&gt;&lt;xsd:complexType name=&quot;tToParts&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;toPart&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;toPart&quot; type=&quot;tToPart&quot;/&gt;&lt;xsd:complexType name=&quot;tToPart&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;part&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;fromVariable&quot; type=&quot;BPELVariableName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; toParts扩展自tExtensibleElements，由1到多个toPart组成 toPart同样扩展自tExtensibleElements，包含两个attribute part fromVariable element：pick123456789101112131415161718&lt;xsd:element name=&quot;pick&quot; type=&quot;tPick&quot;/&gt;&lt;xsd:complexType name=&quot;tPick&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element onAlarm needs to be a Local Element Declaration, because there is another onAlarm element defined for event handlers. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;onMessage&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element name=&quot;onAlarm&quot; type=&quot;tOnAlarmPick&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;createInstance&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; pick扩展自tActivity 两个属性都在后边定义： onMessage onAlarm 一个属性： createInstance element：onMessage1234567891011&lt;xsd:element name=&quot;onMessage&quot; type=&quot;tOnMessage&quot;/&gt;&lt;xsd:complexType name=&quot;tOnMessage&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tOnMsgCommon&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tOnMsgCommon sequence中是一个activity的group complexType：tOnAlarmPick12345678910&lt;xsd:complexType name=&quot;tOnAlarmPick&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;forOrUntilGroup&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tExtensibleElements sequence中有两个group forOrUntilGroup activity 都是出现一次 element：receive1234567891011121314151617181920212223&lt;xsd:element name=&quot;receive&quot; type=&quot;tReceive&quot;/&gt;&lt;xsd:complexType name=&quot;tReceive&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlations needs to be a Local Element Declaration, because there is another correlations element defined for the invoke activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlations&quot; type=&quot;tCorrelations&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;fromParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;portType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;operation&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;createInstance&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;xsd:attribute name=&quot;messageExchange&quot; type=&quot;xsd:NCName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，用于（接收请求）等待客户端通过发送消息调用业务流程 2个element correlations fromParts 6个attribute partnerLink portType operation variable createInstance messageExchange element：repeatUntil123456789101112&lt;xsd:element name=&quot;repeatUntil&quot; type=&quot;tRepeatUntil&quot;/&gt;&lt;xsd:complexType name=&quot;tRepeatUntil&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;condition&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity sequence中包含 activity：group，数量为1 condition：element，数量也是1 element：reply1234567891011121314151617181920212223&lt;xsd:element name=&quot;reply&quot; type=&quot;tReply&quot;/&gt;&lt;xsd:complexType name=&quot;tReply&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlations needs to be a Local Element Declaration, because there is another correlations element defined for the invoke activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlations&quot; type=&quot;tCorrelations&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;toParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;portType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;operation&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;faultName&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;messageExchange&quot; type=&quot;xsd:NCName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，用于生成同步操作的响应 2个element correlations toParts 6个attribute partnerLink portType operation variable faultName messageExchange element：rethrow1234567&lt;xsd:element name=&quot;rethrow&quot; type=&quot;tRethrow&quot;/&gt;&lt;xsd:complexType name=&quot;tRethrow&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 就是tActivity的一个元素化，可以看作是一个最原始，最纯粹的activity。 和compensate、empty，exit定义是一样的，就是在语义上和用法上不一样。 element：scope1234567891011121314151617181920212223242526&lt;xsd:element name=&quot;scope&quot; type=&quot;tScope&quot;/&gt;&lt;xsd:complexType name=&quot;tScope&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;There is no schema-level default for &quot;exitOnStandardFault&quot; at &quot;scope&quot;. Because, it will inherit default from enclosing scope or process. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;partnerLinks&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;messageExchanges&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;variables&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;correlationSets&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;faultHandlers&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;compensationHandler&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;terminationHandler&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;eventHandlers&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;isolated&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;xsd:attribute name=&quot;exitOnStandardFault&quot; type=&quot;tBoolean&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，用于以分层方式将复杂流程划分为多个组织部分。scope为活动提供了行为上下文。换言之，scope可以为不同的活动（或在 或 ) 等通用的结构化活动下收集的活动集）定义不同的故障处理程序。除了定义故障处理程序以外，scope还可以声明只在作用域中可见的变量。scope还可以定义本地关联集、补偿处理程序和事件处理程序。 sequence中有： partnerLinks messageExchanges variables correlationSets faultHandlers compensationHandler terminationHandler eventHandlers activity 还有两个属性 isolated exitOnStandardFault element：compensationHandler1234567&lt;xsd:element name=&quot;compensationHandler&quot; type=&quot;tActivityContainer&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This element can contain all activities including the activities compensate and compensateScope. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt; 实际上就是一个tActivityContainer element：terminationHandler1234567&lt;xsd:element name=&quot;terminationHandler&quot; type=&quot;tActivityContainer&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This element can contain all activities including the activities compensate and compensateScope. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt; 实际上就是一个tActivityContainer element：sequence1234567891011&lt;xsd:element name=&quot;sequence&quot; type=&quot;tSequence&quot;/&gt;&lt;xsd:complexType name=&quot;tSequence&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，但是里边还可以装很多的activity的group的序列 element：throw12345678910&lt;xsd:element name=&quot;throw&quot; type=&quot;tThrow&quot;/&gt;&lt;xsd:complexType name=&quot;tThrow&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:attribute name=&quot;faultName&quot; type=&quot;xsd:QName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;faultVariable&quot; type=&quot;BPELVariableName&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，增加了两个属性 faultName faultVariable element：validate123456789&lt;xsd:element name=&quot;validate&quot; type=&quot;tValidate&quot;/&gt;&lt;xsd:complexType name=&quot;tValidate&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:attribute name=&quot;variables&quot; use=&quot;required&quot; type=&quot;BPELVariableNames&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，增加了1个属性 variables：BPELVariableNames simpleType：BPELVariableNames12345678&lt;xsd:simpleType name=&quot;BPELVariableNames&quot;&gt; &lt;xsd:restriction&gt; &lt;xsd:simpleType&gt; &lt;xsd:list itemType=&quot;BPELVariableName&quot;/&gt; &lt;/xsd:simpleType&gt; &lt;xsd:minLength value=&quot;1&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; 一个BPELVariableName的list，默认空格分割，最短一个 element：wait123456789101112&lt;xsd:element name=&quot;wait&quot; type=&quot;tWait&quot;/&gt;&lt;xsd:complexType name=&quot;tWait&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:choice&gt; &lt;xsd:element ref=&quot;for&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;until&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，增加了元素，从for和until中二选一 element：while123456789101112&lt;xsd:element name=&quot;while&quot; type=&quot;tWhile&quot;/&gt;&lt;xsd:complexType name=&quot;tWhile&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;condition&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 扩展自tActivity，增加了一个sequence，里边有 condition activity complexType：tExpression1234567&lt;xsd:complexType name=&quot;tExpression&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; processContents=&quot;lax&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;expressionLanguage&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; tExpression的内容基本就是随便写 属性有一个expressionLanguage，然后还可以再增加其他属性 看起来是any，实际上要看expressionLanguage的 complexType：tCondition12345&lt;xsd:complexType name=&quot;tCondition&quot;&gt; &lt;xsd:complexContent mixed=&quot;true&quot;&gt; &lt;xsd:extension base=&quot;tExpression&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; tCondition就是在tExpression的基础上随便写 element：condition1234567&lt;xsd:element name=&quot;condition&quot; type=&quot;tBoolean-expr&quot;/&gt;&lt;xsd:complexType name=&quot;tBoolean-expr&quot;&gt; &lt;xsd:complexContent mixed=&quot;true&quot;&gt; &lt;xsd:extension base=&quot;tExpression&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; condition也是在tExpression的基础上随便写 complexType：tDuration-expr12345&lt;xsd:complexType name=&quot;tDuration-expr&quot;&gt; &lt;xsd:complexContent mixed=&quot;true&quot;&gt; &lt;xsd:extension base=&quot;tExpression&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 在tExpression的基础上随便写 complexType：tDeadline-expr12345&lt;xsd:complexType name=&quot;tDeadline-expr&quot;&gt; &lt;xsd:complexContent mixed=&quot;true&quot;&gt; &lt;xsd:extension base=&quot;tExpression&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 在tExpression的基础上随便写 simpleType：tBoolean123456&lt;xsd:simpleType name=&quot;tBoolean&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;yes&quot;/&gt; &lt;xsd:enumeration value=&quot;no&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; yes or no，二选一]]></content>
      <tags>
        <tag>bpel</tag>
        <tag>wsbpel</tag>
        <tag>ws-bpel</tag>
        <tag>bpel2.0</tag>
        <tag>schema</tag>
        <tag>xsd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WS-BPEL 2.0 xml schema 详解(二)]]></title>
    <url>%2F2019%2F03%2F22%2FWS-BPEL-2-0-xml-schema-%E8%AF%A6%E8%A7%A3-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[element：eventHandlers1234567891011121314151617&lt;xsd:element name=&quot;eventHandlers&quot; type=&quot;tEventHandlers&quot;/&gt;&lt;xsd:complexType name=&quot;tEventHandlers&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element onAlarm needs to be a Local Element Declaration, because there is another onAlarm element defined for the pick activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;onEvent&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element name=&quot;onAlarm&quot; type=&quot;tOnAlarmEvent&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; eventHandlers基于tExtensibleElements扩展，由2种元素的sequence组成： onEvent：见element：onEvent onAlarm：见complexType：tOnAlarmEvent element：onEvent12345678910111213&lt;xsd:element name=&quot;onEvent&quot; type=&quot;tOnEvent&quot;/&gt;&lt;xsd:complexType name=&quot;tOnEvent&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tOnMsgCommon&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;scope&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;messageType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;element&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; onEvent元素基于tOnMsgCommon进行扩展，包含一个element sequence： scope：用于表明作用范围 2个attribute： messageType element complexType：tOnMsgCommon1234567891011121314151617181920&lt;xsd:complexType name=&quot;tOnMsgCommon&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlations needs to be a Local Element Declaration, because there is another correlations element defined for the invoke activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlations&quot; type=&quot;tCorrelations&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;fromParts&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;portType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;operation&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;messageExchange&quot; type=&quot;xsd:NCName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; tOnMsgCommon这个complexType同样支持tExtensibleElements扩展，包含由两类element组成的sequence： correlations：type为tCorrelations fromParts 同时还引入了5种属性： partnerLink：必填的链接名 portType：选填的端口类型 operation：必填的操作 messageExchange：选填的操作信息 variable：选填的变量 complexType：tCorrelations12345678910111213141516171819202122232425262728293031&lt;xsd:complexType name=&quot;tCorrelations&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;XSD Authors: The child element correlation needs to be a Local Element Declaration, because there is another correlation element defined for the invoke activity. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element name=&quot;correlation&quot; type=&quot;tCorrelation&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:complexType name=&quot;tCorrelation&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;set&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;initiate&quot; type=&quot;tInitiate&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:simpleType name=&quot;tInitiate&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;yes&quot;/&gt; &lt;xsd:enumeration value=&quot;join&quot;/&gt; &lt;xsd:enumeration value=&quot;no&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; tCorrelations基于tExtensibleElements扩展，由1至多个correlation的sequence组成。 tCorrelation同样基于tExtensibleElements扩展，在此之上还定义了两个属性： set initiate：yes | join | no complexType：tOnAlarmEvent12345678910111213141516&lt;xsd:complexType name=&quot;tOnAlarmEvent&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:choice&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;forOrUntilGroup&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;repeatEvery&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:element ref=&quot;repeatEvery&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt; &lt;xsd:element ref=&quot;scope&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; tOnAlarmEvent基于tExtensibleElements扩展，由1个group：forOrUntilGroup 和 0或1个element：repeatEvery组成的sequence，或者1个element：repeatEvery，再加上一个scope组成的sequence组成。 三个元素都通过ref引用，可以继续往后看定义。 group：forOrUntilGroup123456789101112&lt;xsd:group name=&quot;forOrUntilGroup&quot;&gt; &lt;xsd:choice&gt; &lt;xsd:element ref=&quot;for&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;until&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt;&lt;/xsd:group&gt;&lt;xsd:element name=&quot;for&quot; type=&quot;tDuration-expr&quot;/&gt;&lt;xsd:element name=&quot;until&quot; type=&quot;tDeadline-expr&quot;/&gt;&lt;xsd:element name=&quot;repeatEvery&quot; type=&quot;tDuration-expr&quot;/&gt; 可以看到，forOrUntilGroup还真就是for或者until两个元素中选一个。这两个东西又分别通过tDuration-expr，tDeadline-expr来定义。 刚好element：repeatEvery也在这后边，一起讲了吧，同样通过tDuration-expr来定义。 complexType：tActivity123456789101112&lt;xsd:complexType name=&quot;tActivity&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;targets&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;sources&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;suppressJoinFailure&quot; type=&quot;tBoolean&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 一看是activity的type，感觉应该出现过，其实并没有，大概是后边会用到吧。 同样基于tExtensibleElements扩展（啥都要tExtensibleElements扩展一下，这兼容性也太强了吧），包含两个元素组成的sequence targets：出现0或1次 sources：出现0或1次 另外还有俩属性： name suppressJoinFailure：有一种故障叫joinFailure，在连接条件求值为 false 时抛出。通过将流程或活动属性 suppressJoinFailure 设置为 yes，可以禁止此故障。 element：targets123456789101112&lt;xsd:element name=&quot;targets&quot; type=&quot;tTargets&quot;/&gt;&lt;xsd:complexType name=&quot;tTargets&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;joinCondition&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;target&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; targets基于tExtensibleElements进行扩展，包含两个元素组成的sequence： joinCondition：0或1个 target：1到多个 element：joinCondition1&lt;xsd:element name=&quot;joinCondition&quot; type=&quot;tCondition&quot;/&gt; 这玩意儿的定义在tCondition里边，其实装的就是几乎啥都可以写的混合内容。 element：target123456789&lt;xsd:element name=&quot;target&quot; type=&quot;tTarget&quot;/&gt;&lt;xsd:complexType name=&quot;tTarget&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;linkName&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; tTarget这个东西是一个机遇tExtensibleElements扩展的元素，就增加了一个元素 linkName：NCName，必填，写上你的目标 element：sources1234567891011121314151617181920212223242526&lt;xsd:element name=&quot;sources&quot; type=&quot;tSources&quot;/&gt;&lt;xsd:complexType name=&quot;tSources&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;source&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;source&quot; type=&quot;tSource&quot;/&gt;&lt;xsd:complexType name=&quot;tSource&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;transitionCondition&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;linkName&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;transitionCondition&quot; type=&quot;tCondition&quot;/&gt; sources：tExtensibleElements，以及1到多个source source：tExtensibleElements扩展，还有一个元素的sequence transitionCondition：转移条件，可以不出现，也可以出现一次 还有一个属性 linkName：NCName，必填，写上你的来源 element：assign123456789101112131415&lt;xsd:element name=&quot;assign&quot; type=&quot;tAssign&quot;/&gt;&lt;xsd:complexType name=&quot;tAssign&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:choice maxOccurs=&quot;unbounded&quot;&gt; &lt;xsd:element ref=&quot;copy&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;extensionAssignOperation&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;validate&quot; type=&quot;tBoolean&quot; use=&quot;optional&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; Assign，基于tActivity扩展，增加了两个属性，二选一只猴构成sequence copy：出现1至多次 extensionAssignOperation：出现1至多次 还增加了一个属性 validate：bool值，默认是no，可选 element：copy1234567891011121314&lt;xsd:element name=&quot;copy&quot; type=&quot;tCopy&quot;/&gt;&lt;xsd:complexType name=&quot;tCopy&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;from&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;to&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;keepSrcElementName&quot; type=&quot;tBoolean&quot; use=&quot;optional&quot; default=&quot;no&quot;/&gt; &lt;xsd:attribute name=&quot;ignoreMissingFromData&quot; type=&quot;tBoolean&quot; use=&quot;optional&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; copy，基于tExtensibleElements扩展，两个元素比较好理解 from：从哪里copy to：copy到哪里 还有两个属性： keepSrcElementName：bool值，可选，默认no，是否保存源元素的属性名 ignoreMissingFromData：bool值，可选，默认no，是否忽略数据中的遗失部分 element：from12345678910111213141516171819&lt;xsd:element name=&quot;from&quot; type=&quot;tFrom&quot;/&gt;&lt;xsd:complexType name=&quot;tFrom&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;documentation&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:choice minOccurs=&quot;0&quot;&gt; &lt;xsd:element ref=&quot;literal&quot; minOccurs=&quot;1&quot;/&gt; &lt;xsd:element ref=&quot;query&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:choice&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;expressionLanguage&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot;/&gt; &lt;xsd:attribute name=&quot;part&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;property&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;endpointReference&quot; type=&quot;tRoles&quot;/&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; 然而这个from并不简单，我们先看看这个sequence里边装了什么 documentation：element，0至多个，前边定义过了，基本上就是一个mixed的啥都可以写的东西，属性里边指明source和language就可以了 any：0至多个来自其他命名空间的任意元素 literal/query：这俩二选一，具体是啥看后边定义 还有几个属性 expressionLanguage：表达语言 variable：BPELVariableName part：来自哪一部分 property：属性是什么 partnerLink endpointReference：通过tRoles定义 anyAttribute：还可以随便加其他属性 element：literal1234567&lt;xsd:element name=&quot;literal&quot; type=&quot;tLiteral&quot;/&gt;&lt;xsd:complexType name=&quot;tLiteral&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any namespace=&quot;##any&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt;&lt;/xsd:complexType&gt; literal就是一个mixed描述段落，里边可以有一个任意元素。 element：query123456789&lt;xsd:element name=&quot;query&quot; type=&quot;tQuery&quot;/&gt;&lt;xsd:complexType name=&quot;tQuery&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;queryLanguage&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; Query和literal相似，是一个mixed描述段落，里边可以有任意个任意元素。同时它还有属性 queryLanguage：表明查询语言 anyAttribute：看似随便加属性，实际上根据查询语言不通增加其他属性 simpleType：tRoles123456&lt;xsd:simpleType name=&quot;tRoles&quot;&gt; &lt;xsd:restriction base=&quot;xsd:string&quot;&gt; &lt;xsd:enumeration value=&quot;myRole&quot;/&gt; &lt;xsd:enumeration value=&quot;partnerRole&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; myRole和partnerRole两个值二选一 element：to123456789101112131415&lt;xsd:element name=&quot;to&quot; type=&quot;tTo&quot;/&gt;&lt;xsd:complexType name=&quot;tTo&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;documentation&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;query&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;expressionLanguage&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:attribute name=&quot;variable&quot; type=&quot;BPELVariableName&quot;/&gt; &lt;xsd:attribute name=&quot;part&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;property&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;partnerLink&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; 这个to也不简单，我们看看这个sequence里边装了什么 documentation：element，0至多个，前边定义过了，基本上就是一个mixed的啥都可以写的东西，属性里边指明source和language就可以了 any：0至多个来自其他命名空间的任意元素 query：查询到对应写入的部分 还有几个属性 expressionLanguage：表达语言 variable：BPELVariableName part：去哪一部分 property：属性是什么 partnerLink anyAttribute：还可以根据表达语言随便加其他属性 element：extensionAssignOperation1234567&lt;xsd:element name=&quot;extensionAssignOperation&quot; type=&quot;tExtensionAssignOperation&quot;/&gt;&lt;xsd:complexType name=&quot;tExtensionAssignOperation&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 这个东西是assign中的一个element，怪不得assign没有基于tExtensibleElements扩展，放在里边了。 element：compensate1234567&lt;xsd:element name=&quot;compensate&quot; type=&quot;tCompensate&quot;/&gt;&lt;xsd:complexType name=&quot;tCompensate&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 就是tActivity的一个元素化，可以看作是一个最原始，最纯粹的activity。 element：compensateScope123456789&lt;xsd:element name=&quot;compensateScope&quot; type=&quot;tCompensateScope&quot;/&gt;&lt;xsd:complexType name=&quot;tCompensateScope&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;&gt; &lt;xsd:attribute name=&quot;target&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 在compensate之上增加了一个属性： target：相当于给补偿增加了一个范围 element：empty1234567&lt;xsd:element name=&quot;empty&quot; type=&quot;tEmpty&quot;/&gt;&lt;xsd:complexType name=&quot;tEmpty&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivity&quot;/&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 就是tActivity的一个元素化，可以看作是一个最原始，最纯粹的activity。 和compensate是一样的，在语义上和用法上不一样。]]></content>
      <tags>
        <tag>bpel</tag>
        <tag>wsbpel</tag>
        <tag>ws-bpel</tag>
        <tag>bpel2.0</tag>
        <tag>schema</tag>
        <tag>xsd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WS-BPEL 2.0 xml schema 详解(一)]]></title>
    <url>%2F2019%2F03%2F21%2FWS-BPEL-2-0-xml-schema-%E8%AF%A6%E8%A7%A3(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[本系列文章将一行一行的解读wsbpel2.0的源码。 相关xsd语法问题，请参见XSD学习笔记完整版 wsbpel2.0 xsd源码来自：ws-bpel_executable.xsd schema声明1234&lt;xsd:schema xmlns=&quot;http://docs.oasis-open.org/wsbpel/2.0/process/executable&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://docs.oasis-open.org/wsbpel/2.0/process/executable&quot; elementFormDefault=&quot;qualified&quot; blockDefault=&quot;#all&quot;&gt; ...&lt;\xsd&gt; 声明命名空间http://docs.oasis-open.org/wsbpel/2.0/process/executable，没有前缀。 引入http://www.w3.org/2001/XMLSchema的语素并以xsd为前缀。 elementFormDefault=&quot;qualified&quot;表示所有元素都必须加上前缀以表明其命名空间。 blockDefault=&quot;#all&quot;表示默认情况下不能通过派生类代替原类型。 annotation12345&lt;xsd:annotation&gt; &lt;xsd:documentation&gt;Schema for Executable Process for WS-BPEL 2.0 OASIS Standard 11th April, 2007 &lt;/xsd:documentation&gt;&lt;/xsd:annotation&gt; 赠送了一个简单的文档说明。 import1&lt;xsd:import namespace=&quot;http://www.w3.org/XML/1998/namespace&quot; schemaLocation=&quot;http://www.w3.org/2001/xml.xsd&quot;/&gt; 引入http://www.w3.org/2001/xml.xsd的xml语素，前缀默认为xml。 element：process1234567&lt;xsd:element name=&quot;process&quot; type=&quot;tProcess&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This is the root element for a WS-BPEL 2.0 process. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt; BPEL的根元素，此处没有定义任何内容，内部元素属性通过type=”tProcess”引入。 complexType：tProcess1234567891011121314151617181920212223&lt;xsd:complexType name=&quot;tProcess&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;extensions&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;import&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;partnerLinks&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;messageExchanges&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;variables&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;correlationSets&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;faultHandlers&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:element ref=&quot;eventHandlers&quot; minOccurs=&quot;0&quot;/&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;targetNamespace&quot; type=&quot;xsd:anyURI&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;queryLanguage&quot; type=&quot;xsd:anyURI&quot; default=&quot;urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0&quot;/&gt; &lt;xsd:attribute name=&quot;expressionLanguage&quot; type=&quot;xsd:anyURI&quot; default=&quot;urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0&quot;/&gt; &lt;xsd:attribute name=&quot;suppressJoinFailure&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;xsd:attribute name=&quot;exitOnStandardFault&quot; type=&quot;tBoolean&quot; default=&quot;no&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 首先是一个名为tExtensibleElements的扩展，先放一下往后看。 一个sequence，包括extensions，import，partnerLinks，messageExchanges，variables，correlationSets，faultHandlers，eventHandlers，还有一个activity的group，这里全部是ref，我们知道大概有些啥就行了，后边肯定会有详细的定义，先往后看吧。 接着是一堆attribute，包括process的 名称name 目标命名空间targetNamespace 查询语言queryLanguage，默认是urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0 表达语言expressionLanguage，默认是：urn:oasis:names:tc:wsbpel:2.0:sublang:xpath1.0 抑制链接失败suppressJoinFailure，默认是否 标准错误退出exitOnStandardFault，默认是否 complexType：tExtensibleElement123456789101112&lt;xsd:complexType name=&quot;tExtensibleElements&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This type is extended by other component types to allow elements and attributes from other namespaces to be added at the modeled places. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;documentation&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:any namespace=&quot;##other&quot; processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:anyAttribute namespace=&quot;##other&quot; processContents=&quot;lax&quot;/&gt;&lt;/xsd:complexType&gt; tExtensibleElements这个扩展马上就来了，可以看到，扩展除了0至多个documentation（后边再讲），还有 element：来自该元素的父元素的目标命名空间之外的任何命名空间的元素，且即使不能获取该命名空间架构，也不会发生任何错误。 attribute：同上 element：documentation123456789&lt;xsd:element name=&quot;documentation&quot; type=&quot;tDocumentation&quot;/&gt;&lt;xsd:complexType name=&quot;tDocumentation&quot; mixed=&quot;true&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:any processContents=&quot;lax&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;source&quot; type=&quot;xsd:anyURI&quot;/&gt; &lt;xsd:attribute ref=&quot;xml:lang&quot;/&gt;&lt;/xsd:complexType&gt; documentation中： element：一个字符元素可混合出现的，元素可随意引入，不在此命名空间也没关系 attribute： source：通过URI表明来源 xml:lang: 文档语言，如en、CN等 group：activity123456789101112131415161718192021222324252627282930&lt;xsd:group name=&quot;activity&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;All standard WS-BPEL 2.0 activities in alphabetical order. Basic activities and structured activities. Addtional constraints: - rethrow activity can be used ONLY within a fault handler (i.e. &quot;catch&quot; and &quot;catchAll&quot; element) - compensate or compensateScope activity can be used ONLY within a fault handler, a compensation handler or a termination handler &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt; &lt;xsd:choice&gt; &lt;xsd:element ref=&quot;assign&quot;/&gt; &lt;xsd:element ref=&quot;compensate&quot;/&gt; &lt;xsd:element ref=&quot;compensateScope&quot;/&gt; &lt;xsd:element ref=&quot;empty&quot;/&gt; &lt;xsd:element ref=&quot;exit&quot;/&gt; &lt;xsd:element ref=&quot;extensionActivity&quot;/&gt; &lt;xsd:element ref=&quot;flow&quot;/&gt; &lt;xsd:element ref=&quot;forEach&quot;/&gt; &lt;xsd:element ref=&quot;if&quot;/&gt; &lt;xsd:element ref=&quot;invoke&quot;/&gt; &lt;xsd:element ref=&quot;pick&quot;/&gt; &lt;xsd:element ref=&quot;receive&quot;/&gt; &lt;xsd:element ref=&quot;repeatUntil&quot;/&gt; &lt;xsd:element ref=&quot;reply&quot;/&gt; &lt;xsd:element ref=&quot;rethrow&quot;/&gt; &lt;xsd:element ref=&quot;scope&quot;/&gt; &lt;xsd:element ref=&quot;sequence&quot;/&gt; &lt;xsd:element ref=&quot;throw&quot;/&gt; &lt;xsd:element ref=&quot;validate&quot;/&gt; &lt;xsd:element ref=&quot;wait&quot;/&gt; &lt;xsd:element ref=&quot;while&quot;/&gt; &lt;/xsd:choice&gt;&lt;/xsd:group&gt; 定义了一个activity的group，用于在其他地方引用，比如说通过tProcess引用到process里边。 一个activity可以是以下元素中的一个，没写到的看后边源码解读好了： 基本活动名称 释义 assign 活动的作用是用新的数据来更新变量的值。Assign活动可以包括任意数量的基本复制操作。 compensate 通过该活动做一些补偿动作，通常需要和scope联合使用。只能从故障处理程序或另一个补偿处理活动中调用这个活动。补偿处理程序只能被调用一次。 compensateScope empty 无所事事，比如在一个错误发生后可以不做反应来消除这个错误 exit 该活动用于立刻终止业务流程实例。所有当前运行的活动必须被立刻终止。不用引用任何终点处理、错误处理或者补偿行为。 forEach invoke 活动允许业务流程同步或异步调用由合作伙伴提供的服务，服务实现可以是单向或请求-响应操作。Invoke活动使用“partnerLink”来引用伙伴服务。同过“portType”和“operation”指定相应的WSDL接口和操作。 pick 活动会等待一组相互排斥事件中的一个事件的发生，然后执行与发生的事件相关联的活动。它会阻塞业务流程执行，以等待某一特定的事件发生，比如接收到一个合适的消息或超时警报响起。当其中任何一个事件被触发后，业务流程就会继续执行，pick也随即完成了，不会再等待其他事件的发生。 receive 活动从流程的外部伙伴那获取数据，并将其保存到流程变量。通常一个Receive是一个流程的初始点，它会阻塞执行直到匹配的消息的到达。 reply 活动发送消息给伙伴来应答通过receive活动所接收到的消息。receive和reply的组合对应着WSDL portType上定义的一个请求-响应操作。如果receive活动对应着一个单向(one-way)操作，则不能在流程中定义对应的reply活动。 rethrow throw 提示一个错误，一个故障处理可以处理这样的错误。假如一个错误不被处理的话它最终到达最高层后导致过程的终止 validate wait 活动会暂停流程执行，等待一段给定的时间或等到某一时刻才继续运行。在WebSphere Process Server 6.0中，开发者可以非常灵活地指定wait中的到期条件，比如等待多少秒，等到特定的一个日期，或是使用内置的日期表现法。也可以使用Java代码来动态指定等待时间。 结构化活动名称 释义 extensionActivity flow 可以描述更为复杂的活动执行顺序。我们可以利用flow指定一个或多个并行执行的活动。为了定义任意的控制结构，可以在并行的活动中使用链接。 if repeatUntil scope 使用这个结构可以将一组活动组织在一起作为一个处理单位。通过这个组织方法多个活动可以使用同一个故障处理、事故处理和补偿处理。通过补偿处理BPEL可以处理长时间的处理。 sequence 定义一组按顺序先后执行的活动。执行顺序是sequence活动中嵌套活动的先后顺序。当sequence中的最后一个活动完成后，该sequence活动也就完成了。 while 继承于传统的结构化编程思想，提供了while-do循环结构的支持。它可以包含一个或多个活动。它指定反复执行其内部活动，直到成功条件不被满足为止。在WPS中允许其使用Java代码来描述条件表达式。 element：extensions12345678910111213141516171819202122&lt;xsd:element name=&quot;extensions&quot; type=&quot;tExtensions&quot;/&gt;&lt;xsd:complexType name=&quot;tExtensions&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;extension&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;extension&quot; type=&quot;tExtension&quot;/&gt;&lt;xsd:complexType name=&quot;tExtension&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;namespace&quot; type=&quot;xsd:anyURI&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;mustUnderstand&quot; type=&quot;tBoolean&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 一个extensions由1到多个extension组成。 extension扩展自tExtensibleElements，增加了namespace和mustUnderstand两个属性。 element：import1234567891011&lt;xsd:element name=&quot;import&quot; type=&quot;tImport&quot;/&gt;&lt;xsd:complexType name=&quot;tImport&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;namespace&quot; type=&quot;xsd:anyURI&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;location&quot; type=&quot;xsd:anyURI&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;importType&quot; type=&quot;xsd:anyURI&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; BPEL允许import，import元素在tExtensibleElements的基础上，增加namespace、location、importType三个属性，和xsd的import类似。 element：partnerLinks12345678910111213141516171819202122232425&lt;xsd:element name=&quot;partnerLinks&quot; type=&quot;tPartnerLinks&quot;/&gt;&lt;xsd:complexType name=&quot;tPartnerLinks&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;partnerLink&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;partnerLink&quot; type=&quot;tPartnerLink&quot;/&gt;&lt;xsd:complexType name=&quot;tPartnerLink&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;partnerLinkType&quot; type=&quot;xsd:QName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;myRole&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;partnerRole&quot; type=&quot;xsd:NCName&quot;/&gt; &lt;xsd:attribute name=&quot;initializePartnerRole&quot; type=&quot;tBoolean&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 和extensions相似，partnerLinks由1到多个partnerLink组成，同时支持tExtensibleElements扩展。 partnerLink在tExtensibleElements的基础上，增加了以下5个属性 name partnerLinkType myRole partnerRole initializaPartnerRole element：messageExchanges123456789101112131415161718192021&lt;xsd:element name=&quot;messageExchanges&quot; type=&quot;tMessageExchanges&quot;/&gt;&lt;xsd:complexType name=&quot;tMessageExchanges&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;messageExchange&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;messageExchange&quot; type=&quot;tMessageExchange&quot;/&gt;&lt;xsd:complexType name=&quot;tMessageExchange&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 和extensions相似，messageExchanges由1到多个messageExchange组成，同时支持tExtensibleElements扩展。 messageExchange在tExtensibleElements的基础上，增加了一个属性 name element：variables123456789101112131415161718192021222324252627&lt;xsd:element name=&quot;variables&quot; type=&quot;tVariables&quot;/&gt;&lt;xsd:complexType name=&quot;tVariables&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;variable&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;variable&quot; type=&quot;tVariable&quot;/&gt;&lt;xsd:complexType name=&quot;tVariable&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;from&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;BPELVariableName&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;messageType&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;type&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;xsd:attribute name=&quot;element&quot; type=&quot;xsd:QName&quot; use=&quot;optional&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 和extensions相似，variables由1到多个variable组成，同时支持tExtensibleElements扩展。 variable在tExtensibleElements的基础上，增加了一个元素 from 增加了四个属性 name messageType type element simpleType：BPELVariableName12345&lt;xsd:simpleType name=&quot;BPELVariableName&quot;&gt; &lt;xsd:restriction base=&quot;xsd:NCName&quot;&gt; &lt;xsd:pattern value=&quot;[^\.]+&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; bpel变量的一个限制，BPELVariableName需要满足xsd:NCName限制，不能以.开头，且长度大于等于一个字符。 element：correlationSets12345678910111213141516171819202122&lt;xsd:element name=&quot;correlationSets&quot; type=&quot;tCorrelationSets&quot;/&gt;&lt;xsd:complexType name=&quot;tCorrelationSets&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;correlationSet&quot; minOccurs=&quot;1&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt;&lt;xsd:element name=&quot;correlationSet&quot; type=&quot;tCorrelationSet&quot;/&gt;&lt;xsd:complexType name=&quot;tCorrelationSet&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:attribute name=&quot;properties&quot; type=&quot;QNames&quot; use=&quot;required&quot;/&gt; &lt;xsd:attribute name=&quot;name&quot; type=&quot;xsd:NCName&quot; use=&quot;required&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 和extensions相似，correlationSets由1到多个correlationSet组成，同时支持tExtensibleElements扩展。 correlationSet在tExtensibleElements的基础上，增加了2个属性 properties name simpleType：QNames12345678&lt;xsd:simpleType name=&quot;QNames&quot;&gt; &lt;xsd:restriction&gt; &lt;xsd:simpleType&gt; &lt;xsd:list itemType=&quot;xsd:QName&quot;/&gt; &lt;/xsd:simpleType&gt; &lt;xsd:minLength value=&quot;1&quot;/&gt; &lt;/xsd:restriction&gt;&lt;/xsd:simpleType&gt; QNames就是一个QName的list，最少1个，默认空格分割。 element：faultHandlers123456789101112&lt;xsd:element name=&quot;faultHandlers&quot; type=&quot;tFaultHandlers&quot;/&gt;&lt;xsd:complexType name=&quot;tFaultHandlers&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:element ref=&quot;catch&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt; &lt;xsd:element ref=&quot;catchAll&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; faultHandlers，听名字就知道是干啥的了，同样支持tExtensibleElements扩展，由2种元素的sequence组成： catch catchAll element：catch123456789101112131415161718&lt;xsd:element name=&quot;catch&quot; type=&quot;tCatch&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This element can contain all activities including the activities compensate, compensateScope and rethrow. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt;&lt;xsd:complexType name=&quot;tCatch&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tActivityContainer&quot;&gt; &lt;xsd:attribute name=&quot;faultName&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;faultVariable&quot; type=&quot;BPELVariableName&quot;/&gt; &lt;xsd:attribute name=&quot;faultMessageType&quot; type=&quot;xsd:QName&quot;/&gt; &lt;xsd:attribute name=&quot;faultElement&quot; type=&quot;xsd:QName&quot;/&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; catch扩展自tActivityContainer，包含4个属性，对catch做了限定： faultName faultVariable faultMessageType faultElement element：catchAll1234567891011121314151617&lt;xsd:element name=&quot;catchAll&quot; type=&quot;tActivityContainer&quot;&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt;This element can contain all activities including the activities compensate, compensateScope and rethrow. &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:element&gt;&lt;xsd:complexType name=&quot;tActivityContainer&quot;&gt; &lt;xsd:complexContent&gt; &lt;xsd:extension base=&quot;tExtensibleElements&quot;&gt; &lt;xsd:sequence&gt; &lt;xsd:group ref=&quot;activity&quot; minOccurs=&quot;1&quot;/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:extension&gt; &lt;/xsd:complexContent&gt;&lt;/xsd:complexType&gt; 不同于catch，catchAll没有那么多属性（我全都要），就是tActivityContainer本尊，扩展自tExtensibleElements，同时包含一个activity的sequence。]]></content>
      <tags>
        <tag>bpel</tag>
        <tag>wsbpel</tag>
        <tag>ws-bpel</tag>
        <tag>bpel2.0</tag>
        <tag>schema</tag>
        <tag>xsd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[owl本体语言学习笔记]]></title>
    <url>%2F2019%2F03%2F18%2Fowl%E6%9C%AC%E4%BD%93%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[OWL简介OWL(Web Ontology Language)是W3C开发的一种网络本体语言，用于对本体进行语义描述。OWL是针对各方面的需求在DAML+OIL的基础上进行改进而开发的，它一方面保持了对DAML+oIL／RDFs的兼容性，另一方面又保证了更加强大的语义表达能力，同时还要保证描述逻辑(DL，Description Logic)的可判定推理。W3C的设计人员针对各类特征的需求制定了三种相应的OWL的子语言，即OWL Lite、OWL DL和OWL Full，三种子语言的表达能力递增。 OWL Lite是表达能力最弱的子语言。它是傩乙DL的一个子集，但是通过降低OWL DL中的公理约束，保证了迅速高效的推理。它支持基数约束，但基数值只能为O或l。因为0WL Lite表达能力较弱，为其开发支持工具要比其他两个子语言容易一些。OWL Lite用于提供给那些仅需要一个分类层次和简单约束的用户。 OWL DL(Description Logic，描述逻辑)将可判定推理能力和较强表达能力作为首要目标，而忽略了对RDFS的兼容性。0WL DL包括了OWL语言的所有语言成分，但使用时必须符合一定的约束，受到一定的限制。OWL DL提供了描述逻辑的推理功能，描述逻辑是OWL的形式化基础。 OWL Full包含OWL的全部语言成分并取消了OWL DL中的限制，它将RDFS扩展为一个完备的本体语言，支持那些不需要可计算性保证(no computational guarantees)但需要最强表达能力和完全自由的RDFS用户。在OWL Full中，一个类可以看成是个体的集合，也可以看成是一个个体。由于OWL Full取消了基数限制中对可传递性质的约束，因此不能保证可判定推理。 OWL本体的组成个体（individual）个体代表领域中我们感兴趣的对象，OWL不使用唯一命名假设，即两个不同的名称可以对应一个个体（例如：“伊丽莎白女王”和“伊丽莎白温莎”是指同一个人）。在OWL中，必须明确表示个体之间是否相同，否则它们的关系是不明确的。 个体（individual）有时也被称作实例（Instance）。 属性（Property）属性是个体之间的二元关系。在描述逻辑中，它们就是角色（Role）的概念。 按照属性的表意及性质可以分为以下四类属性： 函数属性(Functional Property)——通过这个属性只能连接一个个体，如hasBirthMother 反函数属性(Inverse Functional Property)——即这个属性的反属性是函数属性，也就是对于一个给定的个体，只有最多一个个体能通过该属性连接那个个体，如isBirthMotherOf 传递属性(Transitive Property)——这个属性是可以传递的，如你的祖先的祖先也是你的祖先，hasAncestor 对称属性(Symmetric Property)——即这个属性是对称的，一个属性是对称的那么它就不能是函数属性。如你是你的兄弟的兄弟，hasSibling 按照属性的链接对象不同可以分为以下三类： 对象属性(Object Property)——连接两个个体。 数据类型属性(Datatype Property)——连接个体和XML Schema数据类型值或rdf literal,该属性不能为传递的，对称的，反函数的。 标注属性 (Annotation Property)——用来对类，属性，个体和本体添加信息(元数据)。OWL-DL对标注属性作出了如下限制：(1)标注属性的filler只能为,literal或URI或个体。(2)标注属性没有子属性，也不能为其它属性的子属性，而且不能使用domain和range。 类（class）表示一些个体的集合，它使用数学的方法描述出该类中成员必须具有的条件。概念（concept）这个词有时被用来代替类，实际上，类是概念的一个具体表现。 OWL中本体的结构命名空间在使用一组术语之前，需要精确地指出哪些具体的词汇表将会用到。一个典型的OWL本体以命名空间声明开始，这些命名空间写到rdf:RDF\标签中。 属性值是不具有命名空间的，在OWL里可以写出它们的完整URI。完整的URI中可以利用实体定义来简略。如： 123&lt;!DOCTYPE rdf:RDF [ &lt;!ENTITY vin &quot;http://www.w3.org/TR/2004/REC-owl-guide-20040210/wine#&quot; &gt; &lt;!ENTITY food &quot;http://www.w3.org/TR/2004/REC-owl-guide-20040210/food#&quot; &gt; ]&gt; 在声明这些实体后，我们可以将“&vin;merlot”作为http://www.w3.org/TR/2004/REC -owl-guide-20040210/wine#merlot的简写。 本体头部在owl：Ontology标签中给出本体的声明。这些标签支持一些重要的常务工作比如注释、版本控制以及其他本体的嵌入等。 owl:Ontology元素是用来收集关于当前文档的OWL元数据的。 rdf:about属性为本体提供一个名称或引用。 rdfs:comment提供了显然必须的为本体添加注解的能力。 owl:priorVersion是一个为用于本体的版本控制系统提供相关信息（hook）的标准标签。本体的版本控制将在后面作进一步讨论。 owl:imports提供了一种嵌入机制。owl:imports接受一个用rdf:resource属性标识的参数。 数据集成与隐私不同的个体成员可能表示同一个体，owl：sameAs表达等价的能力。 基本元素简单的个体和类外延：我们称由属于某个类的个体所构成的集合为该类的外延（extension）。 本体：为了进行相关个体的推理。 简单的具名类一个领域中最基本的概念对应各个分类层次树的根。 。。。。国际化资源标识符（IRI）。。。。。统一资源标识符（URI）。。。。 rdf:ID=”Region” 被用于引入一个名称（作为定义的一部分）在这一文档中，我们现在可以用#Region来引用Region类，例如 rdf:resource=”#Region” rdfs:subClassOf是用于类的基本分类构造符，次关系是可传递的一个类的定义由两部分组成：引入或引用一个名称，以及一个限制表。 个体123456&lt;owl:Thing rdf:ID=&quot;CentralCoastRegion&quot; /&gt; &lt;owl:Thing rdf:about=&quot;#CentralCoastRegion&quot;&gt; &lt;rdf:type rdf:resource=&quot;#Region&quot;/&gt; /*表示个体，type是一个rdf属性，用于关联一个个体和它所属的类*/ &lt;/owl:Thing&gt; 或者使用&lt;Region rdf:ID=&quot;CentralCoastRegion&quot; /&gt; 语句来表示个体 Web本体被设计成为分布式的，我们可以通过导入和补充已有的本体来创建衍生的本体。 使用方面的考虑一个类仅是一个名称和一些描述某集合内个体的属性；而个体是该集合的成员。因此，类应自然地对应于与某论域中的事物的出现集合，而个体应对应于可被归入这些类的实际的实体。 子类：类的子集合 实例：表示一个单一的个体 一个本体的开发应坚定地由它的预定用途所驱动。这些问题也存在于OWL Full和OWL DL之间的一个重要区别。OWL Full允许将类（class）用作实例（instance），而OWL DL不允许。 简单属性一个属性是一个二元关系，有两种类型的属性： 数据类型属性（datatype properties）：类实例与RDF文字或XML Schema数据类型间的关系。 对象属性（object properties）：两个类的实例间的关系。 定义属性1234&lt;owl:ObjectProperty rdf:ID=&quot;madeFromGrape&quot;&gt; &lt;rdfs:domain rdf:resource=&quot;#Wine&quot;/&gt; /*表示定义域*/ &lt;rdfs:range rdf:resource=&quot;#WineGrape&quot;/&gt; /*表示值域*/&lt;/owl:ObjectProperty&gt; 在OWL中，一个值域可被用来推断一个类型 123&lt;owl:Thing rdf:ID=&quot;LindemansBin65Chardonnay&quot;&gt; &lt;madeFromGrape rdf:resource=&quot;#ChardonnayGrape&quot; /&gt;&lt;/owl:Thing&gt; 可以推断出，LindemansBin65Chardonnay为一种葡萄酒，因为其定义域为wine 可以定义子属性，属性是传递的，例如X为Y的子属性，如果具有属性X，则必然同时具有属性Y。 属性和数据类型数据类型属性：将个体关联到数据（值域为：RDF文字或XML Schema数据类型） 12345&lt;owl:Class rdf:ID=&quot;VintageYear&quot; /&gt;&lt;owl:DatatypeProperty rdf:ID=&quot;yearValue&quot;&gt;&lt;rdfs:domain rdf:resource=&quot;#VintageYear&quot; /&gt; &lt;rdfs:range rdf:resource=&quot;&amp;xsd;positiveInteger&quot;/&gt;&lt;/owl:DatatypeProperty&gt; yearValue属性将VintageYears与一个整数值相关联。 个体的属性12345678&lt;Region rdf:ID=&quot;SantaCruzMountainsRegion&quot;&gt; &lt;locatedIn rdf:resource=&quot;#CaliforniaRegion&quot; /&gt;&lt;/Region&gt;&lt;Winery rdf:ID=&quot;SantaCruzMountainVineyard&quot; /&gt;&lt;CabernetSauvignon rdf:ID=&quot;SantaCruzMountainVineyardCabernetSauvignon&quot; &gt; &lt;locatedIn rdf:resource=&quot;#SantaCruzMountainsRegion&quot;/&gt; &lt;hasMaker rdf:resource=&quot;#SantaCruzMountainVineyard&quot; /&gt; &lt;/CabernetSauvignon&gt; 属性的特性 传递属性： P(x，y)，P(y，z) P(x，z) 对称属性： p(x，y)当且仅当P(y, x)【注意是同一个关系】 函数属性： P(x,y) 与P(x,z) 蕴含 y = z，即对应值的唯一性 逆属性 （inverseOf）：P1(x,y) 当且仅当P2(y,x)【注意是不同关系】 反函数属性 （InverseFunctional）：P(y,x) 与 P(z,x) 蕴含 y = z； InverseFunctional意味着属性的值域中的元素为定义域中的每个元素提供了一个唯一的标识。 属性限制两个属性限制机制 allValuesFrom someValuesFrom 它们都是是局部的（local），仅仅在包含它们的类的定义中起作用。 owl:allValuesFrom属性限制要求：对于每一个有指定属性实例的类实例，该属性的值必须是由owl:allValuesFrom从句指定的类的成员。 owl:someValuesFrom限制与之相似。 例子：Wine的制造商必须是Winery。allValuesFrom限制仅仅应用在Wine的hasMaker 属性上。Cheese的制造商并不受这一局部限制的约束。（代码如下） 关系 含意 allValuesFrom 对于所有的葡萄酒，如果它们有制造商，那么所有的制造商都是酿酒厂 someValuesFrom 对于所有的葡萄酒，它们中至少有一个的制造商是酿酒厂 基数限制owl:cardinality：这一约束允许对一个关系中的元素数目作出精确的限制。 例如，我们可以将Vintage标识为恰好含有一个VintageYear的类。 值域限制在0和1的基数表达式(Cardinality expressions)是OWL Lite的一部分。这使得用户能够表示“至少一个”，“不超过一个”，和“恰好一个”这几种意思。OWL DL中还允许使用除0与1以外的正整数值。owl:maxCardinality能够用来指定一个上界。owl:minCardinality能够用来指定一个下界。使用二者的组合就能够将一个属性的基数限制为一个数值区间。 hasValuehasValue 使得我们能够根据“特定的”属性值的存在来标识类。因此，一个个体只要至少有“一个”属性值等于hasValue的资源，这一个体就是该类的成员。 如果是Burgundy酒，那就都是干(dry)的酒。也即，它们的hasSugar属性必须至少有一个是值等于Dry（干的）。【我的理解是，每个Burgundy都要有一个干的（Dry）属性，以此来标识该酒是干酒】 本体映射用于实现本体的共享。 类和属性之间的等价关系（equivalentClass，equivalentProperty）属性owl:equivalentClass被用来表示两个类有着完全相同的实例。但我们要注意，在OWL DL中，类仅仅代表着个体的集合而不是个体本身。然而在OWL FULL中，我们能够使用owl:sameAs来表示两个类在各方面均完全一致。 类似的，我们可以通过使用owl:equivalentProperty属性声明表达属性的等同。 个体间的同一性SameAs：描述个体之间相同的机制与描述类之间的相同机制类似，仅仅只要两个个体的声明形成一致的就可以了。 假如hasMaker是一个函数型属性，那么下面的例子就不一定会产生冲突。 1234&lt;owl:Thing rdf:about=&quot;#BancroftChardonnay&quot;&gt; &lt;hasMaker rdf:resource=&quot;#Bancroft&quot; /&gt; &lt;hasMaker rdf:resource=&quot;#Beringer&quot; /&gt;&lt;/owl:Thing&gt; 除非和我们本体中的其他信息发生冲突，不然的话这样的描述是没有冲突的，他说明Bancroft和Beringer是相同的个体。 要清楚，修饰（或引用）两个类用sameAs还是用equivalentClass效果是不同的。用sameAs的时候，把一个类解释为一个个体，就像在OWL Full中一样，这有利于对本体进行分类。在OWL Full中，sameAs可以用来引用两个东西，如一个类和一个个体、一个类和一个属性等等，无论什么情况，都将被解释为个体。 不同的个体这一机制提供了与sameAs相反的效果。 说明了三个值互不相同。如果我们没有用 differentFrom元素来申明既干又甜的葡萄酒，这意味着“干葡萄酒”和“甜葡萄酒”是相同的。但是我们从上面申明的元素来推断，这又是矛盾的。还有一种更便利的定义相互不同个体的机制，如下 要注意，owl:distinctMembers属性声明只能和owl:AllDifferent属性声明一起结合使用。 复杂类用于创建类的表达式。OWL支持基本的集合操作，即并，交和补运算。它们分别被命名为owl:unionOf,owl:intersectionOf,和owl:complementOf.此外，类还可以是枚举的。类的外延可以使用oneOf构造子来显示的声明。同时，我们也可以声明类的外延必须是互不相交的。 注意：OWL类外延是由个体组成的集合，二这些个体都是类的成员。 集合运算符交运算123456789&lt;owl:Class rdf:ID=&quot;WhiteWine&quot;&gt; &lt;owl:intersectionOf rdf:parseType=&quot;Collection&quot;&gt; /*这是必须的，因为必须对集合操作*/ &lt;owl:Class rdf:about=&quot;#Wine&quot; /&gt; &lt;owl:Restriction&gt; &lt;owl:onProperty rdf:resource=&quot;#hasColor&quot; /&gt; &lt;owl:hasValue rdf:resource=&quot;#White&quot; /&gt; &lt;/owl:Restriction&gt; &lt;/owl:intersectionOf&gt;&lt;/owl:Class&gt; 这个例子表示，白葡萄酒就是葡萄酒和白色物体的相交的集合。如果不这么表示，计算机只知道，白葡萄酒有白色的属性；却不知道，所有白色的葡萄酒是白葡萄酒 WhiteBurgundy类恰好是白葡萄酒和Burgundies的交集。依次，Burgundies生产在法国一个叫做Bourgogne的地方并且它是干葡萄酒（dry wine）。因此，所有满足这些标准的葡萄酒个体都是WhiteBurgundy类的外延的一部分。 并运算表示两个集合的∪。使用方法同上，将intersectionOf改成unionOf。 补运算就是表示差集，complementOf典型的用法是与其它集合运算符联合使用，如下 上面的例子定义了一个NonFrenchWine类，它是Wine类与所有不位于法国的事物的集合的交集。 枚举类（one of）以直接枚举的方式描述类的成员。特别的，这个定义完整的描述了类的外延（类的范围？），因此任何其他个体都不能声明为属于这个类。如下： 这段代码说明，WineColor只包含三种，white rose和red，任何其他的颜色都不是winecolor类的实例 oneOf结构的每一个元素都必须是一个有效声明的个体。一个个体必须属于某个类。在上面的例子中，每一个个体都是通过名字来引用的。我们使用owl:Thing简单地进行引用，尽管这有点多余（因为每个个体都属于owl:Thing）。另外，我们也可以根据具体类型WineColor来引用集合中的元素： 另外，较复杂的个体描述同样也可以是oneOf结构的有效元素，例如: 不相交类（disjointWith）使用owl:disjointWith构造子可以表达一组类是不相交的。它保证了属于某一个类的个体不能同时又是另一个指定类的实例。 Pasta例子声明了多个不相交类。注意它只声明了Pasta与其它所有类是不相交的。例如，它并没有保证Meat和Fruit是不相交的。为了声明一组类是互不相交的，我们必须对每两个类都使用owl:disjointWith来声明。 在下面的例子中，我们定义了Fruit是SweetFruit和NonSweetFruit的并集。而且我们知道这些子类恰好将Fruit划分成了连个截然不同的子类，因为它们是互不相交的。随着互不相交的类的增加，不相交的声明的数目也会相应的增加到n的2次方。然而，在我们已知的用例中，n通常比较小。 本体版本控制本体和软件一样需要维护，因此它们将随着时间的推移而改变。在一个owl:Ontology元素（如上面讨论的http://www.w3.org/TR/2004/REC-owl-guide-20040210/#OntologyHeaders） 内，链接到一个以前定义的本体版本是可能的。属性owl:priorVersion被用来提供这种链接，并能用它跟踪一个本体的版本历史。 本体版本可能彼此互不兼容，例如，一个本体以前的版本可能包含与现在版本中的陈述相矛盾的陈述。在一个owl:Ontology元素中，我们使用owl:backwardCompatibleWith和owl:incompatibleWith这些属性来指出本体版本是兼容还是不兼容以前的版本。如果没有进行owl:backwardCompatibleWith声明，那么我们假定就不存在兼容性。除了上面讲到的两个属性，还有一个属性owl:versionInfo适用与版本控制系统，它提供了一些相关信息（hook）。和前面三个属性相反的是，owl:versionInfo的客体是一个文字值（literal），这一属性除了可以用来注释本体之外还可以用来注释类和属性。 Reference OWL本体语言中OWL Lite、OWL DL、OWL Full理解 owl本体语言学习笔记（一） owl本体语言学习笔记（二）]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>owl</tag>
        <tag>本体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSD/XML Schema 学习笔记完整版]]></title>
    <url>%2F2019%2F03%2F15%2FXSD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AE%8C%E6%95%B4%E7%89%88%2F</url>
    <content type="text"><![CDATA[注：本文摘自W3school Schema 教程 schema声明属性大全 属性 说明 取值 id 标识该元素的唯一ID attributeFormDefault 指定XML文档使用schema中定义的局部属性时是否必须使用命名空间限定 qualified:必须通过命名空间前缀限定、unqualified：（默认值）无须通过命名空间前缀限定 elementFormDefault 指定XML文档使用schema中定义的局部元素时是否必须使用命名空间限定 取值和含义同attributeFormDefault blockDefault 设定schema中element和complexType上的block属性的默认值、block属性用来阻止以指定的派生类型代替原类型 #all或者extension、restriction和substitution的自由组合、例如extension表示防止通过扩展派生的复杂类型替代该复杂类型 finalDefault 设定schema中element、simpleType和complexType上的final的默认值、final属性用来阻止以指定的派生类型来派生新类型 对于element和complexType：值可以是#all或extension和restriction的自由组合、对于simpleType：值可以是#all或restriction、list和union的自由组合 targetNamespace 设定schema的命名空间的URI引用 version 设定schema的版本 xmlns 设定schema使用的一个或多个命名空间的URI引用 any attributes 设定带有non-schema命名空间的任何其他属性 &lt;schema> 声明&lt;schema> 元素是每一个 XML Schema 的根元素：&lt;?xml version=”1.0”?> 123456&lt;xs:schema&gt;......&lt;/xs:schema&gt; &lt;schema> 元素可包含属性。一个 schema 声明往往看上去类似这样： 12345678910&lt;?xml version=&quot;1.0&quot;?&gt; &lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;targetNamespace=&quot;http://www.w3school.com.cn&quot;xmlns=&quot;http://www.w3school.com.cn&quot;elementFormDefault=&quot;qualified&quot;&gt;......&lt;/xs:schema&gt; 代码解释1xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot; 显示 schema 中用到的元素和数据类型来自命名空间 http://www.w3.org/2001/XMLSchema。 同时它还规定了来自命名空间 http://www.w3.org/2001/XMLSchema的元素和数据类型应该使用前缀 xs。 1targetNamespace=&quot;http://www.w3school.com.cn&quot; 显示被此 schema 定义的元素 (note, to, from, heading, body) 来自命名空间： http://www.w3school.com.cn。 1xmlns=&quot;http://www.w3school.com.cn&quot; 指出默认的命名空间是 http://www.w3school.com.cn。 1elementFormDefault=&quot;qualified&quot; 指出任何 XML 实例文档所使用的且在此 schema 中声明过的元素必须被命名空间限定。 在 XSD 文档中引用 其他Schema引用方式有两种： include import import与include的作用是一样的。 区别在于import是导入另外一个命名空间的xsd， 而inlude是包含同一个命名空间的xsd。 例子1&lt;xsd:include schemaLocation=&quot;module/owl1-lite-core.xsd&quot; /&gt; 12345678910&lt;xsd:import namespace=&quot;http://www.w3.org/XML/1998/namespace&quot; schemaLocation=&quot;xml.xsd&quot;&gt; &lt;!-- &quot;http://www.w3.org/2001/xml.xsd&quot; --&gt; &lt;xsd:annotation&gt; &lt;xsd:documentation&gt; Get access to the xml: attribute groups for xml:lang as declared on &apos;Label&apos; and &apos;Documentation&apos; below &lt;/xsd:documentation&gt; &lt;/xsd:annotation&gt;&lt;/xsd:import&gt; 在 XML 文档中引用 Schema此 XML 文档含有对 XML Schema 的引用： 1234567891011&lt;?xml version=&quot;1.0&quot;?&gt;&lt;note xmlns=&quot;http://www.w3school.com.cn&quot;xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;xsi:schemaLocation=&quot;http://www.w3school.com.cn note.xsd&quot;&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 代码解释1xmlns=&quot;http://www.w3school.com.cn&quot; 规定了默认命名空间的声明。此声明会告知 schema 验证器，在此 XML 文档中使用的所有元素都被声明于 http://www.w3school.com.cn 这个命名空间。 一旦您拥有了可用的 XML Schema 实例命名空间： 1xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 您就可以使用 schemaLocation 属性了。此属性有两个值。第一个值是需要使用的命名空间。第二个值是供命名空间使用的 XML schema 的位置： 1xsi:schemaLocation=&quot;http://www.w3school.com.cn note.xsd&quot; 简单类型元素1&lt;xs:element name=&quot;xxx&quot; type=&quot;yyy&quot;/&gt; 常用类型： xs:string xs:decimal xs:integer xs:boolean xs:date xs:time 默认值和固定值缺省值（默认值）设置： 1&lt;xs:element name=&quot;color&quot; type=&quot;xs:string&quot; default=&quot;red&quot;/&gt; 固定值设置： 1&lt;xs:element name=&quot;color&quot; type=&quot;xs:string&quot; fixed=&quot;red&quot;/&gt; 例子这是一些 XML 元素： 123&lt;lastname&gt;Smith&lt;/lastname&gt;&lt;age&gt;28&lt;/age&gt;&lt;dateborn&gt;1980-03-27&lt;/dateborn&gt; 这是相应的简易元素定义： 123&lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt;&lt;xs:element name=&quot;age&quot; type=&quot;xs:integer&quot;/&gt;&lt;xs:element name=&quot;dateborn&quot; type=&quot;xs:date&quot;/&gt; 列表语法123456789&lt;listid=ID itemType=QName any attributes&gt;(annotation?,(simpleType?))&lt;/list&gt; 属性 描述 id 可选。规定该元素的唯一的 ID。 itemType 在该 schema（或由指定的命名空间指示的其他 schema）中定义的内置数据类型或 simpleType 元素的名称。包含 list 元素的 simpleType 元素是从 list 值指定的简单类型派生的。list 值必须是限定名 (QName)。 如果内容包含 simpleType 元素，则不允许使用该属性，否则该属性是必需的。 any attributes 可选。规定带有 non-schema 命名空间的任何其他属性。 例子下面的例子展示了为一列整数的简单类型： 12345678910&lt;?xml version=&quot;1.0&quot;?&gt;&lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&gt;&lt;xs:element name=&quot;intvalues&quot; type=&quot;valuelist&quot;&gt;&lt;xs:simpleType name=&quot;valuelist&quot;&gt; &lt;xs:list itemType=&quot;xs:integer&quot;/&gt;&lt;/xs:simpleType&gt;&lt;/xs:schema&gt; 文档中的 “intvalues” 元素类似这样（注意这个列表有五个列表项）： 1&lt;intvalues&gt;100 34 56 -23 1567&lt;/intvalues&gt; 注释：空格被作为列表项的分隔符 属性1&lt;xs:attribute name=&quot;xxx&quot; type=&quot;yyy&quot;/&gt; 常用类型： xs:string xs:decimal xs:integer xs:boolean xs:date xs:time 例子这是带有属性的 XML 元素： 1&lt;lastname lang=&quot;EN&quot;&gt;Smith&lt;/lastname&gt; 这是对应的属性定义： 1&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot;/&gt; 默认值和固定值缺省值（默认值）设置： 1&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot; default=&quot;EN&quot;/&gt; 固定值设置： 1&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot; fixed=&quot;EN&quot;/&gt; 可选和必选在缺省的情况下，属性是可选的。如需规定属性为必选，请使用 “use” 属性： 1&lt;xs:attribute name=&quot;lang&quot; type=&quot;xs:string&quot; use=&quot;required&quot;/&gt; 限定/Facets对值的限定下面的例子定义了带有一个限定且名为 “age” 的元素。age 的值不能低于 0 或者高于 120： 12345678910&lt;xs:element name=&quot;age&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:integer&quot;&gt; &lt;xs:minInclusive value=&quot;0&quot;/&gt; &lt;xs:maxInclusive value=&quot;120&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对一组值的限定如需把 XML 元素的内容限制为一组可接受的值，我们要使用枚举约束（enumeration constraint）。 下面的例子定义了带有一个限定的名为 “car” 的元素。可接受的值只有：Audi, Golf, BMW： 1234567891011&lt;xs:element name=&quot;car&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:enumeration value=&quot;Audi&quot;/&gt; &lt;xs:enumeration value=&quot;Golf&quot;/&gt; &lt;xs:enumeration value=&quot;BMW&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 上面的例子也可以被写为： 123456789&lt;xs:element name=&quot;car&quot; type=&quot;carType&quot;/&gt;&lt;xs:simpleType name=&quot;carType&quot;&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:enumeration value=&quot;Audi&quot;/&gt; &lt;xs:enumeration value=&quot;Golf&quot;/&gt; &lt;xs:enumeration value=&quot;BMW&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt; 注释：在这种情况下，类型 “carType” 可被其他元素使用，因为它不是 “car” 元素的组成部分。 对一系列值的限定如需把 XML 元素的内容限制定义为一系列可使用的数字或字母，我们要使用模式约束（pattern constraint）。 下一个例子也定义了带有一个限定的名为 “initials” 的元素。可接受的值是大写或小写字母 a - z 其中的三个： 123456789&lt;xs:element name=&quot;initials&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:pattern value=&quot;[a-zA-Z][a-zA-Z][a-zA-Z]&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下一个例子定义了带有一个限定的名为 “choice 的元素。可接受的值是字母 x, y 或 z 中的一个： 123456789&lt;xs:element name=&quot;choice&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:pattern value=&quot;[xyz]&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对一系列值的其他限定下面的例子定义了带有一个限定的名为 “letter” 的元素。可接受的值是 a - z 中零个或多个字母： 123456789&lt;xs:element name=&quot;letter&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:pattern value=&quot;([a-z])*&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下面的例子定义了带有一个限定的名为 “letter” 的元素。可接受的值是一对或多对字母，每对字母由一个小写字母后跟一个大写字母组成。举个例子，”sToP”将会通过这种模式的验证，但是 “Stop”、”STOP” 或者 “stop” 无法通过验证： 123456789&lt;xs:element name=&quot;letter&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:pattern value=&quot;([a-z][A-Z])+&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下面的例子定义了带有一个限定的名为 “gender” 的元素。可接受的值是 male 或者 female： 123456789&lt;xs:element name=&quot;gender&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:pattern value=&quot;male|female&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下面的例子定义了带有一个限定的名为 “password” 的元素。可接受的值是由 8 个字符组成的一行字符，这些字符必须是大写或小写字母 a - z 亦或数字 0 - 9： 123456789&lt;xs:element name=&quot;password&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:pattern value=&quot;[a-zA-Z0-9]&#123;8&#125;&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对空白字符的限定如需规定对空白字符（whitespace characters）的处理方式，我们需要使用 whiteSpace 限定。 下面的例子定义了带有一个限定的名为 “address” 的元素。这个 whiteSpace 限定被设置为 “preserve”，这意味着 XML 处理器不会移除任何空白字符： 123456789&lt;xs:element name=&quot;address&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:whiteSpace value=&quot;preserve&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 这个例子也定义了带有一个限定的名为 “address” 的元素。这个 whiteSpace 限定被设置为 “replace”，这意味着 XML 处理器将移除所有空白字符（换行、回车、空格以及制表符）： 123456789&lt;xs:element name=&quot;address&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:whiteSpace value=&quot;replace&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 这个例子也定义了带有一个限定的名为 “address” 的元素。这个 whiteSpace 限定被设置为 “collapse”，这意味着 XML 处理器将移除所有空白字符（换行、回车、空格以及制表符会被替换为空格，开头和结尾的空格会被移除，而多个连续的空格会被缩减为一个单一的空格）： 123456789&lt;xs:element name=&quot;address&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:whiteSpace value=&quot;collapse&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对长度的限定如需限制元素中值的长度，我们需要使用 length、maxLength 以及 minLength 限定。 本例定义了带有一个限定且名为 “password” 的元素。其值必须精确到 8 个字符： 123456789&lt;xs:element name=&quot;password&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:length value=&quot;8&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 这个例子也定义了带有一个限定的名为 “password” 的元素。其值最小为 5 个字符，最大为 8 个字符： 12345678910&lt;xs:element name=&quot;password&quot;&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base=&quot;xs:string&quot;&gt; &lt;xs:minLength value=&quot;5&quot;/&gt; &lt;xs:maxLength value=&quot;8&quot;/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 数据类型的限定 限定 描述 enumeration 定义可接受值的一个列表 fractionDigits 定义所允许的最大的小数位数。必须大于等于0。 length 定义所允许的字符或者列表项目的精确数目。必须大于或等于0。 maxExclusive 定义数值的上限。所允许的值必须小于此值。 maxInclusive 定义数值的上限。所允许的值必须小于或等于此值。 maxLength 定义所允许的字符或者列表项目的最大数目。必须大于或等于0。 minExclusive 定义数值的下限。所允许的值必需大于此值。 minInclusive 定义数值的下限。所允许的值必需大于或等于此值。 minLength 定义所允许的字符或者列表项目的最小数目。必须大于或等于0。 pattern 定义可接受的字符的精确序列。 totalDigits 定义所允许的阿拉伯数字的精确位数。必须大于0。 whiteSpace 定义空白字符（换行、回车、空格以及制表符）的处理方式。 复杂类型元素四种类型的复合元素： 空元素 包含其他元素的元素 仅包含文本的元素 包含元素和文本的元素 注释：上述元素均可包含属性！ 例子1234&lt;employee&gt;&lt;firstname&gt;John&lt;/firstname&gt;&lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/employee&gt; 的XML Schema可以写成： 12345678&lt;xs:element name=&quot;employee&quot;&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 或者： 12345678&lt;xs:element name=&quot;employee&quot; type=&quot;personinfo&quot;/&gt;&lt;xs:complexType name=&quot;personinfo&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt;&lt;/xs:complexType&gt; 也可以在已有的复合元素之上以某个复合元素为基础，然后添加一些元素，就像这样： 1234567891011121314151617181920&lt;xs:element name=&quot;employee&quot; type=&quot;fullpersoninfo&quot;/&gt;&lt;xs:complexType name=&quot;personinfo&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt;&lt;/xs:complexType&gt;&lt;xs:complexType name=&quot;fullpersoninfo&quot;&gt; &lt;xs:complexContent&gt; &lt;xs:extension base=&quot;personinfo&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;address&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;city&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;country&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt;&lt;/xs:complexType&gt; 空元素一个空的 XML 元素： 1&lt;product prodid=&quot;1345&quot; /&gt; 上面的 “product” 元素根本没有内容。为了定义无内容的类型，我们就必须声明一个在其内容中只能包含元素的类型，但是实际上我们并不会声明任何元素，比如这样： 123456789&lt;xs:element name=&quot;product&quot;&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:restriction base=&quot;xs:integer&quot;&gt; &lt;xs:attribute name=&quot;prodid&quot; type=&quot;xs:positiveInteger&quot;/&gt; &lt;/xs:restriction&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 或者： 12345&lt;xs:element name=&quot;product&quot;&gt; &lt;xs:complexType&gt; &lt;xs:attribute name=&quot;prodid&quot; type=&quot;xs:positiveInteger&quot;/&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; or： 12345&lt;xs:element name=&quot;product&quot; type=&quot;prodtype&quot;/&gt;&lt;xs:complexType name=&quot;prodtype&quot;&gt; &lt;xs:attribute name=&quot;prodid&quot; type=&quot;xs:positiveInteger&quot;/&gt;&lt;/xs:complexType&gt; 仅含元素XML 元素，”person”，仅包含其他的元素： 1234&lt;person&gt;&lt;firstname&gt;John&lt;/firstname&gt;&lt;lastname&gt;Smith&lt;/lastname&gt;&lt;/person&gt; 可在 schema 中这样定义 “person” 元素： 12345678&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 或者： 12345678&lt;xs:element name=&quot;person&quot; type=&quot;persontype&quot;/&gt;&lt;xs:complexType name=&quot;persontype&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt;&lt;/xs:complexType&gt; 仅含文本此类型仅包含简易的内容（文本和属性），因此我们要向此内容添加 simpleContent 元素。当使用简易内容时，我们就必须在 simpleContent 元素内定义扩展或限定，就像这样： 12345678910&lt;xs:element name=&quot;某个名称&quot;&gt; &lt;xs:complexType&gt; &lt;xs:simpleContent&gt; &lt;xs:extension base=&quot;basetype&quot;&gt; .... .... &lt;/xs:extension&gt; &lt;/xs:simpleContent&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 或者： 12345678910&lt;xs:element name=&quot;某个名称&quot;&gt; &lt;xs:complexType&gt; &lt;xs:simpleContent&gt; &lt;xs:restriction base=&quot;basetype&quot;&gt; .... .... &lt;/xs:restriction&gt; &lt;/xs:simpleContent&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 例子1&lt;shoesize country=&quot;france&quot;&gt;35&lt;/shoesize&gt; 下面这个例子声明了一个复合类型，其内容被定义为整数值，并且 “shoesize” 元素含有名为 “country” 的属性： 123456789&lt;xs:element name=&quot;shoesize&quot;&gt; &lt;xs:complexType&gt; &lt;xs:simpleContent&gt; &lt;xs:extension base=&quot;xs:integer&quot;&gt; &lt;xs:attribute name=&quot;country&quot; type=&quot;xs:string&quot; /&gt; &lt;/xs:extension&gt; &lt;/xs:simpleContent&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 我们也可为 complexType 元素设定一个名称，并让 “shoesize” 元素的 type 属性来引用此名称（通过使用此方法，若干元素均可引用相同的复合类型）： 123456789&lt;xs:element name=&quot;shoesize&quot; type=&quot;shoetype&quot;/&gt;&lt;xs:complexType name=&quot;shoetype&quot;&gt; &lt;xs:simpleContent&gt; &lt;xs:extension base=&quot;xs:integer&quot;&gt; &lt;xs:attribute name=&quot;country&quot; type=&quot;xs:string&quot; /&gt; &lt;/xs:extension&gt; &lt;/xs:simpleContent&gt;&lt;/xs:complexType&gt; 混合内容带有混合内容的复合类型XML 元素，”letter”，含有文本以及其他元素： 12345&lt;letter&gt;Dear Mr.&lt;name&gt;John Smith&lt;/name&gt;.Your order &lt;orderid&gt;1032&lt;/orderid&gt;will be shipped on &lt;shipdate&gt;2001-07-13&lt;/shipdate&gt;.&lt;/letter&gt; 下面这个 schema 声明了这个 “letter” 元素： 123456789&lt;xs:element name=&quot;letter&quot;&gt; &lt;xs:complexType mixed=&quot;true&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;orderid&quot; type=&quot;xs:positiveInteger&quot;/&gt; &lt;xs:element name=&quot;shipdate&quot; type=&quot;xs:date&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 注释：为了使字符数据可以出现在 “letter” 的子元素之间，mixed 属性必须被设置为 “true”。xs:sequence\ 标签 (name、orderid 以及 shipdate ) 意味着被定义的元素必须依次出现在 “letter” 元素内部。 或者： 123456789&lt;xs:element name=&quot;letter&quot; type=&quot;lettertype&quot;/&gt;&lt;xs:complexType name=&quot;lettertype&quot; mixed=&quot;true&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;orderid&quot; type=&quot;xs:positiveInteger&quot;/&gt; &lt;xs:element name=&quot;shipdate&quot; type=&quot;xs:date&quot;/&gt; &lt;/xs:sequence&gt;&lt;/xs:complexType&gt; 指示器七种指示器： Order 指示器： All Choice Sequence Occurrence 指示器： maxOccurs minOccurs Group 指示器： Group name attributeGroup name ALL&lt;all> 指示器规定子元素可以按照任意顺序出现，且每个子元素必须只出现一次. 当使用 &lt;all> 指示器时，你可以把 &lt;minOccurs> 设置为 0 或者 1，而只能把 &lt;maxOccurs> 指示器设置为 1 12345678&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:all&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:all&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; Choice&lt;choice> 指示器规定可出现某个子元素或者可出现另外一个子元素（非此即彼）,如需设置子元素出现任意次数，可将 &lt;maxOccurs> 设置为 unbounded（无限次）： 12345678&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:choice&gt; &lt;xs:element name=&quot;employee&quot; type=&quot;employee&quot;/&gt; &lt;xs:element name=&quot;member&quot; type=&quot;member&quot;/&gt; &lt;/xs:choice&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; Sequence&lt;sequence> 规定子元素必须按照特定的顺序出现： 12345678&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; maxOccursOccurrence 指示器用于定义某个元素出现的频率。对于所有的 “Order” 和 “Group” 指示器（any、all、choice、sequence、group name 以及 group reference），其中的 maxOccurs 以及 minOccurs 的默认值均为 1。 &lt;maxOccurs>指示器可规定某个元素可出现的最大次数,如需使某个元素的出现次数不受限制，可以使用 maxOccurs=”unbounded” 这个声明： 12345678&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;full_name&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;child_name&quot; type=&quot;xs:string&quot; maxOccurs=&quot;10&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; minOccurs&lt;minOccurs>指示器可规定某个元素能够出现的最小次数： 123456789&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;full_name&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;child_name&quot; type=&quot;xs:string&quot; maxOccurs=&quot;10&quot; minOccurs=&quot;0&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; Group name元素组通过 group 声明进行定义： 123&lt;xs:group name=&quot;组名称&quot;&gt; ...&lt;/xs:group&gt; 您必须在 group 声明内部定义一个 all、choice 或者 sequence 元素。下面这个例子定义了名为 “persongroup” 的 group，它定义了必须按照精确的顺序出现的一组元素： 1234567&lt;xs:group name=&quot;persongroup&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;birthday&quot; type=&quot;xs:date&quot;/&gt; &lt;/xs:sequence&gt;&lt;/xs:group&gt; 在您把 group 定义完毕以后，就可以在另一个定义中引用它了： 12345678910111213141516&lt;xs:group name=&quot;persongroup&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;birthday&quot; type=&quot;xs:date&quot;/&gt; &lt;/xs:sequence&gt;&lt;/xs:group&gt;&lt;xs:element name=&quot;person&quot; type=&quot;personinfo&quot;/&gt;&lt;xs:complexType name=&quot;personinfo&quot;&gt; &lt;xs:sequence&gt; &lt;xs:group ref=&quot;persongroup&quot;/&gt; &lt;xs:element name=&quot;country&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt;&lt;/xs:complexType&gt; attributeGroup name属性组通过 attributeGroup 声明来进行定义： 123&lt;xs:attributeGroup name=&quot;组名称&quot;&gt; ...&lt;/xs:attributeGroup&gt; 下面这个例子定义了名为 “personattrgroup” 的一个属性组： 12345&lt;xs:attributeGroup name=&quot;personattrgroup&quot;&gt; &lt;xs:attribute name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:attribute name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:attribute name=&quot;birthday&quot; type=&quot;xs:date&quot;/&gt;&lt;/xs:attributeGroup&gt; 在您已定义完毕属性组之后，就可以在另一个定义中引用它了，就像这样： 1234567891011&lt;xs:attributeGroup name=&quot;personattrgroup&quot;&gt; &lt;xs:attribute name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:attribute name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:attribute name=&quot;birthday&quot; type=&quot;xs:date&quot;/&gt;&lt;/xs:attributeGroup&gt;&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:attributeGroup ref=&quot;personattrgroup&quot;/&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; &lt;any>&lt;any> 元素使我们有能力通过未被 schema 规定的元素来拓展 XML 文档！下面这个例子是从名为 “family.xsd” 的 XML schema 中引用的片段。它展示了一个针对 “person” 元素的声明。通过使用 &lt;any> 元素，我们可以通过任何元素（在 &lt;lastname> 之后）扩展 “person” 的内容： 123456789&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:any minOccurs=&quot;0&quot;/&gt; &lt;/xs:sequence&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 相关属性 id:可选。规定该元素的唯一的 ID。 namespace:可选。规定包含可以使用的元素的命名空间。如果没有指定命名空间，则 ##any 为默认值。如果指定命名空间，则必须是以下值之一。 any - 来自任何命名空间的元素都可以出现（默认）。 other - 来自该元素的父元素的目标命名空间之外的任何命名空间的元素都可以出现。 local - 未由命名空间限定的元素可以出现。 targetNamespace - 来自包含该元素的父元素的目标命名空间的元素可以出现。 {URI references of namespaces, ##targetNamespace, ##local} 的列表 - 来自通过空格分隔的命名空间列表的元素可以出现。 该列表可以包含以下内容： 命名空间 ##targetNamespace 和 ##local 的 URI 引用。 processContents:可选。一个指示符，指示应用程序或 XML 处理器应如何根据由该 any 元素指定的元素处理 XML 文档的验证。 如果没有指定 processContents 属性，则默认为 strict。 如果指定了 processContents，必须是以下值之一。 strict - XML 处理器必须获得所需命名空间的架构，并且必须验证来自这些命名空间的所有元素。（默认） lax - 与 strict 相同；但是，即使不能获取该架构，也不会发生任何错误。 skip - XML 处理器不尝试验证来自指定命名空间的所有元素。 any attributes:可选。规定带有 non-schema 命名空间的任何其他属性。 &lt;anyAttribute>&lt;anyAttribute> 元素使我们有能力通过未被 schema 规定的属性来扩展 XML 文档！下面的例子是来自名为 “family.xsd” 的 XML schema 的一个片段。它为我们展示了针对 “person” 元素的一个声明。通过使用 &lt;anyAttribute> 元素，我们就可以向 “person” 元素添加任意数量的属性： 123456789&lt;xs:element name=&quot;person&quot;&gt; &lt;xs:complexType&gt; &lt;xs:sequence&gt; &lt;xs:element name=&quot;firstname&quot; type=&quot;xs:string&quot;/&gt; &lt;xs:element name=&quot;lastname&quot; type=&quot;xs:string&quot;/&gt; &lt;/xs:sequence&gt; &lt;xs:anyAttribute/&gt; &lt;/xs:complexType&gt;&lt;/xs:element&gt; 元素替换让我们举例说明：我们的用户来自英国和挪威。我们希望有能力让用户选择在 XML 文档中使用挪威语的元素名称还是英语的元素名称。为了解决这个问题，我们可以在 XML schema 中定义一个 substitutionGroup。首先，我们声明主元素，然后我们会声明次元素，这些次元素可声明它们能够替换主元素。 1234567891011&lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot;/&gt;&lt;xs:element name=&quot;navn&quot; substitutionGroup=&quot;name&quot;/&gt;&lt;xs:complexType name=&quot;custinfo&quot;&gt; &lt;xs:sequence&gt; &lt;xs:element ref=&quot;name&quot;/&gt; &lt;/xs:sequence&gt;&lt;/xs:complexType&gt;&lt;xs:element name=&quot;customer&quot; type=&quot;custinfo&quot;/&gt;&lt;xs:element name=&quot;kunde&quot; substitutionGroup=&quot;customer&quot;/&gt; 有效的 XML 文档类似这样（根据上面的 schema）： 123&lt;customer&gt; &lt;name&gt;John Smith&lt;/name&gt;&lt;/customer&gt; 或类似这样： 123&lt;kunde&gt; &lt;navn&gt;John Smith&lt;/navn&gt;&lt;/kunde&gt; 如果需要阻止元素替换，可使用 block 属性： 1&lt;xs:element name=&quot;name&quot; type=&quot;xs:string&quot; block=&quot;substitution&quot;/&gt; 请注意，substitutionGroup 中的所有元素（主元素和可替换元素）必须被声明为全局元素，否则就无法工作！ 全局元素指 “schema” 元素的直接子元素！本地元素（Local elements）指嵌套在其他元素中的元素。 数据类型字符串字符串数据类型（String Data Type）字符串数据类型可包含字符、换行、回车以及制表符。如果您使用字符串数据类型，XML 处理器就不会更改其中的值。 1&lt;xs:element name=&quot;customer&quot; type=&quot;xs:string&quot;/&gt; 规格化字符串数据类型（NormalizedString Data Type）规格化字符串数据类型同样可包含字符，但是 XML 处理器会移除折行，回车以及制表符。 下面是一个关于在某个 schema 中规格化字符串数据类型的例子： 1&lt;xs:element name=&quot;customer&quot; type=&quot;xs:normalizedString&quot;/&gt; 文档中的元素看上去应该类似这样： 1&lt;customer&gt;John Smith&lt;/customer&gt; 或者类似这样： 1&lt;customer&gt; John Smith &lt;/customer&gt; 注释：在上面的例子中，XML 处理器会使用空格替换所有的制表符。 Token 数据类型（Token Data Type）Token 数据类型同样可包含字符，但是 XML 处理器会移除换行符、回车、制表符、开头和结尾的空格以及（连续的）空格。 下面是在 schema 中一个有关 token 声明的例子： 1&lt;xs:element name=&quot;customer&quot; type=&quot;xs:token&quot;/&gt; 文档中的元素看上去应该类似这样： 1&lt;customer&gt;John Smith&lt;/customer&gt; 或者类似这样： 1&lt;customer&gt; John Smith &lt;/customer&gt; 注释：在上面这个例子中，XML 解析器会移除制表符。 字符串数据类型 名称 描述 ENTITIES ENTITY ID 在 XML 中提交 ID 属性的字符串 (仅与 schema 属性一同使用) IDREF 在 XML 中提交 IDREF 属性的字符串(仅与 schema 属性一同使用) IDREFS language 包含合法的语言 id 的字符串 Name 包含合法 XML 名称的字符串 NCName `NCName ::= (Letter ‘_’) (NCNameChar)*&lt;br&gt;NCNameChar ::= Letter Digit ‘.’ ‘-‘ ‘_’ CombiningChar Extender ` NMTOKEN 在 XML 中提交 NMTOKEN 属性的字符串 (仅与 schema 属性一同使用) NMTOKENS normalizedString 不包含换行符、回车或制表符的字符串 QName QName ::= (Prefix &#39;:&#39;)? LocalPartPrefix ::= NCNameLocalPart ::= NCName string 字符串 token 不包含换行符、回车或制表符、开头或结尾空格或者多个连续空格的字符串 对字符串数据类型的限定（Restriction）可与字符串数据类型一同使用的限定： enumeration length maxLength minLength pattern (NMTOKENS、IDREFS 以及 ENTITIES 无法使用此约束) whiteSpace 日期日期数据类型（Date Data Type）日期使用此格式进行定义：”YYYY-MM-DD” 下面是一个有关 schema 中日期声明的例子： 1&lt;xs:element name=&quot;start&quot; type=&quot;xs:date&quot;/&gt; 文档中的元素看上去应该类似这样： 1&lt;start&gt;2002-09-24&lt;/start&gt; 如需规定一个时区，您也可以通过在日期后加一个 “Z” 的方式，使用世界调整时间（UTC time）来输入一个日期 - 比如这样： 1&lt;start&gt;2002-09-24Z&lt;/start&gt; 或者也可以通过在日期后添加一个正的或负时间的方法，来规定以世界调整时间为准的偏移量 - 比如这样： 1&lt;start&gt;2002-09-24-06:00&lt;/start&gt; 或者： 1&lt;start&gt;2002-09-24+06:00&lt;/start&gt; 时间数据类型（Time Data Type）时间使用下面的格式来定义：”hh:mm:ss” 下面是一个有关 schema 中时间声明的例子： 1&lt;xs:element name=&quot;start&quot; type=&quot;xs:time&quot;/&gt; 时区同上 日期时间数据类型（DateTime Data Type）日期时间使用下面的格式进行定义：”YYYY-MM-DDThh:mm:ss” 下面是一个有关 schema 中日期时间声明的例子： 1&lt;xs:element name=&quot;startdate&quot; type=&quot;xs:dateTime&quot;/&gt; 1&lt;startdate&gt;2002-05-30T09:00:00&lt;/startdate&gt; 时区同上 持续时间数据类型（Duration Data Type）时间间隔使用下面的格式来规定：”PnYnMnDTnHnMnS”，其中： P 表示周期(必需) nY 表示年数 nM 表示月数 nD 表示天数 T 表示时间部分的起始 （如果您打算规定小时、分钟和秒，则此选项为必需） nH 表示小时数 nM 表示分钟数 nS 表示秒数 如需规定一个负的持续时间，请在 P 之前输入减号： 1&lt;period&gt;-P10D&lt;/period&gt; 日期和时间数据类型 名称 描述 date 定义一个日期值 dateTime 定义一个日期和时间值 duration 定义一个时间间隔 gDay 定义日期的一个部分 - 天 (DD) gMonth 定义日期的一个部分 - 月 (MM) gMonthDay 定义日期的一个部分 - 月和天 (MM-DD) gYear 定义日期的一个部分 - 年 (YYYY) gYearMonth 定义日期的一个部分 - 年和月 (YYYY-MM) time 定义一个时间值 对日期数据类型的限定（Restriction）可与日期数据类型一同使用的限定： enumeration maxExclusive maxInclusive minExclusive minInclusive pattern whiteSpace 数值十进制数据类型1&lt;xs:element name=&quot;prize&quot; type=&quot;xs:decimal&quot;/&gt; 您可规定的十进制数字的最大位数是 18 位。 整数数据类型1&lt;xs:element name=&quot;prize&quot; type=&quot;xs:integer&quot;/&gt; 数值数据类型 名字 秒数 byte 有正负的 8 位整数 decimal 十进制数 int 有正负的 32 位整数 integer 整数值 long 有正负的 64 位整数 negativeInteger 仅包含负值的整数 ( .., -2, -1.) nonNegativeInteger 仅包含非负值的整数 (0, 1, 2, ..) nonPositiveInteger 仅包含非正值的整数 (.., -2, -1, 0) positiveInteger 仅包含正值的整数 (1, 2, ..) short 有正负的 16 位整数 unsignedLong 无正负的 64 位整数 unsignedInt 无正负的 32 位整数 unsignedShort 无正负的 16 位整数 unsignedByte 无正负的 8 位整数 对数值数据类型的限定（Restriction）可与数值数据类型一同使用的限定： enumeration fractionDigits maxExclusive maxInclusive minExclusive minInclusive pattern totalDigits whiteSpace 杂项其他杂项数据类型包括逻辑、base64Binary、十六进制、浮点、双精度、anyURI、anyURI 以及 NOTATION。 逻辑数据类型（Boolean Data Type）逻辑数据性用于规定 true 或 false 值。 1&lt;xs:attribute name=&quot;disabled&quot; type=&quot;xs:boolean&quot;/&gt; 合法的布尔值是 true、false、1（表示 true） 以及 0（表示 false）。 二进制数据类型（Binary Data Types）二进制数据类型用于表达二进制形式的数据。 我们可使用两种二进制数据类型： base64Binary (Base64 编码的二进制数据) hexBinary (十六进制编码的二进制数据) 下面是一个关于某个 scheme 中 hexBinary 声明的例子： 1&lt;xs:element name=&quot;blobsrc&quot; type=&quot;xs:hexBinary&quot;/&gt; AnyURI 数据类型（AnyURI Data Type）anyURI 数据类型用于规定 URI。 下面是一个关于某个 scheme 中 anyURI 声明的例子： 1&lt;xs:attribute name=&quot;src&quot; type=&quot;xs:anyURI&quot;/&gt; 文档中的元素看上去应该类似这样： 1&lt;pic src=&quot;http://www.w3school.com.cn/images/smiley.gif&quot; /&gt; 注释：假如某个 URI 含有空格，请用 %20 替换它们。 杂项数据类型（Miscellaneous Data Types） anyURI base64Binary boolean double float hexBinary NOTATION QName 对杂项数据类型的限定（Restriction）可与杂项数据类型一同使用的限定： enumeration (布尔数据类型无法使用此约束*) length (布尔数据类型无法使用此约束) maxLength (布尔数据类型无法使用此约束) minLength (布尔数据类型无法使用此约束) pattern whiteSpace]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>XSD</tag>
        <tag>XML Schema</tag>
        <tag>XML</tag>
        <tag>Schema</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[商业模式新生代读书笔记三]]></title>
    <url>%2F2019%2F03%2F12%2F%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E6%96%B0%E7%94%9F%E4%BB%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%89%2F</url>
    <content type="text"><![CDATA[设计 商业人士不仅需要更好的了解设计，他们更需要把自己变成设计师。 ————Roger Martin 客户洞察 创意构思 可视思考 原型创作 故事讲述 情景推测 客户洞察移情图 创意构思4类不同集中点的商业模式创新： 资源驱动 产品/服务驱动 客户驱动 财务驱动 多中心驱动（未纳入四大类之中，是上述四种的混合，更多的表现为业务的重构） 创意构思过程 团队构成：团队是否有足够的多样性，来创造新的商业模式构想 全情投入/头脑风暴：在创新之前，需要研究哪些要素 扩展：针对每个构造块，能够想到哪些创新 条件筛选：什么事商业模式创新的最重要准则 原型创作：每个入围创意的完整商业模式应该是什么样子 头脑风暴的规则 保持聚焦：从问题的精确表述开始，不能跑题太远 执行规则：暂缓判决/一次一议/争取数量/视觉化/鼓励疯狂创意 可视思考：把创意写下来，在每个人都能看得到的平面上描绘出来 做好准备：头脑风暴前要有充分的了解与思考 可视思考将模式描绘出来，这个模式就转换成一个持久的事物，也是一个可以随时返回讨论的概念原点。 视觉化的故事讲述活动 原型制作原型制作可以让概念变得更加形象具体，并能促进新创意的探索。 设计理念 如果过快地专注于一个创意，你就会迷上它。如果急于精雕细琢某个创意，你就会变得依附于它，很难保持不断的探索、不断寻找更好的创意。对于那些不成熟的早期模型尤其需要审慎小心。 Jin Glymph，盖里公司合伙人 具体步骤 故事讲述为什么要讲故事 让新创意不再抽象 让商业模式不再抽象 公司视角 客户视角 让未来变得不再抽象 激发创意 证明变革 要讲的清晰易懂 调动员工的积极性 技巧技巧有很多，要充分了解谁是你的听众，你会出席什么场合，再来选择一种匹配的技巧。 情景推测两种情景推测： 描述不同的客户背景：客户事如何使用产品和服务的，什么类型的客户在使用它们，客户的顾虑、愿望和目的分别是什么 描述新商业模式可能会参与竞争的未来场景：这里的目的不是要去预测未来，而是要具体形象地草绘出未来的各种可能情况。 未来的情景推测和新型商业模式]]></content>
      <tags>
        <tag>商业模式</tag>
        <tag>商业</tag>
        <tag>模式</tag>
        <tag>读书笔记</tag>
        <tag>商业模式设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[商业模式新生代读书笔记二]]></title>
    <url>%2F2019%2F03%2F11%2F%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E6%96%B0%E7%94%9F%E4%BB%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[商业模式式样 建筑中的式样就是将原型和原形的再现抽象为建筑设计的概念 ——Christopher Alexander 商业模式式样 非绑定式商业模式 长尾式商业模式 多边平台式商业模式 免费式商业模式 开放式商业模式 非绑定式商业模式三种基础业务： 客户关系型业务 产品创新型业务 基础设施型业务 长尾式商业模式核心：多样少量 式样 多边平台式商业模式多边平台将两个或者更多有明显区别但有互相依赖的客户群体集合在一起。 式样 免费式商业模式 至少有一个庞大的用户细分群体可以享受持续的免费服务 免费服务可以来自多种模式 通过该商业模式的其他部分或其他客户细分群体，给分服务用户细分群体提供财务支持。 免费广告：多边平台的式样 免费式样 诱钓式样 开放式商业模式开放式商业模式可以用哪些通过与外部伙伴系统合作，来创造和捕捉价值的企业。 由外到内：将外部创意引入到公司内部 由内到外：将企业内部闲置的创意和资产提供给外部伙伴 由外到内的式样 由内到外的式样 总览]]></content>
      <tags>
        <tag>商业模式</tag>
        <tag>商业</tag>
        <tag>模式</tag>
        <tag>读书笔记</tag>
        <tag>商业模式式样</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[商业模式新生代读书笔记一]]></title>
    <url>%2F2019%2F03%2F06%2F%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E6%96%B0%E7%94%9F%E4%BB%A3%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[商业模式画布 商业模式定义：商业模式描述了企业如何创造价值，传递价值和获取价值的基本原理 苹果iPod/iTunes商业模式案例 9个构造块详细说明 CS：客户细分 customer segments VP：价值主张 value propositions CH：渠道通路 channel CR：客户关系 customer relationships R$: 收入来源 revenue streams KR：核心资源 key resources KA：关键业务 key activities KP：重要合作 key partnerships C$：成本结构 cost structure 这9个商业模式构造块组成了构建商业模式边界工具的基础，这个工具我们称之为商业模式画布（Business Model Canvas） 客户细分划分依据： 满足需求的产品服务 分销渠道 类型关系 盈利能力 客户的提供物 价值主张例子：新颖、性能、定制化、成分削减、风险抑制、可达性等 渠道通路 客户关系客户关系被以下几个动机所驱动： 客户获取 客户维系 提升销售额（追加销售） 例子：个人助理、自助服务、社区、共同创作等 收入来源一个商业模式可以包含两种不同类型的收入来源： 通过客户一次性支付获得的交易收入 经常性收入来自客户为获得价值主张与售后服务而持续支付的费用 获取收入的方式：资产销售、使用收费、订阅收费、租赁收费、授权收费等 核心资源核心资源用来描绘让商业模式有效运转所必须的最重要因素 核心资源分类： 实体资产 知识资产 人力资源 金融资源 关键业务关键业务分类： 制造产品 问题解决 平台/网络 重要合作合作关系可以分为以下四类： 在非竞争者之间的战略联盟关系 竟合：在竞争者之间的战略合作关系 为开发新业务而构建的合资关系 为确保可靠供应的购买方——供应商关系 以下三种动机有助于创建合作关系： 商业模式的优化和规模经济的运用 风险和不确定性的降低 特定资源和业务的获取 成本结构两种商业模式成本结构类型： 成本驱动 价值驱动 成本结构有以下特点： 固定成本 可变成本 规模经济 范围经济]]></content>
      <tags>
        <tag>商业模式</tag>
        <tag>商业</tag>
        <tag>模式</tag>
        <tag>读书笔记</tag>
        <tag>商业画布</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浙大邮箱第三方登录设置方法]]></title>
    <url>%2F2019%2F03%2F05%2F%E6%B5%99%E5%A4%A7%E9%82%AE%E7%AE%B1%E7%AC%AC%E4%B8%89%E6%96%B9%E7%99%BB%E5%BD%95%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[第三方邮箱客户端（outlook、foxmail、各种手机自带邮箱APP等）可以选择IMAP或者POP3两种协议中的任意一种进行设置，设置方法如下： 客户端使用IMAP协议设置方法：接收邮件服务器：imap.zju.edu.cn 端口：143 使用SSL端口：993 发送邮件服务器：smtp.zju.edu.cn 端口：25 使用SSL端口：994 客户端使用POP3协议设置方法：接收邮件服务器：pop3.zju.edu.cn 端口：110 使用SSL端口：995 发送邮件服务器：smtp.zju.edu.cn 端口：25 使用SSL端口：994 note: 如果一种不行就试一下另一种，再不行重启试试怎么都不行的时候可能是网络问题，本人的mac用实验室的wifi可以上网却连不上邮箱，但是手机热点就可以]]></content>
      <tags>
        <tag>浙大邮箱</tag>
        <tag>第三方登录</tag>
        <tag>设置方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac显示隐藏文件/文件夹快捷键]]></title>
    <url>%2F2019%2F01%2F13%2Fmac%E6%98%BE%E7%A4%BA%E9%9A%90%E8%97%8F%E6%96%87%E4%BB%B6-%E6%96%87%E4%BB%B6%E5%A4%B9%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Finder（访达）在最前端的时候，三个键一起按下即可 Shift + Command + . 注意：最后一个是点不是逗号]]></content>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[latex:统一图表caption格式]]></title>
    <url>%2F2018%2F12%2F27%2Flatex-%E7%BB%9F%E4%B8%80caption%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[方法通过caption包中的captionsetup来进行格式的统一设定 栗子12345678\usepackage&#123;caption&#125;\captionsetup&#123; labelsep = quad, justification = raggedright, font = &#123;singlespacing,sf&#125;, singlelinecheck=off, skip=4pt, position=top&#125; Captionsetup中具体字段含义及修改方法见：https://blog.csdn.net/stereohomology/article/details/37741591]]></content>
      <tags>
        <tag>latex</tag>
        <tag>caption</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[latex:使用longtable实现表格跨页]]></title>
    <url>%2F2018%2F12%2F27%2Flatex-%E4%BD%BF%E7%94%A8longtable%E5%AE%9E%E7%8E%B0%E8%A1%A8%E6%A0%BC%E8%B7%A8%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[方法使用包\usepackage{longtable}，然后使用\begin{longtable}...\end{longtable}代替tabular即可 注意不能在一个表格上同时使用table和longtable，比如\begin{table}\begin{longtable}...\end{longtable}\end{table}，这会使longtable无法分页。 栗子123456789101112131415161718192021222324252627282930313233343536373839\begin&#123;center&#125; \begin&#123;longtable&#125;&#123;p&#123;2.4cm&#125;p&#123;5.4cm&#125;p&#123;3.6cm&#125;&#125; \caption&#123;服务模式的语义解释和案例&#125;\\ \label&#123;revenuepatternexplain&#125;\\ \hline\noalign&#123;\smallskip&#125; 名称 &amp; 语义解释 &amp; 案例说明 \\ \hline 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ 名称 &amp; 语义解释 &amp; 案例说明 \\ \hline \end&#123;longtable&#125;\end&#123;center&#125;]]></content>
      <tags>
        <tag>latex</tag>
        <tag>long table</tag>
        <tag>表格跨页</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[latex:修改bst使bib引文按照引用顺序排序]]></title>
    <url>%2F2018%2F12%2F27%2Flatex-%E4%BF%AE%E6%94%B9bst%E4%BD%BFbib%E5%BC%95%E6%96%87%E6%8C%89%E7%85%A7%E5%BC%95%E7%94%A8%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[问题使用spring的spbasic.bst模板，结果引文是按照作者名字的字母顺序排序的。 方法 使用任意一款文本编辑器打开spbasic.bst文件 找到其中所有的SORT行 修改为%SORT即可 注意大小写，spbasic.bst中应有两处 如果未生效，可能是bst编译的文件没有更新，试着把bbl文件删除，然后重新编译一下 解释 bst文件什么也不写的话默认是按照引用顺序来排序的 很多模板中有一部分关于排序的函数，使其按照作者名字字母顺序排序 SORT行的作用就是调用这些方法，注释掉之后就变成了默认排序方法]]></content>
      <tags>
        <tag>latex</tag>
        <tag>bib</tag>
        <tag>bst</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML Schema (XSD) 入门]]></title>
    <url>%2F2018%2F11%2F29%2FXMLSchema%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[这是一篇W3school Schema 教程学习笔记。 概要XML Schema 是基于 XML 的 DTD 替代者。XML Schema 描述 XML 文档的结构。XML Schema 语言也称作 XML Schema 定义（XML Schema Definition，XSD）。 简单类型定义简易元素的语法：1&lt;xs:element name="xxx" type="yyy"/&gt; 定义简易属性的语法：1&lt;xs:attribute name="xxx" type="yyy"/&gt; 数据类型的限定 限定 描述 enumeration 定义可接受值的一个列表 fractionDigits 定义所允许的最大的小数位数。必须大于等于0。 length 定义所允许的字符或者列表项目的精确数目。必须大于或等于0。 maxExclusive 定义数值的上限。所允许的值必须小于此值。 maxInclusive 定义数值的上限。所允许的值必须小于或等于此值。 maxLength 定义所允许的字符或者列表项目的最大数目。必须大于或等于0。 minExclusive 定义数值的下限。所允许的值必需大于此值。 minInclusive 定义数值的下限。所允许的值必需大于或等于此值。 minLength 定义所允许的字符或者列表项目的最小数目。必须大于或等于0。 pattern 定义可接受的字符的精确序列。 totalDigits 定义所允许的阿拉伯数字的精确位数。必须大于0。 whiteSpace 定义空白字符（换行、回车、空格以及制表符）的处理方式。 限定的例子对值的限定下面的例子定义了带有一个限定且名为 “age” 的元素。age 的值不能低于 0 或者高于 120： 12345678910&lt;xs:element name="age"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:integer"&gt; &lt;xs:minInclusive value="0"/&gt; &lt;xs:maxInclusive value="120"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对一组值的限定如需把 XML 元素的内容限制为一组可接受的值，我们要使用枚举约束（enumeration constraint）。下面的例子定义了带有一个限定的名为 “car” 的元素。可接受的值只有：Audi, Golf, BMW： 1234567891011&lt;xs:element name="car"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:enumeration value="Audi"/&gt; &lt;xs:enumeration value="Golf"/&gt; &lt;xs:enumeration value="BMW"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对一系列值的限定如需把 XML 元素的内容限制定义为一系列可使用的数字或字母，我们要使用模式约束（pattern constraint）。下面的例子定义了带有一个限定的名为 “letter” 的元素。可接受的值只有小写字母 a - z 其中的一个： 123456789&lt;xs:element name="letter"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:pattern value="[a-z]"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下一个例子定义了带有一个限定的名为 “initials” 的元素。可接受的值是大写字母 A - Z 其中的三个： 123456789&lt;xs:element name="initials"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:pattern value="[A-Z][A-Z][A-Z]"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下一个例子也定义了带有一个限定的名为 “initials” 的元素。可接受的值是大写或小写字母 a - z 其中的三个： 123456789&lt;xs:element name="initials"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:pattern value="[a-zA-Z][a-zA-Z][a-zA-Z]"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下一个例子定义了带有一个限定的名为 “choice 的元素。可接受的值是字母 x, y 或 z 中的一个： 123456789&lt;xs:element name="choice"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:pattern value="[xyz]"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下一个例子定义了带有一个限定的名为 “prodid” 的元素。可接受的值是五个阿拉伯数字的一个序列，且每个数字的范围是 0-9： 123456789&lt;xs:element name="prodid"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:integer"&gt; &lt;xs:pattern value="[0-9][0-9][0-9][0-9][0-9]"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对一系列值的其他限定下面的例子定义了带有一个限定的名为 “letter” 的元素。可接受的值是 a - z 中零个或多个字母： 123456789&lt;xs:element name="letter"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:pattern value="([a-z])*"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下面的例子定义了带有一个限定的名为 “letter” 的元素。可接受的值是一对或多对字母，每对字母由一个小写字母后跟一个大写字母组成。举个例子，”sToP”将会通过这种模式的验证，但是 “Stop”、”STOP” 或者 “stop” 无法通过验证： 123456789&lt;xs:element name="letter"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:pattern value="([a-z][A-Z])+"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下面的例子定义了带有一个限定的名为 “gender” 的元素。可接受的值是 male 或者 female： 123456789&lt;xs:element name="gender"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:pattern value="male|female"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 下面的例子定义了带有一个限定的名为 “password” 的元素。可接受的值是由 8 个字符组成的一行字符，这些字符必须是大写或小写字母 a - z 亦或数字 0 - 9： 123456789&lt;xs:element name="password"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:pattern value="[a-zA-Z0-9]&#123;8&#125;"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对空白字符的限定如需规定对空白字符（whitespace characters）的处理方式，我们需要使用 whiteSpace 限定。下面的例子定义了带有一个限定的名为 “address” 的元素。这个 whiteSpace 限定被设置为 “preserve”，这意味着 XML 处理器不会移除任何空白字符： 123456789&lt;xs:element name="address"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:whiteSpace value="preserve"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 这个例子也定义了带有一个限定的名为 “address” 的元素。这个 whiteSpace 限定被设置为 “replace”，这意味着 XML 处理器将移除所有空白字符（换行、回车、空格以及制表符）： 123456789&lt;xs:element name="address"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:whiteSpace value="replace"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 这个例子也定义了带有一个限定的名为 “address” 的元素。这个 whiteSpace 限定被设置为 “collapse”，这意味着 XML 处理器将移除所有空白字符（换行、回车、空格以及制表符会被替换为空格，开头和结尾的空格会被移除，而多个连续的空格会被缩减为一个单一的空格）： 123456789&lt;xs:element name="address"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:whiteSpace value="collapse"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 对长度的限定如需限制元素中值的长度，我们需要使用 length、maxLength 以及 minLength 限定。本例定义了带有一个限定且名为 “password” 的元素。其值必须精确到 8 个字符： 123456789&lt;xs:element name="password"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:length value="8"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 这个例子也定义了带有一个限定的名为 “password” 的元素。其值最小为 5 个字符，最大为 8 个字符： 12345678910&lt;xs:element name="password"&gt;&lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:minLength value="5"/&gt; &lt;xs:maxLength value="8"/&gt; &lt;/xs:restriction&gt;&lt;/xs:simpleType&gt;&lt;/xs:element&gt; 最常用的类型是： xs:string xs:decimal xs:integer xs:boolean xs:date xs:time 属性的默认值和固定值12&lt;xs:attribute name="lang" type="xs:string" default="EN"/&gt;&lt;xs:attribute name="lang" type="xs:string" fixed="EN"/&gt; 可选和必选1&lt;xs:attribute name="lang" type="xs:string" use="required"/&gt;]]></content>
      <tags>
        <tag>XSD</tag>
        <tag>XML Schema</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac如何卸载pandoc]]></title>
    <url>%2F2018%2F09%2F28%2FMac%E5%A6%82%E4%BD%95%E5%8D%B8%E8%BD%BDpandoc%2F</url>
    <content type="text"><![CDATA[将以下脚本保存到本地，命名为uninstall-pandoc.pl12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#!/usr/bin/perl# Script to remove all files installed by the macOS pandoc installer# and unregister the package. Modified from a script contributed# by Daniel T. Staal.use warnings;use strict;use File::Spec;# The main info: this is the list of files to remove and the pkg_id.my $pkg_id = &apos;net.johnmacfarlane.pandoc&apos;;# Find which, if any, volume Pandoc is installed on.my $volume;# First check /, then other volumes on the box.my $cur_test = `pkgutil --pkgs=$pkg_id`;if ( $cur_test =~ m/$pkg_id/ ) &#123; $volume = &apos;/&apos;;&#125; else &#123; opendir( my $dh, &apos;/Volumes&apos; ) or die &quot;Can&apos;t list Volumes: $!\n&quot;; foreach my $dir ( readdir($dh) ) &#123; next if $dir =~ m/^\./; # Skip dotfiles. my $path = File::Spec-&gt;rel2abs( $dir, &apos;/Volumes&apos; ); next if !( -d $path ); # Skip anything that isn&apos;t a directory. my $cur_test = `pkgutil --pkgs=$pkg_id --volume &apos;$path&apos;`; if ( $cur_test =~ m/$pkg_id/ ) &#123; $volume = $path; last; &#125; &#125;&#125;die &quot;Pandoc not installed.\n&quot; if !( defined($volume) );# Get the list of files to remove.my @pkg_files = `pkgutil --volume &apos;$volume&apos; --only-files --files &apos;$pkg_id&apos;`;@pkg_files = map &#123; chomp; File::Spec-&gt;rel2abs($_, $volume) &#125; @pkg_files;# Confirm uninistall with the user.print &quot;The following files will be deleted:\n\n&quot;;print join(&quot;\n&quot;, @pkg_files);print &quot;\n\n&quot;;print &quot;Do you want to proceed and uninstall pandoc (Y/N)?&quot;;my $input = &lt;STDIN&gt;;if ($input =~ m/^[Yy]/) &#123; # Actually remove the files. foreach my $file (@pkg_files) &#123; if ( -e $file ) &#123; if ( system( &apos;sudo&apos;, &apos;rm&apos;, $file ) == 0 ) &#123; warn &quot;Deleted $file\n&quot;; &#125; else &#123; warn &quot;Unable to delete $file: $?\n&quot;; die &quot;Aborting Uninstall.\n&quot;; &#125; &#125; else &#123; warn &quot;File $file does not exist. Skipping.\n&quot;; &#125; &#125; # Clean up the install. if (system(&apos;sudo&apos;, &apos;pkgutil&apos;, &apos;--forget&apos;, $pkg_id, &apos;--volume&apos;, $volume) != 0) &#123; die &quot;Unable to clean up install: $?\n&quot;; &#125;&#125; else &#123; print &quot;OK, aborting uninstall.\n&quot;; exit;&#125;print &quot;Pandoc has been successfully uninstalled.\n&quot;;exit; 在uninstall-pandoc.pl目录下运行 perl uninstall-pandoc.pl 附：官方链接和截图官方链接：http://pandoc.org/installing.html#macos 截图：]]></content>
      <tags>
        <tag>mac</tag>
        <tag>卸载</tag>
        <tag>pandoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jupyter配置远程访问]]></title>
    <url>%2F2018%2F09%2F19%2Fjupyter%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[安装jupyter pip install ipythonpip install jupyter 生成jupyter配置文件 jupyter notebook –generate-config 12#: jupyter notebook --generate-configWriting default config to: /home/xm/.jupyter/jupyter_notebook_config.py 自动生成密码 jupyter notebook password 12345#: jupyter notebook passwordEnter password: # 这里输入密码不会显示字符的Verify password: [NotebookPasswordApp] Wrote hashed password to /home/xm/.jupyter/jupyter_notebook_config.json# 密码已经被加密记录到这个文件中了 获取密码 cat /home/xm/.jupyter/jupyter_notebook_config.json 123456#: cat /home/xm/.jupyter/jupyter_notebook_config.json&#123; &quot;NotebookApp&quot;: &#123; &quot;password&quot;: &quot;这是你的密码，一整段都复制 下来&quot; &#125;&#125; 修改配置文件 vim /home/xm/.jupyter/jupyter_notebook_config.py 12345#懒得找对应配置项的朋友，直接把这四项配置写到文件开头就可以了c.NotebookApp.ip = &apos;*&apos;c.NotebookApp.password = &apos;sha:ce...刚才复制的那个密文&apos;c.NotebookApp.open_browser = Falsec.NotebookApp.port = 8888 #可自行指定一个端口，访问时使用该端口]]></content>
      <tags>
        <tag>jupyter</tag>
        <tag>远程访问</tag>
        <tag>ipython</tag>
        <tag>notebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux如何查看磁盘可用空间]]></title>
    <url>%2F2018%2F09%2F19%2Flinux%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E7%A3%81%E7%9B%98%E5%8F%AF%E7%94%A8%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[命令 df -h 示例123456789101112USER_MANE@PC_NAME:~$ df -hFilesystem Size Used Avail Use% Mounted onudev 16G 0 16G 0% /devtmpfs 3.2G 26M 3.2G 1% /run/dev/sda1 198G 151G 38G 81% /tmpfs 16G 4.0K 16G 1% /dev/shmtmpfs 5.0M 4.0K 5.0M 1% /run/locktmpfs 16G 0 16G 0% /sys/fs/cgroup/dev/sdb1 917G 290G 581G 34% /SATAtmpfs 3.2G 8.0K 3.2G 1% /run/user/1004tmpfs 3.2G 0 3.2G 0% /run/user/1010tmpfs 3.2G 0 3.2G 0% /run/user/1003]]></content>
      <tags>
        <tag>linux</tag>
        <tag>磁盘</tag>
        <tag>空间</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Trick]-bash: tensorboard: 未找到命令]]></title>
    <url>%2F2018%2F09%2F06%2FTrick-bash-tensorboard-%E6%9C%AA%E6%89%BE%E5%88%B0%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[原因tensorboard命令不在环境变量中 解决思路找到tensorboard脚本路径，然后运行 解决方法1python3 /home/USERNAME/.local/lib/python3.6/site-packages/tensorboard/main.py --logdir=LOGDIR NOTE： USERNAME是指用户名称 LOGDIR是指log文件存放的相对或绝对目录]]></content>
      <tags>
        <tag>linux</tag>
        <tag>trick</tag>
        <tag>tensorboard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Python]通过threading开启多线程]]></title>
    <url>%2F2018%2F08%2F09%2FPython-python%E9%80%9A%E8%BF%87threading%E5%BC%80%E5%90%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[构造方法：Thread(group=None, target=None, name=None, args=(), kwargs={}) group: 线程组，目前还没有实现，库引用中提示必须是None； target: 要执行的方法； name: 线程名； args/kwargs: 要传入方法的参数。 实例方法： isAlive(): 返回线程是否在运行。正在运行指启动后、终止前。 get/setName(name): 获取/设置线程名。 start(): 线程准备就绪，等待CPU调度 is/setDaemon(bool): 获取/设置是后台线程（默认前台线程（False））。（在start之前设置） 如果是后台线程，主线程执行过程中，后台线程也在进行，主线程执行完毕后，后台线程不论成功与否，主线程和后台线程均停止 如果是前台线程，主线程执行过程中，前台线程也在进行，主线程执行完毕后，等待前台线程也执行完成后，程序停止 start(): 启动线程。 join([timeout]): 阻塞当前上下文环境的线程，直到调用此方法的线程终止或到达指定的timeout（可选参数）。 示例代码123456789101112# Split items and run function through n threads# func形如func(arg_list[0], ..., arg_list[n], items),run_through_threads 可以把items分为num份分配给num个线程运行def run_through_threads(func, arg_list, items, num=4): threads = [] item_len = len(items) for i in range(num): threads.append(threading.Thread(target=func, args=(*arg_list, items[int(i*item_len/num):int((i+1)*item_len/num)]))) for t in threads: t.setDaemon(True) t.start() for t in threads: t.join()]]></content>
      <tags>
        <tag>python</tag>
        <tag>python入门</tag>
        <tag>threading</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Python]对dict字典进行排序]]></title>
    <url>%2F2018%2F08%2F08%2FPython-%E5%AF%B9dict%E5%AD%97%E5%85%B8%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[代码12345678910#定义字典dict = &#123;'a':1, 'b':2, 'c':3, 'd':4, 'e':5&#125;#根据key进行排序dict_sorted_by_key = sorted(dict.items(), key=lambda d: d[0])#根据key进行反向排序dict_sorted_by_key_reverse = sorted(dict.items(), key=lambda d: d[0], reverse=True)#根据value进行排序dict_sorted_by_value = sorted(dict.items(), key=lambda d: d[1])#根据value进行反向排序dict_sorted_by_value_reverse = sorted(dict.items(), key=lambda d: d[1], reverse=True) 示例]]></content>
      <tags>
        <tag>python</tag>
        <tag>dict</tag>
        <tag>字典</tag>
        <tag>python入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Python]获取某文件夹下所有文件名]]></title>
    <url>%2F2018%2F08%2F06%2Fpython-%E8%8E%B7%E5%8F%96%E6%9F%90%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6%E5%90%8D%2F</url>
    <content type="text"><![CDATA[导入模块 import os 读取目录下文件 os.listdir() #读取当前工作目录下文件名，返回列表os.listdir(‘/username/folder_name/‘) #读取路径下所有文件名，返回列表]]></content>
      <tags>
        <tag>python</tag>
        <tag>python入门</tag>
        <tag>os</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Trick]git pull 强制覆盖本地文件]]></title>
    <url>%2F2018%2F07%2F31%2FTrick-git-pull-%E5%BC%BA%E5%88%B6%E8%A6%86%E7%9B%96%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[123git fetch --all git reset --hard origin/mastergit pull note：出错的话就再试一次，说不定就可以了]]></content>
      <tags>
        <tag>trick</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Trick]在linux上创建root权限用户（不修改系统文件）]]></title>
    <url>%2F2018%2F07%2F31%2F%E5%9C%A8linux%E4%B8%8A%E5%88%9B%E5%BB%BAroot%E6%9D%83%E9%99%90%E7%94%A8%E6%88%B7%EF%BC%88%E4%B8%8D%E4%BF%AE%E6%94%B9%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[简略过程如我们现在要创建一个名为imonce的新用户： adduser imonce 赋予root权限 usermod -g sudo imonce 万事大吉 详细过程有空再补吧~(‾⌣‾~)]]></content>
      <tags>
        <tag>linux</tag>
        <tag>trick</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程连接mysql报错：1130 - Host '192.168.2.204' is not allowed to connect to this MySQL server]]></title>
    <url>%2F2017%2F04%2F24%2F%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5mysql%E6%8A%A5%E9%94%99%EF%BC%9A1130%20-%20Host%20'192.168.2.204'%20is%20not%20allowed%20to%20connect%20to%20this%20MySQL%20server%2F</url>
    <content type="text"><![CDATA[问题原因MySQL自带配置数据库mysql中的表user中，User=root一栏，Host的值为localhost，导致root用户只能通过本地登录。 解决思路将User=root对应行的Host一栏的值修改为%，允许任意ip登录root。 具体解决方案在本机登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称’%’即可 1234mysql -u root -p mysql&gt;use mysql; mysql&gt;update user set host = &apos;%&apos; where user =&apos;root&apos;; mysql&gt;flush privileges;]]></content>
      <tags>
        <tag>trick</tag>
        <tag>mysql</tag>
        <tag>远程连接报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python入门：pickle模块简介]]></title>
    <url>%2F2017%2F04%2F24%2FPython%E5%85%A5%E9%97%A8%EF%BC%9Apickle%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[概要这篇文章介绍了何为pickle以及pickle模块的简单使用方法，即如何使用pickle进行存储存储以及数据的提取，关于pickle模块的其他更加详细的介绍可以参看https://docs.python.org/2/library/pickle.html pickle简介pickle模块是python中用来持久化对象的一个模块。所谓对对象进行持久化，即将对象的数据类型、存储结构、存储内容等所有信息作为文件保存下来以便下次使用。 就比如说你通过pickle将一个数组保存成了文件，那么当你下次通过pickle将这个文件读取出来的时候，你读取到的依然是一个数组，而不是一个看起来长得像数组的字符串。 用pickle保存对象到文件1234567891011121314151617#导入pickle模块import pickle#创建一个名为data1的对象data1 = &#123;'a': '123', 'b': [1, 2, 3, 4]&#125;#打开(或创建)一个名为data1.pkl的文件，打开方式为二进制写入(参数‘wb’)file_to_save = open("data1.pkl", "wb")#通过pickle模块中的dump函数将data1保存到data1.pkl文件中。#第一个参数是要保存的对象名#第二个参数是写入到的类文件对象file。file必须有write()接口， file可以是一个以'w'方式打开的文件或者一个StringIO对象或者其他任何实现write()接口的对象。如果protocol&gt;=1，文件对象需要是二进制模式打开的。#第三个参数为序列化使用的协议版本，0：ASCII协议，所序列化的对象使用可打印的ASCII码表示；1：老式的二进制协议；2：2.3版本引入的新二进制协议，较以前的更高效；-1：使用当前版本支持的最高协议。其中协议0和1兼容老版本的python。protocol默认值为0。pickle.dump(data1, file_to_save, -1)#关闭文件对象file_to_save.close() 用pickle从文件中读取对象(请接着上一个脚本运行)1234567891011121314#导入pickle模块import pickle#打开一个名为data1.pkl的文件，打开方式为二进制读取(参数‘rb’)file_to_read = open('data1.pkl', 'rb')#通过pickle的load函数读取data1.pkl中的对象，并赋值给data2data2 = pickle.load(file_to_read)#打印data2print data2#关闭文件对象file_to_read.close()]]></content>
      <tags>
        <tag>python</tag>
        <tag>python入门</tag>
        <tag>pickle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[远程连接mysql报错：error 2003 （hy000）:can't connect to mysql server on 'localhost' (10061)]]></title>
    <url>%2F2017%2F04%2F24%2F%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5mysql%E6%8A%A5%E9%94%99%EF%BC%9Aerror%202003%20%EF%BC%88hy000%EF%BC%89-can't%20connect%20to%20mysql%20server%20on%20'localhost'%20(10061)%2F</url>
    <content type="text"><![CDATA[问题原因mysql配置文件中有一句： bind-address = 127.0.0.1 导致mysql只能从本地进行连接。 解决思路找到mysql的配置文件，将这一行注释掉。 具体解决方案去两个配置文件中找这个配置项： /etc/mysql/my.cnf /etc/mysql/mysqld.cnf 在这两个文件的任意一个中找到 bind-address = 127.0.0.1 后，将其修改成： #bind-address = 127.0.0.1 然后执行 service mysql restart重新启动mysql服务使配置生效即可。]]></content>
      <tags>
        <tag>trick</tag>
        <tag>mysql</tag>
        <tag>远程连接报错</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql-python安装错误：EnvironmentError:mysql_config not found]]></title>
    <url>%2F2017%2F04%2F24%2Fmysql-python%E5%AE%89%E8%A3%85%E9%94%99%E8%AF%AF%EF%BC%9AEnvironmentError-%20mysql_config%20not%20found%2F</url>
    <content type="text"><![CDATA[问题描述：安装mysql-python时报错： 12345678910111213141516Collecting mysql-python Using cached MySQL-python-1.2.5.zip Complete output from command python setup.py egg_info: sh: 1: mysql_config: not found Traceback (most recent call last): File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; File &quot;/tmp/pip-build-_itbcX/mysql-python/setup.py&quot;, line 17, in &lt;module&gt; metadata, options = get_config() File &quot;setup_posix.py&quot;, line 43, in get_config libs = mysql_config(&quot;libs_r&quot;) File &quot;setup_posix.py&quot;, line 25, in mysql_config raise EnvironmentError(&quot;%s not found&quot; % (mysql_config.path,)) EnvironmentError: mysql_config not found ----------------------------------------Command &quot;python setup.py egg_info&quot; failed with error code 1 in /tmp/pip-build-_itbcX/mysql-python/ 问题原因：没有安装libmysqlclient-dev。 解决方案：执行： sudo apt-get install libmysqlclient-dev 安装成功后，再运行pip install mysql-python即可。]]></content>
      <tags>
        <tag>python</tag>
        <tag>trick</tag>
        <tag>mysql</tag>
        <tag>mysql-python安装错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chainer入门教程(下)：MNIST手写体识别]]></title>
    <url>%2F2016%2F12%2F15%2FChainer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%8B)-MNIST%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[III. 训练一个手写体识别器在这一部分中，我们将使用MNIST手写数字数据集来尝试区分一个28x28像素的手写体图像。这是一个典型的有监督的深度学习。 对于这个问题，我们将会改变我们之前的线性回归器，同时引入一些隐藏的线性神经网络层，当然，也会引入一些非线性的激活函数。这种类型的架构通常被称为Multilayer Perceptron(MLP)。接下来我们就来看一下它是如何处理眼下的这个任务的。 下面的这一段代码会帮助你下载、引入并结构化MNIST数据集。然而为了完成这部分工作，你还需要下载data.py文件，并把它放在你的工作目录(你的脚本或notebook所在的目录)下以方便导入。 12345678# functions for importing the MNIST dataset.import data# We'll first import the data as a variable mnist.# (If this is the first time you've run this function# it could take a minute or two)mnist = data.load_mnist_data() 现在我们可以先看一下这些图片的样子： 12345678910plt.figure(figsize=(12,5))for i in range(10): example = mnist['data'][i].reshape(28, 28) target = mnist['target'][i] plt.subplot(2, 5, i+1) plt.imshow(example, cmap='gray') plt.title("Target Number: &#123;0&#125;".format(target)) plt.axis("off")plt.tight_layout()plt.show() 现在，我们要把数据集中的图像和对应的真实数字分开，并分成训练集和测试集两部分，以便我们在最后检验我们的学习成果。 1234567# Separate the two parts of the MNIST datasetfeatures = mnist['data'].astype(np.float32) / 255targets = mnist['target'].astype(np.int32)# Make a train/test split.x_train, x_test = np.split(features, [60000])y_train, y_test = np.split(targets, [60000]) 这样一来，我们就可以集中精力训练我们的MLP了。MLP包含一系列不同的layer，Chainer又有一个很不错的方法，这可以帮我们把神经网络中所有的layer都封装到一个对象中。 FunctionSet简介这个方便的对象以命名后的layer作为关键字参数，以便我们之后可以引用它们。FunctionSet工作的方式如下： 1model = FunctionSet(layer1=&lt;place link here&gt;, layer2=&lt;place link here&gt;, ...etc.) 然后layer就会在类的实例中作为属性存在。这些layer都可以通过把FunctionSet实例交给optimizer的setup方法同时进行优化： 1optimizer.setup(model) 理解了这个小tip之后，我们就可以继续构建我们的分类器了。我们需要把一个28x28像素的图像降维成一个10维的单形。输出的每一个维度代表一个具体的数字。 MLP架构为了方便教学以及理解，我们在这里建立一个只有三层的神经网络。 我们需要一个link来引入我们的28x28=784的图像，然后一步一步把它降维到10维。 另外，因为线性函数的组织是线性的，而深度学习又具有引入非线性变换的优点，所以当我们引入一些非线性函数时就会有非常好的重复线性层的堆叠。 因此，在前向传播时，我们希望线性变换层和非线性的激活函数层交替出现。通过这种方法，我们的神经网络可以学习到非线性的数据模型以得到更好的预测结果。最后我们通过一个名为softmax的交叉熵损失函数来比较输出的矢量与我们的原本提取出的答案，然后基于计算出的损失来进行反向传播。 最终我们的前向传播的架构应该是这样的形式： 12345out = linear_layer1(data)out = relu(out)out = linear_layer2(out)out = relu(out)out = linear_layer3(out) 到了训练我们的模型的时候，我们希望能够每次处理一部分的样品并在更新权重前来统计它们的损失。 Define the Model首先，我们通过声明link的集以及在训练过程中要用到的optimizer来定义模型。 123456789101112# Declare the model layers together as a FunctionSetmnist_model = FunctionSet( linear1=L.Linear(784, 300), linear2=L.Linear(300, 100), linear3=L.Linear(100, 10) )# Instantiate an optimizer (you should probably use an# Adam optimizer here for best performance)# and then setup the optimizer on the FunctionSet.mnist_optimizer = optimizers.Adam()mnist_optimizer.setup(mnist_model) 构造训练函数现在我们构造一个合适的函数来进行前向传播、定义训练用的数据集以及生成训练之后对MNIST手写图像进行预测的结果。 12345678910111213141516171819202122232425262728293031323334353637383940414243# Construct a forward pass through the network,# moving sequentially through a layer then activation function# as stated above.def mnist_forward(data, model): out1 = model.linear1(data) out2 = F.relu(out1) out3 = model.linear2(out2) out4 = F.relu(out3) final = model.linear3(out4) return final# Make a training function which takes in training data and targets# as an input.def mnist_train(x, y, model, batchsize=1000, n_epochs=20): data_size = x.shape[0] # loop over epochs for epoch in range(n_epochs): print('epoch %d' % (epoch + 1)) # randomly shuffle the indices of the training data shuffler = np.random.permutation(data_size) # loop over batches for i in range(0, data_size, batchsize): x_var = Variable(x[shuffler[i : i + batchsize]]) y_var = Variable(y[shuffler[i : i + batchsize]]) output = mnist_forward(x_var, model) model.zerograds() loss = F.softmax_cross_entropy(output, y_var) loss.backward() mnist_optimizer.update()# Make a prediction function, using a softmax and argmax in order to# match the target space so that we can validate.def mnist_predict(x, model): x = Variable(x) output = mnist_forward(x, model) return F.softmax(output).data.argmax(1) Train the Model我们现在可以开始训练神经网络了（这里我们使用一个比较小的训练次数和一个比较大的批大小，这样可以帮我们节省一些训练时间。你也可以修改一些参数，说不定就会出现更好的结果呢~） 1mnist_train(x_train, y_train, mnist_model, n_epochs=5) 进行预测最后一件事情就是通过测试集来验证我们的模型的精确度，看看是否出现了过拟合的情况。 12345678# Call your prediction function on the test setpred = mnist_predict(x_test, mnist_model)# Compare the prediction to the ground truth target values.accuracy = (pred==y_test).mean()# Print out test accuracyprint("Test accuracy: %f" % accuracy) out: Test accuracy: 0.965900 可以看到，我们才训练了5次就有了一个96.59%的准确率，amazing~ 模型复用如果你觉得某一次的训练结果不错，想要保存下来以后使用，你可以通过Chainer的serializers来将其保存成hdf5格式： 12serializers.save_hdf5('test.model', mnist_model)serializers.save_hdf5('test.state', mnist_optimizer) 要调出使用的时候也很简单： 12serializers.load_hdf5('my_model.model', model_name)serializers.load_hdf5('my_optimizer.state', optimizer_name) Conclusion通过这篇入门教程，相信大家对于机器学习以及Chainer都有了一定的概念。可以看出，Chainer是一个非常灵活且实用的框架，机器学习也并非难以理解。如果你想进一步Chaier这个框架，个人觉得去看看Chainer的官方文档也是一个不错的选择~ Note:本文译自：Introduction to Chainer: Neural Networks in Python 每日一句：On n’est jamais content là où on est.（人们从来不会满意自己所在的地方。）]]></content>
      <tags>
        <tag>chainer</tag>
        <tag>入门教程</tag>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chainer入门教程(上)：在Chainer中做线性回归]]></title>
    <url>%2F2016%2F12%2F14%2FChainer%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B(%E4%B8%8A)%EF%BC%9A%E5%9C%A8Chainer%E4%B8%AD%E5%81%9A%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[简介神经网络技术在统计建模、数据的转换分类回归等各大领域都有很大的应用空间。但是由于计算本身的复杂性以及早期的计算能力不足，神经网络一直没有得到很大的发展。然而近几年，随着GPU计算的进步，涌现出一大批非常强大而实用的神经网络的训练框架如Caffe、Keras、CUDA convnet、Torch7等。在这片教程中，我们着重介绍另一款灵活又好用的框架：Chainer的基础使用方法。你可以通过Jupyter Notebook或是其他的python终端来跟进这篇教程。 在这篇教程中，我们将先通过编写一个简单的线性回归器来帮助你入门，然后我们再编写一个用于识别MNIST手写数字的标准的深度学习模型来让你熟悉编程逻辑。 首先我们需要安装几个python包： 123456#首先更新一下cython，旧的版本可能会导致chainer安装出错pip install --upgrade cython#再把numpy、matplotlib、chainer都安装一下pip install numpypip install matplotlibpip install chainer I. Chainer基础首先我们要导入这篇教程中要用到的包，关于每个包的作用，之后会有简单的介绍： 12345678#Matplotlib and Numpyimport numpy as npimport matplotlib.pyplot as plt#Chainer Specificfrom chainer import FunctionSet, Variable, optimizers, serializersimport chainer.functions as Fimport chainer.links as L 了解Chainer中Variables和Functions的特点和作用首先，我们通过包裹numpy数组定义两个简单的Chainer Variables变量。数组中只有一个值，这样可以方便我们后续做一些标量运算。 12345# Create 2 chainer variables then sum their squares# and assign it to a third variable.a = Variable(np.array([3], dtype=np.float32))b = Variable(np.array([4], dtype=np.float32))c = a**2 + b**2 在Chainer中，Variables对象既是象征的又是数字的。它们在data属性中包含数据的值，但也包含已在它们上执行的操作链的信息。当你需要训练神经网络时，这段操作历史是非常有用的。我们通过调用backward()方法对变量进行BP或（反向模式）自动分化，这给我们提供了所选择的优化与所有更新我们的神经网络所需要的权重信息。 这个过程之所以可以发生，是因为Chainer的Variables对象把所有对其进行操作的函数都进行了存储，分析了其表达式及导数。你将会使用到的一些函数会是带参的，包含在chainer.links中(这里我们作为L导入)。这些函数的参数将在我们的网络的每个训练迭代中更新。其他包含在chainer.functions(这里我们作为F导入)中的函数将会是无参的，只是对变量执行预定义的数学操作。连加减运算都需要调用Chainer Functions，各变量的操作历史都将保存为变量本身的一部分。这使我们能够计算任何变量的相对于任何其他变量的导数。 下面我们来看一个例子，过程如下： 通过调用data属性检查之前定义的变量 使用backward()方法，对变量c进行反向传播 通过在变量中存储的grad属性，检查其导数 12#Inspect the value of your variables.print("a.data: &#123;0&#125;, b.data: &#123;1&#125;, c.data: &#123;2&#125;".format(a.data, b.data, c.data)) output: a.data: [ 3.], b.data: [ 4.], c.data: [ 25.] 1234#Now call backward() on the sum of squares.c.backward()#And inspect the gradients.print("dc/da = &#123;0&#125;, dc/db = &#123;1&#125;, dc/dc = &#123;2&#125;".format(a.grad, b.grad, c.grad)) output: dc/da = [ 6.], dc/db = [ 8.], dc/dc = [ 1.] II. 在Chainer中做线性回归现在我们知道了一点关于基础的Chainer在做什么，让我们用它来训练最基本的神经网络、线性回归网络。当然，这里所涉及的最小二乘优化的解决方案，通过正常的等式计算分析可能更有效，但这个过程将展示每个网络的基本组成部分，你可以直接进行训练。 这个网络没有隐藏的节点，只涉及一个输入节点，一个输出节点，和一个连接他们两个的线性函数。 我们将要进行下列步骤： 生成随机的线性数据集 通过Chainer Link构造一个前向的网络 构造一个函数来进行网络训练 12345678910# Generate linearly related datasets x and y.x = 30*np.random.rand(1000).astype(np.float32)y = 7*x+10y += 10*np.random.randn(1000).astype(np.float32)plt.scatter(x,y)plt.xlabel('x')plt.ylabel('y')plt.show() 一般来说，在Chainer中想要让你的结构保持共同的神经网络，你需要构造一个forward函数，这个函数会带入你的不同的带参的link函数并在序列中把所有数据运行一遍。 然后，我们需要写一个train函数，它将在你的所有的数据上把forward函数运行epochs次。并且在每次forward之后，都调用loss/objective函数，然后通过optimizer和通过backward方法算出的梯度来更新权重。 Chainer使用者通常会在一开始的时候就定义好Link的层（这里我们只需要一层）。然后他们会通过实例化一个optimizer类来指定要用的优化器。最后，他们会通过调用优化实例的设置方法，告诉optimizer来跟踪和更新指定的模型层的参数，该层将作为一个参数被跟踪。 123456789101112131415161718192021222324252627282930313233343536373839# Setup linear link from one variable to another.linear_function = L.Linear(1,1)# Set x and y as chainer variables, make sure to reshape# them to give one value at a time.x_var = Variable(x.reshape(1000,-1))y_var = Variable(y.reshape(1000,-1))# Setup the optimizer.optimizer = optimizers.MomentumSGD(lr=0.001)optimizer.setup(linear_function)# Define a forward pass function taking the data as input.# and the linear function as output.def linear_forward(data): return linear_function(data)# Define a training function given the input data, target data,# and number of epochs to train over.def linear_train(train_data, train_target,n_epochs=200): for _ in range(n_epochs): # Get the result of the forward pass. output = linear_forward(train_data) # Calculate the loss between the training data and target data. loss = F.mean_squared_error(train_target,output) # Zero all gradients before updating them. linear_function.zerograds() # Calculate and update all gradients. loss.backward() # Use the optmizer to move all parameters of the network # to values which will reduce the loss. optimizer.update() 绘制训练结果下面的代码将会把此模型每次训练5遍，并绘制线性链接中当前的参数下的线。你将会看到模型是如何从蓝色的线收敛到红色的线（最终状态）。 12345678910111213141516# This code is supplied to visualize your results.plt.scatter(x,y, alpha =0.5)for i in range(150): linear_train(x_var, y_var, n_epochs=5) y_pred = linear_forward(x_var).data plt.plot(x, y_pred, color=plt.cm.cool(i/150.), alpha = 0.4, lw =3)slope = linear_function.W.data[0,0]intercept = linear_function.b.data[0]plt.title("Final Line: &#123;0:.3&#125;x + &#123;1:.3&#125;".format(slope, intercept))plt.xlabel('x')plt.ylabel('y')plt.show() Note:本文译自：Introduction to Chainer: Neural Networks in Python 每日一句Oh là là ! C’est incroyable !（艾玛，真是令人难以置信！）]]></content>
      <tags>
        <tag>chainer</tag>
        <tag>入门教程</tag>
        <tag>机器学习</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Reading Notes] Object detection via a multi-region and sematic segmentation-aware CNN model]]></title>
    <url>%2F2016%2F12%2F13%2F%5BReading%20Notes%5D%20Object%20detection%20via%20a%20multi-region%20and%20sematic%20segmentation-aware%20CNN%20model%2F</url>
    <content type="text"><![CDATA[AbstractThis article propose an object detection system that relies on a multi-region deep convolutional neural network that also encodes sematic segmentation-aware features. The module aims at capturing a diverse set of discriminative appearance factors and exhibits localization sensitivity that is essential for accurate object localization. They exploit the above properties of their recognition module by intergrating it on an iterative localization mechanism that alternates between socring a box proposal and refgining its location with a deep CNN regression model. And consiquently, they detect objects with very high localization accuracy. I. IntroductionThe definition of object detection: Given an image return all the instances of one or more type of objects in form of bounding boxes that tightly enclose them. Overfeat: Using two CNN models that apply in a sliding window fashion on multiple scales of an image. The first is used to classify if a window contains an object. The second is to predict the true bounding box location of the object. And use greedy algorithm in the end to merge them. R-CNN: Using Alex Krizhevsky’s Net to extract features from box proposals provided by selective search and then it classifies them with class specific linear SVMs. How to further advance the state-of-the-art on object detection? Focusing on object representation and object localization. Object representation: Indeed features matter a lot on object detection. Instead of proposing only a network architecture that is deeper, here they also opt for an architecture of greater width. And that was accomplished at two levels: They want their object representation to capture several different aspects of an object. To achieve this, they propose a multi-component CNN model (multi-region CNN). Each component of it is steered to focus on a different region. They wish to enrich the above representation so that it also captures semantic segmentation information Object localization: They attempt to built a more powerful localization system that combines their multi-region CNN model with a CNN-model for bounding box regression, which are used within an iterative scheme that alternates between scoring candidate boxes and reﬁning their coordinates. Their Contributions: They develop a multi-region CNN recognition model that yields an enriched object representation capable of capturing a diversity of discriminative appearance factors and of exhibiting localization sensitivity that is desired for the task of accurate object localization. They furthermore extend the above model by proposing a uniﬁed neural network architecture that also learns semantic segmentation-aware CNN features for the task of object detection. They show how to significantly improve the localization capability by coupling the aforementioned CNN recognition model with a CNN model for bounding box regression. Their detection system achieves mAP of 78.2% and 73.9% on VOC2007 and VOC2012 detection challenges respectively. II. Multi-Region CNN Model Activation maps module This part of the network gets as input the entire image and outputs activation maps (feature maps) by forwarding it through a sequence of convolutional layers. Region adaptation module Given a region R on the image and the activation maps of the image, this module projects R on the activation maps, crops the activations that lay inside it, pools them with a spatially adaptive (max-)pooling layer, and then forwards them through a multi-layer network. This is the architecture of the Multi-Region CNN model: There are two aims of that: to force the network to capture various complementary aspects of the objects appearance, thus leading to a much richer and more robust object representation to also make the resulting representation more sensitive to inaccurate localization, which is also crucial for object detection The regions they deploy: Original candidate box Half boxes Central Regions Border Regions Contextual Region Why these regions helps? Discriminative feature diversification Localization-aware representation III. Semantic Segmentation-Aware CNN Model Activation maps module for semantic segmentation aware features Weakly supervised training(see Figure 4) Activation maps Region adaptation module for semantic segmentation aware features They combine the Multi-Region CNN features and the semantic segmentation aware CNN features by concatenating them. The resulting network thus jointly learns deep features of both types during training. IV. Object LocalizationThere are three main components in this section: CNN region adaptation module for bounding box regression It is applied on top of the activation maps produced from the Multi-Region CNN model and, instead of a typical one-layer ridge regression model, consists of two hidden fully connected layers and one prediction layer that outputs 4 values per category. In order to allow it to predict the location of object instances that are not in the close proximity of any of the initial candidate boxes, we Use as region a box obtained by enlarging the candidate box by a factor of 1.3. This combination offers a significant boost on the detection performance of out system by allowing it to make more accurate predictions and for more distant objects. Iterative Localization Their localization scheme starts from the selective search proposals and works by iteratively scoring them and refining their coordinates. Bounding box voting Because of the multiple regression steps, the generated boxes will be highly concentrated around the actual objects of interest. They exploit this “by-product” of the iterative localization scheme by adding a step of bounding box voting. V. Implementation Details For all the CNN models involved in their proposed system, we used the publicly available 16-layers VGG model pre-trained on ImageNet for the task of image classification. Multi-Region CNN model Its activation maps module consistes of the convolustional part of the 16-layers VGG-Net that outputs 512 feature channels. The max-pooling layer right after the last convolutional layer is omitted on this module. Each region adaptation module inherits the fully connected layers of the 16-layers VGG-Net and is fine-tuned separately from the others. Semantic segmentation-aware CNN model The activation maps module architecture consists of the 16-layers VGG-Net without the last classification layer and transformed to a Fully Convolutional Network. Classification SVMs The ground truth bounding boxes are used as positive samples and the selective search proposals that overlap with the ground truth boxes by less than 0.3, are used as negative samples. CNN region adaptation module for bounding box regression The region adaptation module for bounding box regression inherits the fully connected hidden layers of the 16-layers VGG-Net. As a loss function they use the euclidean distance between the target values and the network predictions. VI. Experimental Evaluation Results on PASCAL VOC2007 Detection error analysis Results on PASCAL VOC2012 VII. ConclusionTwo key factors: the diversification of the discriminative appearance factors that it captures by steering its focus on different regions of the object the encoding of semantic segmentation-aware features. By using it in the context of a CNN-based localization refinement scheme, they showed that it achieves excellent results that surpass the state-of-the-are by a significant margin]]></content>
      <tags>
        <tag>Reading Notes</tag>
        <tag>object detection</tag>
        <tag>CNN</tag>
        <tag>multi-region</tag>
        <tag>sematic segmentation-aware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Reading Notes] UniCrawl: A Practical Geographically Distributed Web Crawler]]></title>
    <url>%2F2016%2F12%2F11%2F%5BReading%20Notes%5D%20UniCrawl-%20A%20Practical%20Geographically%20Distributed%20Web%20Crawler%2F</url>
    <content type="text"><![CDATA[AbstractCause the wealth of information available on the web keeps growing, we want to use web crawler to get them. But the traditional method has a fatal limit of its large infrastructure cost. To reduce it, we developed this method, unicrawl, which can show a performance improvement of 93.6% in terms of network bandwidth consumption, and a speedup factor of 1.75. I. introductionNowadays, it’s common that to use parallel process on a large number of machines to achieve a reasonable collection time. While this method requires large computing infrastructures. Like Google and Bing, who rely on big data centers.As for the public crawl repositories, they require externalizing computation and data hosting to a commercial cloud provider. Which may pose the problem of data availability in the mid-long term. And cause there are large amounts of data unnecessary, postprocessing is needed. A solution to those problems is to distribute the crawling effort over several geographically distributed locations. For instance, by allowing several small companies to mutualize their crawling infrastructures. In addition, such an approach leverages data locality as sites can crawl web servers that are geographically nearby. But in this way, the synchronization between the crawler at the different sites is a new problem. Our goal is to reduce such communication costs. UniCrawl is an efficient geo-distributed crawler that aims at minimizing inter-site communication costs. Our design is both practical and scalable. We assess this claim with a detailed evaluation of UniCrawl in a controlled environment using the ClueWeb12 dataset, as well as in geo-distributed setting using 3 distinct sites located in Germany. outline:Section II is related work. Section III introduces the crawler architecture, refining it from existing well-founded central disigns. Section IV is the details about the internal implementaion. Section V presents the experimental results, both in-vitro, and in-vivo over multiple geographical locations in Germany. We discuss out results and future work in Section V. We conclude the paper inSection VII. II. Related workThere are several problems for every crawler to solve: since the amount of information to parse is huge, a crawler must scale a crawler should select which information to download first, and which information to refresh over time a crawler should not be a burden for the web sites that host the content adversaries, e.g., spider traps, need to be avoided with care Mercator/Polybot/IBM WebFountain/Ubicrawl and etc.. III. Distributed crawler architectureA. Single site Design Map-reduce: spill shuffle reduce site storage In UniCrawl, the crawl database of a site is implemented as a single distributed map structure. This map contains for each page its URL, content, and outlinks. INFINISPAN, a distributed key-value store stat supports the following features: Routing: Notes are organized in a ring Elasticity Storage Reliability Interface Consistency Querying Detail of Phases Generate: The goal of the generate phase is to select a set of pages to process during the round. Fetch: During the fetch phase, the map step first groups by host the pages that were generated in the previous phase. Parse: Once the pages are fetched, they are analyzed during the parse phase. Update: The goal of the update phase is to refresh the scores of pages that belong to the frontier in order to prioritize them. B. Multi-site OperationsSeveral key ideas allow UniCrawl to be practical in this setting: Each site is independent and crawls the web autonomously We unite all the site data stores Sites exchanges dynamically the URLs they discover over the course of the crawl Federating the storage: One of the key design concerns of UniCrawl is to bring small monifications to the site code base in order be usable over multiple geographical locations. collaboration between sites: Following the approach advocated by Cho and Garcia-Molina. UniCrawl exchanges newly discovered URLs over time. This exchange occurs at the end of the update phase. We implement the crawl database as a distributed ensemble map that span all the sites. This map operates in frontier mode with a replication factor of one. Crawl quality and cost: The quality of the crawling operation is not only measured by means of pure web-graph exploration but also by the rounds it takes to discover the most interesting pages. IV. ImplementationWe implemented UniCrawl inJava, starting from the code base of Nutch version 2.5.3. Nutch makes use of Apache Gora, an open-source framework that provides an in-memory and persistent data model for big data. Intotal, our contribution accounts for about a dozen thousands lines of code (LOC) split as follows: 9.4 kLOC for Ensemble, 1.1 kLOC for Gora and 2.3 kLOC patch for Nutch A. Merging phasesCause each new map-reduce job creation is expensive as it requires to start a dedicated Java virtual machine, and deploy the appropriate jars. To lower this cost, we merge the fetch and parse phases in out UniCrawl implementation. This means that whenever a reducer fetches a new page, it parses its content and extract the out-links. These links are then directly inserted in the crawl database together with the fetched page. B. CachingTo avoid sending out an URL multiple times across sites, we use a distributed solution. In more details, this cache is a bounded ENSENMBLE map C local to each site and replicated at all nodes in a site. During the update phase, when a reducer selects a URL in the frontier that is associated to a remote site, it first check locally with C is this URL woa previously sent. If this is the case , the reducer simply skips the call to putIfAbsent. Since C is replicated at all nodes, every map-reduce node is co-located with an INFINISPAN node, and C is in memory, this inclusion test costs less than a millisecond. V. EvaluationEvaluate UniCrawl through several key metrics such as the page processing rate, the memory usage and the network traffic across sites. Two parts: Evaluate our approach in-vitro, by running UniCrawl against the ClueWeb12 benchmark in an emulated multi-site architecture and crawling from a local repository. Report several experimental results where we deploy UniCrawl at multiple localtions in Germany and access actual web sites. A. In-vitro validation Single site performance Emulating multiple sites B. UniCrawl in the wild URL Exchange Comparison with Nutch Scalability]]></content>
      <tags>
        <tag>Reading Notes</tag>
        <tag>web</tag>
        <tag>crawler</tag>
        <tag>unicrawl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F12%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[[Reading Notes]Privacy-CNH: A Framework to Detect Photo Privacy with Convolutional Neural Network using Hierarchical Features]]></title>
    <url>%2F2016%2F12%2F10%2F%5BReading%20Notes%5D%20Privacy-CNH-%20A%20Framework%20to%20Detect%20Photo%20Privacy%20with%20Convolutional%20Neural%20Network%20using%20Hierarchical%20Features%2F</url>
    <content type="text"><![CDATA[MotivationMobile devices have revolutionized how people share photos with each other on social networks with a single click of a button. The content of the photos people shared to the internet are rarely analyzed by the websites before the photos are made available to view. After the photos are posted on the social network to the public to view, it is close to impossible to permanently delete the uploaded photos. Photo leakage, regretion after posting and malicious posting happens from time to time. Related WorksExisting works on photo privacy detection, which rely on low-level vision features, are non-informative to the users regarding what privacy information is leaked from their photos. Detailed Design PCNH is a combination of PCNN and PONN. Given the image features in the input layer, the object features learning pipeline processes the features using hi(x) as the activation functions and the param eters of network structure is encoded as Vi, finally obtaining the photo privacy detection result in the output layer. The convolutional features learning pipeline processes the features using j(x) as the activation function and the parameters of network structure is encoded as Ws, finally obtaining the photo privacy detection result in the output layer. hi(x), j(x) are activation functions, which map from a vector to a scalar. Evaluation]]></content>
      <tags>
        <tag>Reading Notes</tag>
        <tag>CNN</tag>
        <tag>PCNH</tag>
        <tag>Privacy Detect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从0到100：zabbix及其支持环境的完整安装教程]]></title>
    <url>%2F2016%2F08%2F08%2F%E4%BB%8E0%E5%88%B0100%EF%BC%9Azabbix%E5%8F%8A%E5%85%B6%E6%94%AF%E6%8C%81%E7%8E%AF%E5%A2%83%E7%9A%84%E5%AE%8C%E6%95%B4%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[版本信息：Ubuntu15.10Apache2.4.12php5.6.11（zabbix3.0要求php版本至少5.4以上）Mysql5.6.31zabbix3.0 前言：本教程包括了ubuntu上LAMP(Linux+Apache+Mysql+Php)环境的搭建以及zabbix安装。因为我们最终是要通过外部计算机访问我们的服务器的，所以我希望你可以先运行一下“ifconfig -a”语句来查看以下自己的IP地址，以方便之后测试服务器。文中将以“IPAddr”来代替你的IP地址，阅读时请注意。这是博主虚拟机上的IP地址： 0.预安装后边会用到的软件，装一下即可：sudo apt-get install vim -y 1.Apache安装在命令行运行下列语句下载apache：sudo apt-get install apache2 -y启动apache服务：sudo /etc/init.d/apache2 start看到下列语句说明启动成功：从其他PC上打开浏览器，输入http://IPAddr，打开页面，如果显示如下，则表示Apache安装成功。 2.安装Mysql在命令行运行下列语句下载mysql：sudo apt-get install mysql-server -y安装的时候会弹出窗口让你设置root帐户的初始密码，根据个人喜好设置一个即可。同样的，安装完了我们也要启动一下mysql的服务：sudo /etc/init.d/mysql start看到下列语句说明启动成功： 3.安装php5在命令行输入下列语句下载php5：sudo apt-get install php5 -y接着安装phpmyadmin：sudo apt-get install phpmyadmin -y安装的过程中根据提示，选择apache2，dbconfig-common那里选择YES，再输入系统root的密码和数据库root的密码即可。版本不同，顺序可能不大一样，总之问什么答什么就对了。顺便改写以下/var/www目录的权限，方便以后编辑网站文件：sudo chmod 777 /var/www创建phpmyadmin的链接：sudo ln -s /usr/share/phpmyadmin /var/www/html/修改一下php5的配置，打开配置文件：sudo vim /etc/php5/apache2/php.ini加入红框中的语句：保存退出。现在在其他的PC上打开浏览器，输入http://IPAddr/phpmyadmin，显示以下页面表示配置成功： 4.安装配置zabbix server###4.1 下载deb：1234cd ~wget http://repo.zabbix.com/zabbix/3.0/ubuntu/pool/main/z/zabbix-release/zabbix-release_3.0-1+trusty_all.debdpkg -i zabbix-release_3.0-1+trusty_all.debapt-get update ###4.2 安装服务器端运行下列语句：sudo apt-get install zabbix-server-mysql zabbix-frontend-php -y安装完成之后试着启动一下zabbix服务,出现下列语句即为成功： ###4.3 配置zabbix_server.conf打开配置文件：sudo vim /etc/zabbix/zabbix_server.conf把对应项的值改为如下(没有的自己在对应位置加上即可)： DBHost=localhost DBName=zabbix DBUser=zabbix DBPassword=zabbix ###4.4 配置mysql1234567891011mysql -u root -p(输入你的数据库root密码)mysql&gt; create database zabbix character set utf8 collate utf8_bin;mysql&gt; grant all privileges on zabbix.* to zabbix@localhost identified by &apos;zabbix&apos;;mysql&gt; flush privileges;mysql&gt; \qcd /usr/share/doc/zabbix-server-mysqlzcat create.sql.gz | mysql -u root -p zabbix（输入你的数据库root密码，点击回车后稍微等一会儿）sudo cp -r /usr/share/zabbix /var/www/html/zabbix/etc/init.d/zabbix-server restart 最后出现下列语句即为成功： ###4.5 配置php编辑php的配置文件：sudo vim /etc/php5/apache2/php.ini把对应项的值改为如下(没有的自己在对应位置加上即可)： post_max_size = 16M max_execution_time = 300 max_input_time = 300 date.timezone = “Asia/Shanghai” 改完之后重启apache2：/etc/init.d/apache2 restart 5.进入zabbix在另外一台PC上打开浏览器，在地址栏输入：http://IPAddr/zabbix显示以下页面：点击右下角的Next step进入Check of pre-requisites页面：这个页面是检测服务器配置是否合格的页面，必须全部为OK才可以点击Next step进入Configure DB connection页面。其中password为zabbix（我们刚刚配置数据库时设置的）。接下来的Zabbix server details和Pre-installation summary两个页面无脑点Next step即可。显示如下页面我们就可以点击Finish了。点击Finish之后出现zabbix server的登录页面，这里Username为Admin，Password为zabbix，最后点击Sign in，大功告成~]]></content>
      <tags>
        <tag>zabbix安装</tag>
        <tag>lamp配置</tag>
      </tags>
  </entry>
</search>
